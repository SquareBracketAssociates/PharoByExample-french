% $Author: oscar $
% $Date: 2009-10-07 14:15:45 +0200 (Wed, 07 Oct 2009) $
% $Revision: 29389 $

% HISTORY: [see also Metaprogramming2.tex]
% 2007-05-22 - Damien Pollet started (translation from French article by ...?)
% 2008-01-15 - Alex added text
% 2008-12-15 - Oscar revised
% 2009-03-24 - Stef started new chapter (acttalk ... see separate file)
% 2009-06-01 - Oscar started to revise again and add new material
% 2009-06-08 - Lukas -- unsent messages
% 2009-06-15 - Oscar completed revision
% 2009-06-16 _ Stef comments
% 2009-06-17 - Alexandre completed revision
% 2009-06-19 - Lukas comments
% 2009-07-07 - Oscar migrated to Pharo; fixed broken tests
% 2009-08-16 - Oscar indexing and cleaning up loose ends

%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
	% \renewcommand{\nnbb}[2]{} % Disable editorial comments
	\sloppy
\fi

%=================================================================
\chapter{La réflexivité}\chalabel{reflection}

%\alex{I addressed lukas comments using editorial macros. Please, if you read this, remove this comment and remove the editorial macros, else their purpose is diminished}

\indexmain{reflection}
\st est un langage de programmation réflexif. Brièvement, cela signifie que les programmes ont la possibilité d'agir sur leur propre exécution et structure.
% \lr{not only on execution, also on the static model}
Plus techniquement, cela signifie que les \emphind{méta-objets} du système en cours d'exécution peuvent être \emph{réifiés} sous forme d'objets ordinaires qui peuvent alors recevoir des requêtes et être inspectés.
Les méta-objets dans \st sont les classes, méta-classes, dictionnaires de méthodes, méthodes compilées, pile d'exécution, etc ...
Cette forme de réflexivité est également appelée \emphind{introspection} et est disponible dans de nombreux langages de programmation.

\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{reflect}
	\caption{Réification et réflexivité.\figlabel{reflect}} % \lr{not referenced, not sure if I understand it}
\end{figure}
Inversement il est possible en \st de modifier les méta-objets réifiés et que leurs modifications soient prises en compte lors de l'exécution du système (voir \figref{reflect}).
Ceci est appelé \emph{intercession} et est principalement utilisé dans les langages de programmation dynamique et de manière plus limitée dans les langages statiques.

Un programme qui manipule d'autres programmes (ou même lui-même) est un \emphind{méta-programme}.
Pour qu'un langage de programmation soit réflexif, il faut qu'il supporte à la fois l'\ind{introspection} et l'\ind{intercession}.

L'introspection est la capacité \emph{d'examiner} les structures de données qui définissent le programme comme les objets, classes, méthodes ou pile d'exécution.
L'intercession est la capacité de modifier ces structures, en d'autre terme de changer la sémantique du langage et le comportement d'un programme depuis le programme lui-même.
La \emph{réflexivité structurelle} s'intéresse à l'exploration et à la modification des structures lors de l'exécution du système, alors que la \emph{réflexivité de comportement} concerne l'interprétation de ces structures.

Dans ce chapitre, nous allons principalement nous intéresser à la \ind{réflexivité structurelle}.
Nous illustrerons avec plusieurs exemples pratiques comment \st supporte l'introspection et la méta-programmation.

%======================================
\section{Introspection}

En utilisant un inspecteur, il est possible d'examiner un objet, de changer les valeurs de ses variables d'instances et même de lui envoyer un message.

\dothis{Évaluer le code qui suit dans un workspace:}
\begin{code}{| w |}
w := Workspace new.
w openLabel: 'My Workspace'.
w inspect
\end{code}

Ceci va ouvrir un deuxième workspace et un inspecteur.
L'inspecteur montre l'état interne de ce nouveau workspace : la liste de ses variables d'instances dans la partie gauche (\ct!dependents!, \ct!contents!, \ct!bindings!...) et la valeur de la variable d'instance sélectionnée dans la partie droite.
La variable d'instance \ct!contents! représente ce que le workspace affiche dans sa zone de texte. Ainsi si vous la sélectionnez, la partie droite montrera une chaîne de caractères vide.

\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{workspaceInspector}
	\caption{Inspecter un \ct!Workspace!.\figlabel{workspaceInspector}}
\end{figure}

\dothis{Maintenant tapez \ct!'hello'! à la place de la chaîne de caractères vide, puis ensuite faites \emph{accept}.}
La valeur de la variable \ct!contents! change, mais la fenêtre du workspace n'en sera pas notifiée, c'est-à-dire qu'elle ne ré-affiche pas son contenu.
Afin d'activer le rafraîchissement de la fenêtre, évaluez \ct!self contentsChanged! dans la partie inférieure de l'inspecteur.

%-----------------------------------------------------------------
\subsection{Accéder aux variables d'instances}

Comment fonctionne l'inspecteur ?
En \st, toutes les variables d'instances sont protégées.
En théorie, il est impossible d'y accéder depuis un autre objet si la classe ne définit pas d'accesseur.
En pratique, l'inspecteur peut accéder aux variables sans avoir besoin d'accesseurs, parce qu'il utilise les capacités réflexives de \st.
En \st, les classes définissent les variables d'instances soient par nom ou au moyen d'indices numériques.
L'inspecteur utilisent des méthodes définies dans la classe \ct!Object! afin d'y accéder :  \lct{instVarAt: \emph{index}} et \lct{instVarNamed: \emph{aString}} peuvent être utilisé pour avoir respectivement la valeur de la variable d'instance à la position \lct{\emph{index}} ou identifié par \lct{\emph{aString}}; pour associer de nouvelles valeurs à ces variables d'instances, on utilise \ct!instVarAt:put:! et \ct!instVarNamed:put:!.
\mthindex{Object}{instVarAt:}
\mthindex{Object}{instVarNamed:}
\mthindex{Object}{instVarAt:put:}
\mthindex{Object}{instVarNamed:put:}

Par exemple, vous pouvez changer la valeur de la variable d'instance \ct!contents! de \ct!w! précédemment définie en évaluant :
\begin{code}{}
w instVarNamed: 'contents' put: 'howdy!'; contentsChanged
\end{code}

\important{\emph{Caveat:} Bien que ces méthodes soient utiles pour construire les outils de l'environnement de développement, les utiliser dans le cadre d'une application conventionnelle est une mauvaise idée: ces méthodes réflexives rompent l'encapsulation des objets et peuvent rendre votre code plus difficile à comprendre et à maintenir.}
% \lr{Why? The access does not show up when looking for all readers/writers in the code browser.}

\ct!instVarAt:! et \ct!instVarAt:put:! sont des \ind{méthodes primitives}, c'est-à-dire qu'elles sont implémentées comme des opérations primitives de la machine virtuelle \pharo.
Si vous consultez le code de ces méthodes, la syntaxe spéciale d'un \ind{pragma} \ct!<primitive: N>! où \ct!N! est un entier.
% \lr{actually this is the syntax of pragmas (method annotations), \ct!primitive:! is just a special kind of pragma}

\needlines{5}
\begin{code}{}
Object>>>instVarAt: index 
	"Primitive. Answer a fixed variable in an object. ..."
	!\textbf{<primitive: 73>}!
	"Access beyond fixed variables."
	^self basicAt: index - self class instSize		
\end{code}

Généralement le code après l'invocation de la primitive n'est pas exécuté. Il est exécuté seulement si la primitive échoue. Dans le cas qui nous intéresse, si on essaie d'accéder à une variable qui n'existe pas, alors le code qui suit la primitive sera essayé. Ceci permet aussi d'utiliser le débogueur sur des méthodes primitives.
Bien qu'il soit possible de modifier le code des méthodes primitives, ceci est risqué pour la stabilité de votre image \pharo.

\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{allInstanceVariables}
	\caption{Afficher toutes les variables d'instance d'un \ct!Workspace!.\figlabel{allInstanceVariables}}
\end{figure}

\figref{AllInstanceVariables} montre comment afficher les valeurs des variables d'instances d'une instance (\ct!w!)  de la classe \ct!Workspace!.
La méthode \ct!allInstVarNames! retourne l'ensemble des noms de variables d'instances d'une classe donnée.

De la même façon, il est possible de collecter les instances qui ont certaines propriétés.
Par exemple, pour avoir toutes les instances de la classe \ct!SketchMorph! dont la variable d'instance \ct!owner! est initialisée avec un morph de type world (\ie les morphs qui sont affichés à chaque instant à l'écran), essayez cette expression:
\begin{code}{}
SketchMorph allInstances select: [:c | (c instVarNamed: 'owner') isWorldMorph]
\end{code}

%-----------------------------------------------------------------
\subsection{Parcourir les variables d'instances}

\mthindex{Object}{instanceVariableValues}
Considérons le message \ct!instanceVariableValues!, qui retourne une collection de toutes les valeurs des variables d'instances définies dans la classe, en excluant les variables d'instances héritées.
Par exemple :
\begin{code}{@TEST}
(1@2) instanceVariableValues --> an OrderedCollection(1 2)
\end{code}

La méthode est implémentée dans \ct{Object} de la manière qui suit :
\needlines{9}
\begin{code}{}
Object>>>instanceVariableValues
	"Answer a collection whose elements are the values of those instance variables of the receiver which were added by the receiver's class."	
	| c |
	c := OrderedCollection new.
	self class superclass instSize + 1
		to: self class instSize
		do: [ :i | c add: (self instVarAt: i)].
	^ c
\end{code}

Cette méthode parcourt par indice les variables d'instances que la classe définit, à partir du dernier index utilisé par les superclasses.
(La méthode \ct!instSize! retourne le nombre des variables d'instances nommées que la classe définit.)

%-----------------------------------------------------------------
\subsection{Faire des requêtes sur les classes et interfaces}

Les outils de développement \pharo (navigateur de code, débogueur, inspecteur, ...) utilisent tous les mécanismes réflexifs que nous avons vu jusqu'à présent.

Voici quelques messages supplémentaires qui peuvent être utiles afin de construire des outils de développement :

\lct{isKindOf: \emph{aClass}} retourne vrai si le receveur est une instance de \lct{\emph{aClass}} ou d'une de ses superclasses.
Par exemple :
\begin{code}{@TEST}
1.5 class                     --> Float
1.5 isKindOf: Number --> true
1.5 isKindOf: Integer   --> false
\end{code}
\mthindex{Object}{class}
\mthindex{Object}{isKindOf:}

\lct{respondsTo: \emph{aSymbol}} retourne vrai si le receveur a une méthode dont le sélecteur est \lct{\emph{aSymbol}}.
Par exemple :
\needlines{3}
\begin{code}{@TEST}
1.5 respondsTo: #floor      --> true    "car Number !implémente! floor"
1.5 floor                            --> 1
Exception respondsTo: #, --> true    "exception classes can be grouped"
\end{code}
\mthindex{Object}{respondsTo:}

\important{\emph{Caveat:} Bien que tous ces outils soient particulièrement utiles pour construire des outils de développements, ils ne sont pas appropriés pour une application classique.
Demander à un objet sa classe ou bien l'interroger pour connaître les messages qu'il comprend, sont un signe indiquant une mauvaise conception objet, puisque généralement cela signifie une violation du principe d'encapsulation.
Les outils de développements ne sont pas considérés comme des applications comme les autres, puisque leur domaine d'applications porte sur le logiciel. Ces outils doivent nécessairement accéder aux détails internes du code.}

%There also exist mechanisms for introspecting on various parts of the run-time system, such as  the process scheduler, the memory manager and so on. For now we will focus on navigating through objects, classes and methods, and we will look more closely at rest of the runtime system in an other chapter.
%\on{let's not mention this if we don't actually write such a chapter!}

%-----------------------------------------------------------------
\subsection{Métriques de code}

Voyons maintenant comment nous pouvons utiliser les mécanismes d'introspection de \st pour rapidement pouvoir construire des métriques de code. Les \ind{métriques} de code mesure certains aspects comme la profondeur de l'arbre d'héritage, le nombre de sous-classes directes ou indirectes, le nombre de méthodes ou de variables d'instances de chaque classe ou enfin le nombre local de méthodes ou de variables d'instances.
Voici quelques résultats de métriques pour la classe \ct!Morph!, qui est la superclasse de tous les objets graphiques de \pharo, révélant qu'il s'agit d'une classe d'une taille conséquente et qu'elle est la racine d'une hiérarchie importante. Peut-être qu'elle nécessiterait d'être refactorisé !

\mthindex{Behavior}{allSuperclasses}
\mthindex{Behavior}{allSelectors}
\mthindex{Behavior}{allInstVarNames}
\mthindex{Behavior}{selectors}
\mthindex{Behavior}{instVarNames}
\mthindex{Behavior}{subclasses}
\mthindex{Behavior}{allSubclasses}
\mthindex{ClassDescription}{linesOfCode}
\begin{code}{}
Morph allSuperclasses size.  -->       2 "profondeur d'!héritage!"
Morph allSelectors size.        --> 1378 "nombre de !méthodes!"
Morph allInstVarNames size. -->      6 "nombre de variables d'instances"
Morph selectors size.             -->  998 "nombre de nouvelles !méthodes!"
Morph instVarNames size.     -->      6 "nombre de nouvelles variables"
Morph subclasses size.          -->    45 "sous-classes directes"
Morph allSubclasses size.      -->  326 "total de sous-classes"
Morph linesOfCode.               --> 5968 "nombre total de lignes de codeBANG"
\end{code}

Une des métriques les plus intéressantes dans le domaine de la programmation par objet est le nombre de méthodes qui étendent les méthodes héritées de la superclasse. Ceci nous informe de la relation entre une classe et ses superclasses.
Dans les prochaines sections, nous verrons comment exploiter notre connaissance des mécanismes d'exécution pour répondre à de telles questions.

%======================================
\section{Parcourir le code}

En \st, tout est objet. Les classes sont en particulier des objets qui fournissent des mécanismes utiles afin de parcourir leurs instances.
La plupart des messages que nous allons voir maintenant sont implémentés dans la classe \ct{Behavior}. Ils sont donc compris de toutes les classes.

Comme nous avons vu précédemment, nous pouvons obtenir une instance particulière d'une classe donnée en lui envoyant le message \ct!#someInstance!.
\mthindex{Behavior}{someInstance}
\begin{code}{@TEST} % Possibly fragile!
Point someInstance --> 0@0
\end{code}

Vous pouvons également rassembler toutes les instances avec \ct!#allInstances! ou déterminer le nombre d'instances en mémoire avec \ct!#instanceCount!.

%\alex{In a Pharo0.1-10342dev09.96.3, I have "ByteString instanceCount --> 63607"}
\mthindex{Behavior}{allInstances}
\mthindex{Behavior}{instanceCount}
\mthindex{Behavior}{allSubInstances}
\begin{code}{} % Cannot test this
ByteString allInstances        --> #('collection' 'position'  ...)
ByteString instanceCount    --> 104565
String allSubInstances size -->  101675
\end{code}

Ces caractéristiques peuvent être très utiles lors du deboguage d'une application, car il est possible de demander à une classe d'énumérer les méthodes possédant des propriétés spécifiques.
\begin{itemize}
\item \mthind{Behavior}{whichSelectorsAccess:} retourne la liste de tous les sélecteurs de méthodes qui lisent ou écrivent dans une variable dont le nom est passé en argument
\item \mthind{Behavior}{whichSelectorsStoreInto:} retourne les sélecteurs des méthodes qui modifient la valeur d'une variable d'instance
\item \mthind{Behavior}{whichSelectorsReferTo:} retourne les sélecteurs des méthodes qui envoie un certain message
\item \mthind{Behavior}{crossReference} associe chaque message avec l'ensemble des méthodes qui l'envoie.
\end{itemize}

\begin{code}{} % TOO FRAGILE TO TEST
Point whichSelectorsAccess: 'x'    --> an IdentitySet(#'\\' #= #scaleBy: ...)
Point whichSelectorsStoreInto: 'x' --> an IdentitySet(#setX:setY: ...)
Point whichSelectorsReferTo: #+  --> an IdentitySet(#rotateBy:about: ...)
Point crossReference --> an Array(
		an Array('*' an IdentitySet(#rotateBy:about: ...))
		an Array('+' an IdentitySet(#rotateBy:about: ...))
		...)
\end{code}

Les messages qui suivent prennent en compte l'héritage :
\begin{itemize}
\item \mthind{Behavior}{whichClassIncludesSelector:} retourne la super-classe qui implémente le message concerné
\item \mthind{Behavior}{unreferencedInstanceVariables} retourne la liste des variables d'instances qui ne sont ni utilisées dans la classe du receveur, ni dans aucune de ses sous-classes
\end{itemize}

\begin{code}{@TEST}
Rectangle whichClassIncludesSelector: #inspect --> Object
Rectangle unreferencedInstanceVariables            --> #()
\end{code}

\clsind{SystemNavigation} is a facade that supports various useful methods for querying and browsing the source code of the system.
\ct{SystemNavigation} \mthind{SystemNavigation class}{default} returns an instance you can use to navigate the system.

\clsind{SystemNavigation} est une façade qui comporte plusieurs méthodes utiles pour examiner et parcourir le code source du système.
\ct{SystemNavigation} \mthind{SystemNavigation class}{default} retourne une instance que vous pouvez utiliser pour naviguer dans le système. 

Par exemple :

\mthindex{SystemNavigation}{allClassesImplementing:}
\begin{code}{@TEST}
SystemNavigation default allClassesImplementing: #yourself --> {Object}
\end{code}

Les messages suivants devraient être également compréhensibles par eux-même :

\mthindex{SystemNavigation}{allSentMessages}
\mthindex{SystemNavigation}{allUnsentMessages}
\mthindex{SystemNavigation}{allUnimplementedCalls}
\begin{code}{}
SystemNavigation default allSentMessages size          --> 24930
SystemNavigation default allUnsentMessages size      --> 6431
SystemNavigation default allUnimplementedCalls size --> 270
\end{code}

Notons que les messages implémentés mais non envoyés ne sont pas nécessairement inutiles, car ils peuvent être envoyés implicitement (\eg en utilisant \ct{perform:}).
Les messages envoyés mais non implémentés sont plus problématiques, car les méthodes envoyant ces messages vont échouer à l'exécution. Ceci peut être le signe d'une implémentation non finie, d'une API obsolète ou bien de librairies manquantes.

\mthindex{SystemNavigation}{allCallsOn:}
\ct!SystemNavigation default allCallsOn: #Point! retourne tous les messages envoyés explicitement à \ct!Point! comme receveur du message.

Toutes ces fonctionnalités sont intégrées dans l'environnement de programmation \pharo, en particulier dans les navigateurs de code.
Comme vous avez déjà pu vous en apercevoir, il existe des raccourcis claviers pour parcourir tous les i\underline{m}plémenteurs (\short{m}) et e\underline{n}voyeurs (\short{n}) d'un message particulier.

Ce qui est moins connu est qu'il existe un certain nombre de méthodes pour faire des requêtes similaires dans le protocole \prot{browsing} dans la classe \ct{SystemNavigation}.

Par exemple, vous pouvez parcourir de manière programmatique tous les implémenteurs du message \ct{ifTrue:} en évaluant:
\mthindex{SystemNavigation}{browseAllImplementorsOf:}
\begin{code}{}
SystemNavigation default browseAllImplementorsOf: #ifTrue:
\end{code}

\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{implementors}
	\caption{Parcourir toutes les implémentations de \ct!\#ifTrue:!.\figlabel{implementors}}
\end{figure}

Des méthodes qui sont particulièrement utiles sont les méthodes \ct{browserAllSelect:} et \lct{browserMethodsWithSourceString:}. 
Voici deux différentes façons de parcourir les méthodes d'un système qui utilisent des appels à super (la première façon est plutôt brutale; la deuxième est meilleure et élimine certains faux positifs):
\mthindex{SystemNavigation}{browseMethodsWithSourceString:}
\mthindex{SystemNavigation}{browseAllSelect:}
\begin{code}{}
SystemNavigation default browseMethodsWithSourceString: 'super'.
SystemNavigation default browseAllSelect: [:method | method sendsToSuper ].
\end{code}

%======================================
\section{Classes, dictionnaires de méthodes et méthodes}

Comme les classes sont des objets, il est possible de les inspecter ou de les explorer de la même manière que les objets.

\mthindex{Object}{explore}
\dothis{\'Evaluer \ct{Point explore}.}

Dans \figref{CompiledMethod}, l'\ind{explorateur} montre la structure de la classe \clsind{Point}.
Vous pouvez remarquer que la classe stocke ses méthodes dans un dictionnaire, indexées par leur sélecteur.
Le sélecteur \ct{#*} pointe vers le \ind{bytecode} décompilé de \ct!Point>>>*!.

\begin{figure}[ht]\centering
	\includegraphics[width=.5\linewidth]{CompiledMethod}
	\caption{l'explorateur de la classe \ct!Point! et le bytecode de sa méthode \ct!\#*! method.\figlabel{CompiledMethod}}
\end{figure}

Examinons la relation entre classes et méthodes.
Dans \figref{MethodsAsObjects} nous voyons que classes et méta-classes ont en commun la superclasse \ct{Behavior}. C'est dans cette superclasse que la méthode \mthind{Behavior}{new} est définie, parmi d'autres méthodes clés pour ces classes.
Chaque classe possède un dictionnaire de méthode, qui associe chaque sélecteur de méthodes à sa \ind{méthode compilée}.
Chaque méthode compilée connait la classe dans laquelle elle est installée.
Dans \figref{CompiledMethod}, nous pouvons même remarquer que l'information est conservée au moyen d'une association dans \ct{literal5}.

\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{MethodsAsObjects}
	\caption{Classes, dictionnaires de méthodes et méthodes compilées\figlabel{MethodsAsObjects}}
\end{figure}

On peut exploiter les relations établies entre classes et méthodes, pour effectuer des requêtes sur le système.
Par exemple, pour connaitre quelles méthodes viennent d'être introduites dans une classe donnée, \ie celles qui ne surchargent pas les méthodes de la superclasse, nous pouvons naviguer depuis la classe vers le dictionnaire de méthodes de cette manière :

\mthindex{Behavior}{methodDict}
\begin{code}{}
[:aClass| aClass methodDict keys select: [:aMethod |
  (aClass superclass canUnderstand: aMethod) not ]] value: SmallInteger
  --> an IdentitySet(#threeDigitName #printStringBase:nDigits: ...)
\end{code}

Une méthode compilée ne stocke pas simplement le bytecode de la méthode.
C'est aussi un objet qui fournit de nombreuses méthodes utiles pour interroger le système. 
Une de ces méthodes se nomme \ct{isAbstract} (qui nous renseigne si la méthode envoie \ct{subclassResponsibility}).
Nous pouvons l'utiliser pour identifier toutes les méthodes abstraites d'une classe abstraite.

\needlines{4}
\begin{code}{}
[:aClass| aClass methodDict keys select: [:aMethod |
  (aClass>>aMethod) isAbstract ]] value: Number
  --> an IdentitySet(#storeOn:base: #printOn:base: #+ #- #* #/ ...)
\end{code}

Remarquez que ce code envoie le message \ct{>>} à la classe pour obtenir la méthode compilée d'un sélecteur donné.

% As a slightly more complex example, we can browse 

Pour parcourir les méthodes d'une classe-mère au sein d'une hiérarchie donnée, par exemple de la hiérarchie de Collections, nous pouvons poser une requête plus sophistiquée : 
\begin{code}{}
class := Collection.
SystemNavigation default
  browseMessageList: (class withAllSubclasses gather: [:each |
    each methodDict associations
      select: [:assoc | assoc value sendsToSuper]
      thenCollect: [:assoc | MethodReference class: each selector: assoc key]])
  name: 'Supersends of ' , class name , ' and its subclasses'
\end{code}
Remarquez comment nous naviguons en partant des classes pour aller vers les dictionnaires de méthodes puis vers les méthodes compilées pour identifier les méthodes recherchées. 
Une \ct{MethodReference} est un proxy léger pour une méthode compilée, utilisé par de nombreux outils.
Il existe une méthode adaptée \clsmthind{CompiledMethod}{methodReference} qui retourne la référence de la méthode pour une méthode compilée.

\begin{code}{@TEST}
(Object>>#=) methodReference methodSymbol --> #=
\end{code}

%======================================
\section{Environnements de navigation du code}

Même si \clsind{SystemNavigation} offre quelques façons utiles d'interroger le système par programmes et de parcourir le code système, il existe une meilleure manière. Le \ind{Refactoring Browser}, qui est intégré dans \pharo, permet de poser des questions complexes à la fois de manière interactive et par programme.

Supposons que nous voulions découvrir quelle méthode dans la hiérarchie \lct{Collection} envoie un message à \super qui soit différent depuis le sélecteur de méthodes. Ceci est généralement considéré comme un mauvais \ind{code smell}, puisque un tel \super-send devrait normalement être remplacé par un \self-send. (Pensez à cela --- vous ne devriez avoir besoin de \super que pour étendre une méthode que vous êtes en train de surcharger; toutes les autres méthodes héritées peuvent être accédées par un \self! )

Le Refactoring Browser nous permet de manière élégante de restreindre nos interrogations uniquement aux classes et méthodes qui nous intéressent. 


\dothis{Ouvrir un Browser sur la classe \ct{Collection}.
\actclick sur le nom de la classe et sélectionner \menu{refactoring scope>subclasses with}.
Ceci ouvrira un nouveau browser Environnement sur la hierarchie \ct{Collection}.
Dans ce champ restreint sélectionner \menu{refactoring scope>super-sends} pour ouvrir un nouvel environnement avec toutes les méthodes qui font des super-sends dans la hiérarchie \ct{Collection}. Maintenant \click sur n'importe quelle méthode et sélectionner \menu{refactor>code critics}.
Naviguer dans \menu{Lint checks>Possible bugs>Sends different super message} et \actclick pour sélectionner \menu{browse}.}

Dans \figref{sendDifferentSuper} nous pouvons voir que 19 méthodes de la sorte ont été trouvées dans la hiérarchie \ct{Collection}, incluant \ct{Collection>>>printNameOn:}, laquelle envoie \ct{super printOn:}.
\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{sendDifferentSuper}
	\caption{Trouver les méthodes qui envoient un message différent de super.
 	\figlabel{sendDifferentSuper}}
\end{figure}

Un environnement de navigation du code peut aussi être créé par programme.
Ici, par exemple, nous créons un nouveau \clsind{BrowserEnvironment} pour \clsind{Collection} et ses sous-classes, nous sélectionnons les méthodes super-sending et nous ouvrons l'environnement résultant.
\needlines{4}
\begin{code}{}
((BrowserEnvironment new forClasses: (Collection withAllSubclasses))
	selectMethods: [:method | method sendsToSuper])
	label: 'Collection methods sending super';
	open.
\end{code}{}

Notez à quel point ce moyen est considérablement plus compact que les exemples précédents utilisant \ct{SystemNavigation}.

Finallement, nous pouvons trouver uniquement les méthodes qui envoient un message différent de super comme ceci :
\needlines{6}
\begin{code}{}
((BrowserEnvironment new forClasses: (Collection withAllSubclasses))
	selectMethods: [:method | 
		method sendsToSuper
		and: [(method parseTree superMessages includes: method selector) not]])
	label: 'Collection methods sending different super';
	open
\end{code}
Dans cet exemple nous demandons à chaque méthode compilée son arbre d'analyse (Refactoring Browser), dans le but de trouver quels super messages diffèrent des sélecteurs de méthodes.  
Regardez le protocole \prot{querying} de la classe \ct{RBProgramNode} pour voir un certain nombre de choses que nous pouvons demander aux arbres d'analyse. 

% Here we ask each compiled method for its (Refactoring Browser) parse tree, in order to find out whether the super messages differ from the method's selector.
% Have a look at the \prot{querying} protocol of the class \ct{RBProgramNode} to see some the things we can ask of parse trees.

%======================================
\section{Accéder au contexte d'exécution}

Nous avons vu comment les capacités réflexives de \st, nous permettent d'interroger et d'explorer les objets, les classes et les méthodes. Qu'en est-il de l'environnement d'exécution ?

%-----------------------------------------------------------------
\subsection{Contextes des méthodes}

En fait, le contexte d'exécution d'une méthode se trouve dans la machine virtuelle et pas dans l'image. Mais visiblement, le \ind{débogueur} a accès à cette information et on peut explorer le contexte d'exécution, comme n'importe quel autre objet ? Comment cela est possible ?

En fait, il n'y rien de magique avec le débogueur.
Le secret réside dans la pseudo-variable \pvind{thisContext}, que nous avons brièvement rencontré précédemment.
Lorsque l'on accède à \ct{thisContext} dans une méthode qui s'exécute, tout le contexte d'exécution de cette méthode est réifié et rendu disponible dans l'image comme une liste chainée d'objets \clsind{MethodContext}.
Nous pouvons facilement expérimenter ce mécanisme par nous-même.

\dothis{Changer la définition de \ct{Integer>>>factorial} en insérant l'expression soulignée ci-dessous:}
\mthindex{Object}{halt}
\begin{code}{}
Integer>>>factorial
	"Answer the factorial of the receiver."
	self = 0 ifTrue: [!\underline{thisContext explore. self halt.}! ^ 1].
	self > 0 ifTrue: [^ self * (self - 1) factorial].
	self error: 'Not valid for negative integers'
\end{code}

\dothis{Maintenant évaluons \ct{3 factorial} dans un espace de travail. Nous devons normalement obtenir une fenêtre de déboguage et un explorateur comme on peut le voir dans \figref{exploringThisContext}.}

\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{exploringThisContext}
	\caption{Explorer \lct{thisContext}.\figlabel{exploringThisContext}}
\end{figure}

Bienvenue dans le débogueur du pauvre ! 
Si maintenant nous parcourons la classe de l'objet exploré (\ie en évaluant \ct{self browse} dans le panneau du bas de l'explorateur), vous aller découvrir que c'est une instance de la classe \lct{MethodContext}, comme tous les \ct{envoyeurs} dans la chaîne.
% All of these objects have been created dynamically in the image by the \st virtual machine at the point where \ct{thisContext} was referred to in the \ct{factorial} method. \lr{Not actually. In all the currently available VMs the context objects are created with every method activation, no matter if they are accessed using \ct{thisContext} or not.}

\ct{thisContext} n'est pas destiné à être utilisé dans la programmation de tous les jours, mais il est essentiel pour réaliser des outils comme des débogueurs et lorsque l'on a besoin d'accéder à des information concernant la pile d'appels de méthodes.
On peut évaluer l'expression suivante pour découvrir quelles méthodes utilisent \ct{thisContext}:

\begin{code}{}
SystemNavigation default browseMethodsWithSourceString: 'thisContext'
\end{code}

Comme on pourrait s'en douter, une des applications les plus répandues est de découvrir l'envoyeur d'un message.
Voici une application courante :
\begin{code}{}
Object>>>subclassResponsibility
	"This message sets up a framework for the behavior of the class' subclasses.
	Announce that the subclass should have implemented this message."

	self error: 'My subclass should have overridden ', thisContext sender selector printString
\end{code}

Par convention, les méthodes \st qui envoient le message \ct{self subclassResponsibility} sont considérées comme abstraites. Mais
comment \clsmthind{Object}{subclassResponsibility} indique un message d'erreur utile indiquant quelle méthode abstraite a été appelée ? Simplement, en interrogant la pseudo-variable \ct{thisContext} de l'envoyeur du message.

%\lr{I think co-routines and continuations should at least mentioned here. Another very practical application that is simple and could be shown here is the ``escaper''. Store the current context into a temp or inst-var \ct{target := thisContext} and jump back to that stack frame at a later point in time using \ct{target return: 123}.}
%\sd{lukas maybe we should have another chapter showing such kind of beasts. I would love to read it. Showing how to use block to build exception and such a kind of point. I think that this chapter should be an introduction may be we should have a Reflection applied chapter}
%\lr{I would love to help writing such a chapter}
%-----------------------------------------------------------------
\subsection{Points d'arrêts intelligents}

\mthindex{Object}{halt}
La façon \st de mettre des points d'arrêts dans un programme consiste à évaluer \ct{self halt} aux endroits correspondants. Ceci va provoquer la réification de \ct{thisContext} et une fenêtre de \ind{déboguage} va s'ouvrir sur ce point d'arrêt.
Malheureusement ceci peut poser des problèmes pour des méthodes qui sont utilisées partout dans le système.

Supposons par exemple, que nous voulons explorer l'exécution de \ct{OrderedCollection>>>add:}.
Mettre un point d'arrêt sur cette méthode est problématique.

\dothis{Prendre une \emph{nouvelle} image et ajouter le point d'arrêt suivant :}
\needlines{3}
\begin{code}{}
OrderedCollection>>>add: newObject
	!\underline{self halt.}!
	^self addLast: newObject
\end{code}

Nous remarquons que notre image se fige instantanément ! Nous n'avons même pas eu de fenêtre de déboguage.
Le problème devient évident lorsque nous comprenons que (i) \ct{OrderedCollection>>>add:} est utilisé en de nombreux endroit du système, de telle sorte que le point d'arrêt est déclenché peut après que nous ayons accepté cette modification et (ii) que le \emph{débogueur lui-même} envoie le message \ct{add:} à une instance de \ct{OrderedCollection}, l'empéchant d'ouvrir la fenêtre de déboguage !
Ce dont nous avons besoin est de pouvoir faire \emph{un point d'arrêt conditionnel} seulement lorsque nous sommes dans le contexte qui nous intéresse.
C'est exactement ce qu'offre \clsmthind{Object}{haltIf:}.

Supposons maintenant que nous voulons arrêter le programme seulement si le message \ct{add} est envoyé dans le contexte de \ct{OrderedCollectionTest>>>testAdd}.

\dothis{Ouvrir une nouvelle image de nouveau et mettre le point d'arrêt ci-dessous :}
\begin{code}{}
OrderedCollection>>>add: newObject
	!\underline{self haltIf: \#testAdd.}!
	^self addLast: newObject
\end{code}

Cette fois ci, l'image ne se fige pas. Essayer d'exécuter \ct{OrderedCollectionTest}.
(Vous pouvez trouver cette classe dans la catégorie \scat{CollectionsTests-Sequenceable}.)

Comment cela fonctionne-t-il ? Regardons le code de \clsmthind{Object}{haltIf:}:
\begin{code}{}
Object>>>haltIf: condition
	| cntxt |
	condition isSymbol ifTrue: [
		"only halt if a method with selector symbol is in callchain"
		cntxt := thisContext.
		[cntxt sender isNil] whileFalse: [
			cntxt := cntxt sender. 
			(cntxt selector = condition) ifTrue: [Halt signal]. ].
		^self.
	].
	...
\end{code}

À partir de \ct!thisContext!, \ct!haltIf:! parcourt la pile d'exécution en vérifiant que le nom de la méthode appelante est le même que celle passé en paramètre. Si c'est le cas, la méthode déclenche une exception qui par défaut déclenche le débogueur.

Il est également possible de fournir une valeur booléenne ou un bloc qui retourne un booléen comme argument de \ct{haltIf:}, mais dans ce cas, cela devient plus simple et on n'utilise pas \ct{thisContext}.

%======================================
\section{Intercepter les messages non compris}
\seclabel{msgnotunderstood}

Pour l'instant, nous avons utilisé les capacités réflexives de \st principalement pour interroger et explorer les objets, classes, méthodes et pile d'exécution du système. Nous allons maintenant voir comment utiliser notre connaissance de \st pour intercepter des messages et modifier le comportement du système à l'exécution.

Lorsque un objet reçoit un message, il regarde d'abord dans son dictionnaire de méthodes pour la méthode correspondante pour répondre au message.
Si aucune méthode correspondante n'existe, il va continuer son exploration en remontant dans la hiérarchie de classe, jusqu'à atteindre la classe \ct{Object}. If still no method is found for that message, the object will \emph{send itself} the message \ct{doesNotUnderstand:} with the message selector as its argument.
The process then starts all over again, until \clsmthind{Object}{doesNotUnderstand:} is found, and the debugger is launched.

But what if \ct{doesNotUnderstand:} is overridden by one of the subclasses of \ct{Object} in the lookup path?
As it turns out, this is a convenient way of realizing certain kinds of very dynamic behaviour. An object that does not understand a message can, by overriding \ct{doesNotUnderstand:}, fall back to an alternative strategy for responding to that message.

Two very common applications of this technique are (1) to implement \ind{lightweight proxies} for objects, and (2) to dynamically compile or load missing code.

%-----------------------------------------------------------------
\subsection{Proxy légers}

In the first case, we introduce a ``\ind{minimal object}'' to act as a proxy for an existing object.
Since the proxy will implement virtually no methods of its own, any message sent to it will be trapped by \ct{doesNotUnderstand:}. By implementing this message, the proxy can then take special action before delegating the message to the real subject it is the proxy for.

Let us have a look at how this may be implemented\footnote{You can also load \pkg{PBE-Reflection} from \url{http://www.squeaksource.com/PharoByExample/}}.

We define a \ct{LoggingProxy} as follows:
\begin{code}{}
ProtoObject subclass: #LoggingProxy
	instanceVariableNames: 'subject invocationCount'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PBE-Reflection'
\end{code}
Note that we subclass \ct{ProtoObject} rather than \ct{Object} because we do not want our proxy to inherit over 400 methods (!) from \ct{Object}.

\begin{code}{}
Object methodDict size --> 408
\end{code}

Our proxy has two instance variables: the \ct{subject} it is a proxy for, and a \ct{count} of the number of messages it has intercepted.
We initialize the two instance variables and we provide an accessor for the message count.
Initially the \ct{subject} variable points to the proxy object itself.
\begin{code}{}
LoggingProxy>>>initialize
	invocationCount := 0.
	subject := self.
\end{code}

\begin{code}{}
LoggingProxy>>>invocationCount
	^ invocationCount
\end{code}

We simply intercept all messages not understood, print them to the Transcript, update the message count, and forward the message to the real subject.
\begin{code}{}
LoggingProxy>>>doesNotUnderstand: aMessage 
	Transcript show: 'performing ', aMessage printString; cr.
	invocationCount := invocationCount + 1.
	^ aMessage sendTo: subject
\end{code}

Here comes a bit of magic.
We create a new \ct{Point} object and a new \ct{LoggingProxy} object, and then we tell the proxy to \mthind{ProtoObject}{become:} the point object:
\seeindex{\ct{become:}}{\ct{ProtoObject>>>become:}}
\begin{code}{}
point := 1@2.
LoggingProxy new !\underline{become:}! point.
\end{code}

This has the effect of swapping all references in the image to the point to now refer to the proxy, and vice versa. Most importantly, the proxy's \ct{subject} instance variable will now refer to the point!

\begin{code}{}
point invocationCount --> 0
point + (3@4)             --> 4@6
point invocationCount --> 1
\end{code}

This works nicely in most cases, but there are some shortcomings:
\begin{code}{}
point class --> LoggingProxy
\end{code}
Curiously, the method \ct{class} is not even implemented in \ct{ProtoObject} but in \ct{Object}, which \ct{LoggingProxy} does not inherit from!
The answer to this riddle is that \ct{class} is never sent as a message but is directly answered by the virtual machine.\footnote{\ct{yourself} is also never truly sent.
Other messages that may be directly interpreted by the VM, depending on the receiver, include:
\ct{+- < > <= >= = ~= * / \ ==}
\ct{@ bitShift: // bitAnd: bitOr:}
\ct{at: at:put: size}
\ct{next nextPut: atEnd}
\ct{blockCopy: value value: do: new new: x y}.
Selectors that are never sent, because they are inlined by the compiler and transformed to comparison and jump bytecodes:
\ct{ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:}
\ct{and: or:}
\ct{whileFalse: whileTrue: whileFalse whileTrue}
\ct{to:do: to:by:do:}
\ct{caseOf: caseOf:otherwise:}
\ct{ifNil: ifNotNil:  ifNil:ifNotNil: ifNotNil:ifNil:}
Attempts to send these messages to non-boolean objects can be intercepted and execution can be resumed with a valid boolean value by overriding \ct{mustBeBoolean} in the receiver or by catching the \ct{NonBooleanReceiver} exception.
}% NB: Notes by Lukas Renggli

Even if we can ignore such special message sends, there is another fundamental problem which cannot be overcome by this approach: \self-sends cannot be intercepted:
\begin{code}{}
point := 1@2.
LoggingProxy new become: point.
point invocationCount --> 0
point rect: (3@4)        --> 1@2 corner: 3@4
point invocationCount --> 1
\end{code}

Our proxy has been cheated out of two \self-sends in the \ct{rect:} method:
\begin{code}{}
Point>>>rect: aPoint 
	^ Rectangle  origin: (self min: aPoint) corner: (self max: aPoint)
\end{code}

Although messages can be intercepted by proxies using this technique, one should be aware of the inherent limitations of using a proxy.  In \secref{wrapper} we will see another, more general approach for intercepting messages.

%-----------------------------------------------------------------
\subsection{Générer des méthodes manquantes}

The other most common application of intercepting not understood messages is to dynamically load or generate the missing methods.
Consider a very large library of classes with many methods.  Instead of loading the entire library, we could load a stub for each class in the library. The stubs know where to find the source code of all their methods.  The stubs simply trap all messages not understood, and dynamically load the missing methods on-demand.  At some point, this behaviour can be deactivated, and the loaded code can be saved as the minimal necessary subset for the client application.

%\on{Stef sez: check ObjectOut -- I looked, but this seems to be very old. Depends on SqueakPage.}

Let us look at a simple variant of this technique where we have a class that automatically adds accessors for its instance variables on-demand:
% \lr{the last statement should return the result of the message, otherwise you cannot proceed with the debugger} \alex{all redefinition of doesNotUnderstand: includes a return statement. However, I do not see your comment lukas, I tried to insert a 'self halt' in the method, I was able to proceed. I added the return in the function} \lr{Of course it depends on the exact circumstances. If you perform a message on self that returns self it does not matter, but in any other case a forgotten return can introduce strange side effects. There was no return in the listing below, but now there is and the problem is solved.}

\begin{code}{}
DynamicAcccessors>>>doesNotUnderstand: aMessage
	| messageName |
	messageName := aMessage selector asString.
	(self class instVarNames includes: messageName)
		ifTrue: [
			self class compile: messageName, String cr, ' ^ ', messageName.
			^ aMessage sendTo: self ].
	^ super doesNotUnderstand: aMessage
\end{code}
Any message not understood is trapped here. If an instance variable with the same name as the message sent exists, then we ask our class to compile an accessor for that instance variables and we re-send the message.

Suppose the class \ct{DynamicAcccessors} has an (uninitialized) instance variable \ct{x} but no pre-defined accessor. Then the following will generate the accessor dynamically and retrieve the value:
\needlines{2}
\begin{code}{}
myDA := DynamicAccessors new.
myDA x --> nil
\end{code}

Let us step through what happens the first time the message \ct{x} is sent to our object (see \figref{DynamicAccessors}).

\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{DynamicAccessors}
	\caption{Création dynamique d'accesseurs.\figlabel{DynamicAccessors}}
	% \alex{not sure whether the figure is highly necessary. The code is rather simple and the figure complete to follow in my opinion.}}
	% \on{trust me, it is useful to see all the steps.}
\end{figure}

(1) We send \ct{x} to \ct{myDA}, (2) the message is looked up in the class, and (3) not found in the class hierarchy. (4) This causes \ct{self doesNotUnderstand: #x} to be sent back to the object, (5) triggering a new lookup. This time \ct{doesNotUnderstand:} is found immediately in \ct{DynamicAccessors}, (6) which asks its class to compile the string \ct{'x ^ x'}. The \ct{compile} method is looked up (7), and (8) finally found in \ct{Behavior}, which (9-10) adds the new compiled method to the method dictionary of \ct{DynamicAccessors}. Finally, (11-13) the message is resent, and this time it is found.

The same technique can be used to generate setters for instance variables, or other kinds of boilerplate code, such as visiting methods for a Visitor.

Note the use of \clsmthind{Object}{perform:} in step (13) which can be used to send messages that are composed at run-time:
\begin{code}{@TEST}
5 perform: #factorial                                             --> 120
6 perform: ('fac', 'torial') asSymbol                       --> 720
4 perform: #max: withArguments: (Array with: 6) --> 6
\end{code}

%======================================
\section{Objects as method wrappers}
\seclabel{wrapper}

We have already seen that compiled methods are ordinary objects in \st, and they support a number of methods that allow the programmer to query the run-time system.
What is perhaps a bit more surprising, is that \emph{any object} can play the role of a compiled method. All it has to do is respond to the method \ct{run:with:in:} and a few other important messages.

\dothis{Define an empty class \ct{Demo}. Evaluate \ct{Demo new answer42} and notice how the usual ``Message Not Understood'' error is raised.}

Now we will install a plain \st object in the method dictionary of our \ct{Demo} class.

\dothis{Evaluate \lct{Demo methodDict at: \#answer42 put: ObjectsAsMethodsExample new.}
Now try again to print the result of \ct{Demo new answer42}. This time we get the answer \ct{42}.}

If we take look at the class \clsind{ObjectsAsMethodsExample} we will find the following methods:
%\alex{I would prefer having return 42 in the run:with:in: method, and not having answer42 defined in ObjectsAsMethodsExample, this could be confusing I imagine}
%\on{ObjectsAsMethodsExample is part of the standard pharo image -- it is not in PBE-Reflection}
\needlines{5}
\begin{code}{}
answer42
	^42

run: oldSelector with: arguments in: aReceiver
	^self perform: oldSelector withArguments: arguments
\end{code}

When our \ct{Demo} instance receives the message \ct{answer42}, method lookup proceeds as usual, however the virtual machine will detect that in place of a compiled method, an ordinary \st object is trying to play this role.
The VM will then send this object a new message \ct{run:with:in:} with the original method selector, arguments and receiver as arguments.
Since \ct{ObjectsAsMethodsExample} implements this method, it intercepts the message and delegates it to itself.

We can now remove the fake method as follows:
\begin{code}{}
Demo methodDict removeKey: #answer42 ifAbsent: []
\end{code}

If we take a closer look at \ct{ObjectsAsMethodsExample}, we will see that its superclass also implements the methods \ct{flushcache}, \ct{methodClass:} and \lct{selector:}, but they are all empty.  These messages may be sent to a compiled methods, so they need to be implemented by an object pretending to be a compiled method.  (\ct{flushcache} is the most important method to be implemented; others may be required depending on whether the method is installed using \clsmthind{Behavior}{addSelector:withMethod:} or directly using \clsmthind{MethodDictionary}{at:put:}.)

%-------------------------------------------------------------------------
\subsection{Using methods wrappers to perform test coverage}

Method wrappers are a well-known technique for intercepting messages \cite{Bran98a}.
In the original implementation\footnote{http://www.squeaksource.com/MethodWrappers.html}, a method wrapper is an instance of a subclass of \ct{CompiledMethod}. When installed, a method wrapper can perform special actions before or after invoking the original method.
When uninstalled, the original method is returned to its rightful position in the method dictionary.

In Pharo, \ind{method wrappers} can be implemented more easily by implementing \ct{run:with:in:} instead of by subclassing \ct{CompiledMethod}. In fact, there exists a lightweight implementation of objects as method wrappers\footnote{http://www.squeaksource.com/ObjectsAsMethodsWrap.html}, but it is not part of standard Pharo at the time of this writing.

Nevertheless, the Pharo Test Runner uses precisely this technique to evaluate test coverage.
Let's have a quick look at how it works.

The entry point for test coverage is the method \clsmthind{TestRunner}{runCoverage}:
\begin{code}{}
TestRunner>>>runCoverage
	| packages methods |
	... "identify methods to check for coverage"
	self collectCoverageFor: methods
\end{code}

The method \clsmthind{TestRunner}{collectCoverageFor:} clearly illustrates the coverage checking algorithm:
\begin{code}{}
TestRunner>>>collectCoverageFor: methods
	| wrappers suite |
	wrappers := methods collect: [ :each | TestCoverage on: each ].
	suite := self
		reset;
		suiteAll.
	[ wrappers do: [ :each | each install ].
	  [ self runSuite: suite ] ensure: [ wrappers do: [ :each | each uninstall ] ] ] valueUnpreemptively.
	wrappers := wrappers reject: [ :each | each hasRun ].
	wrappers isEmpty 
		ifTrue: 
			[ UIManager default inform: 'Congratulations. Your tests cover all code under analysis.' ]
		ifFalse: ...
\end{code}
A wrapper is created for each method to be checked, and each wrapper is installed.
The tests are run, and all wrappers are uninstalled.
Finally the user obtains feedback concerning the methods that have not been covered.

How does the wrapper itself work?
The \ct{TestCoverage} wrapper has three instance variables, \ct{hasRun}, \ct{reference} and \ct{method}.
They are initialized as follows:
\begin{code}{}
TestCoverage class>>>on: aMethodReference
	^ self new initializeOn: aMethodReference

TestCoverage>>>initializeOn: aMethodReference
	hasRun := false.
	reference := aMethodReference.
	method := reference compiledMethod
\end{code}

The install and uninstall methods simply update the method dictionary in the obvious way:
\begin{code}{}
TestCoverage>>>install
	reference actualClass methodDictionary
		at: reference methodSymbol
		put: self

TestCoverage>>>uninstall
	reference actualClass methodDictionary
		at: reference methodSymbol
		put: method
\end{code}
\noindent
and the \ct{run:with:in:} method simply updates the \ct{hasRun} variable, uninstalls the wrapper (since coverage has been verified), and resends the message to the original method
\begin{code}{}
run: aSelector with: anArray in: aReceiver
	self mark; uninstall.
	^ aReceiver withArgs: anArray executeMethod: method

mark
	hasRun := true
\end{code}
(Have a look at \clsmthind{ProtoObject}{withArgs:executeMethod:} to see how a method displaced from its method dictionary can be invoked.)

That's all there is to it!

Method wrappers can be used to perform any kind of suitable behaviour before or after the normal operation of a method.  Typical applications are instrumentation (collecting statistics about the calling patterns of methods), checking optional pre- and post-conditions, and memoization (optionally cacheing computed values of methods).

%======================================
\section{Pragmas}

Un \emphind{pragma} est une annotation qui donne des information sur un programme, mais qui n'est pas directement impliqué dans l'exécution de ce programme. Les pragmas n'ont pas d'effet direct lors du déroulement d'une méthode annotée.
Les pragmas sont très utiles notamment pour :
\begin{itemize}
\item Donner de l'information au compilateur : les \indmain{pragmas} peuvent être utilisés par le compilateur pour qu'une méthode appelle une fonction primitive. Cette fonction doit être définie par la machine virtuelle ou au moyen d'un greffon externe.
\item Donner de l'information à l'exécution.
\end{itemize}

Les pragmas s'utilisent uniquement lors de la déclaration des méthodes d'un programme. Une méthode peut déclarer un ou plusieurs pragmas qui sont écrits avant toutes expressions Smalltalk. En réalité, un pragma défini une sorte de message statique avec des arguments qui sont des litéraux.

Nous avons déjà parlé brièvement des pragmas lorsque nous avons briévement introduit la notion de primitives précédemment dans ce chapitre. Une primitive n'est rien moins qu'une déclaration de pragma. 
Consider \ct{<primitive: 73>} as contained in \ct{instVarAt:}. The pragma's selector is \ct{primitive:} and its arguments is an immediate literal value, \ct{73}. 

Le compilateur Smalltalk est probablement l'un des utilisateurs les plus important des pragmas. SUnit is another tool that makes use of annotations. SUnit is able to estimate the coverage of an application from a test unit. One may want to exclude some methods from the coverage. This is the case of the \ct!documentation! method in \ct!SplitJointTest class!:

\begin{code}{}
SplitJointTest class>>>documentation
	<ignoreForCoverage>
	"self showDocumentation"
	
	^ 'This package provides function.... "
\end{code}

By simply annotating a method with the pragma \ct!<ignoreForCoverage>! one can control the scope of the coverage.

%Beside the compiler, Lint is a heavy user of pragmas. Lint is a static code analyzer that flags suspicious, non-portable constructs and code that is likely to contain bugs. It may happen that a method needs to be excluded from Lint analysis. This is the case here:

%\begin{code}{}
%MorphObjectOut>>>doesNotUnderstand: aMessage 
%	"Bring in the object, install, then resend aMessage"
%	"Transcript show: thisContext sender selector; cr."
%	"useful for debugging"
%	
%	! \textbf{<lint: 'Unnecessary "= true"' rationale: 'recursionFlag may be nil' author: 'stephane.ducasse'>}!
%	...
%\end{code}	

%One of the pragmas used by Lint to filter out methods is \ct{lint:rationale:author:}.

As instances of the class \clsind{Pragma}, pragmas are first class objects. A compiled method answers to the message \mthind{CompiledMethod}{pragmas}. This method returns an array of pragmas. 

\begin{code}{@TEST}
(SplitJoinTest class >> #showDocumentation) pragmas
  --> an Array(<ignoreForCoverage>)
(Float>>#+) pragmas --> an Array(<primitive: 41>)
\end{code}

Methods defining a particular query may be retrieved from a class. The class side of \ct!SplitJoinTest! contains some methods annotated with \ct!<ignoreForCoverage>!:

\begin{code}{@TEST}
Pragma allNamed: #ignoreForCoverage in: SplitJoinTest class  --> an Array(<ignoreForCoverage> <ignoreForCoverage> <ignoreForCoverage>)
\end{code}

A variant of \ct{allNamed:in:} may be found on the class side of \ct{Pragma}.

A pragma knows in which method it is defined (using \ct{method}), the name of the method (\ct{selector}), the class that contains the method (\ct{methodClass}), its number of arguments (\ct{numArgs}), about the literals the pragma has for arguments (\ct{hasLiteral:} and \ct{hasLiteralSuchThat:}). 

%\lr{Typically pragmas are performed on an interpreter object that understands the pragma message.}

%======================================
\section{Résumé du chapitre}

Reflection refers to the ability to query, examine and even modify the metaobjects of the run-time system as ordinary objects.

\begin{itemize}
\item The Inspector uses \ct{instVarAt:} and related methods to query and modify ``private'' instance variables of objects.
\item Send \ct{Behavior>>>allInstances} to query instances of a class.
\item The messages \ct{class}, \ct{isKindOf:}, \ct{respondsTo:} \etc  are useful for gathering metrics or building development tools, but they should be avoided in regular applications: they violate the encapsulation of objects and make your code harder to understand and maintain.
\item \ct{SystemNavigation} is a utility class holding many useful queries for navigation and browsing the \ct class hierarchy. For example, use \ct{SystemNavigation default browseMethodsWithSourceString: 'pharo'.} to find and browse all methods with a given source string. (Slow, but thorough!)
\item Every \st class points to an instance of \ct{MethodDictionary} which maps selectors to instances of \ct{CompiledMethod}. A compiled method knows its class, closing the loop.
\item \ct{MethodReference} is a leightweight proxy for a compiled method, providing additional convenience methods, and used by many \st tools. 
\item \ct{BrowserEnvironment}, part of the Refactoring Browser infrastructure, offers a more refined interface than \ct{SystemNavigation} for querying the system, since the result of a query can be used as a the scope of a new query. Both GUI and programmatic interfaces are available.
\item \ct{thisContext} is a pseudo-variable that reifies the run-time stack of the virtual machine. It is mainly used by the debugger to dynamically construct an interactive view of the stack. It is also especially useful for dynamically determining the sender of a message.
\item Intelligent breakpoints can be set using \ct{haltIf:}, taking a method selector as its argument. \ct{haltIf:} halts only if the named method occurs as a sender in the run-time stack.
\item A common way to intercept messages sent to a given target is to use a ``minimal object'' as a proxy for that target. The proxy implements as few methods as possible, and traps all message sends by implementing \ct{doesNotunderstand:}. It can then perform some additional action and then forward the message to the original target.
\item Send \ct{become:} to swap the references of two objects, such as a proxy and its target.
\item Beware, some messages, like \ct{class} and \ct{yourself} are never really sent, but are interpreted by the VM.  Others, like \ct{+}, \ct{-} and \ct{ifTrue:} may be directly interpreted or inlined by the VM depending on the receiver.
\item Another typical use for overriding \ct{doesNotUnderstand:} is to lazily load or compile missing methods.
\item \ct{doesNotUnderstand:} cannot trap \self-sends.
\item A more rigorous way to intercept messages is to use an object as a method wrapper. Such an object is installed in a method dictionary in place of a compiled method. It should implement \ct{run:with:in:} which is sent by the VM when it detects an ordinary object instead of a compiled method in the method dictionary. This technique is used by the SUnit Test Runner to collect coverage data.
\end{itemize}

%=========================================================
\ifx\wholebook\relax\else
   \bibliographystyle{jurabib}
   \nobibliography{scg}
   \end{document}
\fi
%=========================================================

%Other stuff:
%- anonymous classes (uses compile: and primitiveChangeClassTo:) ???
%- collect direct senders; class collaborations
%- Object primitiveChangeClassTo: become: and becomeForward: (see tests and slides with minimal object example)
%- PointerFinder?
%- anonymous classes (see slides) ?

%Test  Coverage using ObjectsAsMethodsWrap package:
%\begin{code}{}
%category := 'SCGPier'.
%w := (ObjectAsOneTimeMethodWrapper installOnClassCategory: category).
%tr := TestRunner new.
%ToolBuilder open: tr.
%[tr
%	categoryAt: (tr categoryList indexOf: 'SCGPier') put: true;
%	selectAllClasses;
%	runAll.]
%ensure: [[w do: [:each| each uninstall ]] valueUnpreemptively].
%((w select: [:each | each executed not ])
%	collect: [:each | each wrappedClass name, '>>', each selector name ]) explore.
%\end{code}
