% $Author: oscar $
% $Date: 2009-10-07 14:15:45 +0200 (Wed, 07 Oct 2009) $
% $Revision: 29389 $

% HISTORY: [see also Metaprogramming2.tex]
% 2007-05-22 - Damien Pollet started (translation from French article by ...?)
% 2008-01-15 - Alex added text
% 2008-12-15 - Oscar revised
% 2009-03-24 - Stef started new chapter (acttalk ... see separate file)
% 2009-06-01 - Oscar started to revise again and add new material
% 2009-06-08 - Lukas -- unsent messages
% 2009-06-15 - Oscar completed revision
% 2009-06-16 _ Stef comments
% 2009-06-17 - Alexandre completed revision
% 2009-06-19 - Lukas comments
% 2009-07-07 - Oscar migrated to Pharo; fixed broken tests
% 2009-08-16 - Oscar indexing and cleaning up loose ends
% 2011-06-15 - Rene re-read french translation

%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
	\renewcommand{\nnbb}[2]{} % Disable editorial comments
	\sloppy
\fi

%=================================================================
\chapter{La réflexivité}\chalabel{reflection}

%\alex{I addressed lukas comments using editorial macros. Please, if you read this, remove this comment and remove the editorial macros, else their purpose is divinisait}

\indexmain{réflexivité}
\st est un langage de programmation réflexif. En bref, cela signifie que les programmes ont la possibilité d'agir à la fois sur leur propre exécution et leur propre structure.
% \lr{not only on execution, also on the static model}
Plus techniquement, cela signifie que les \emphind{méta-objets} du système en cours d'exécution peuvent être \emph{réifiés} sous forme d'objets ordinaires qui peuvent alors recevoir des requêtes et être inspectés.
Les méta-objets dans \st sont les classes, méta-classes, dictionnaires de méthodes, méthodes compilées, pile d'exécution, \etc\ldots
Cette forme de réflexivité est également appelée \emphind{introspection}: elle est disponible dans de nombreux langages de programmation.

\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{reflect}
	\caption{Réification et réflexivité.\figlabel{reflect}} % \lr{not referenced, not sure if I understand it}
\end{figure}
Inversement, il est possible en \st de modifier les méta-objets réifiés et que leurs modifications soient prises en compte lors de l'exécution du système (voir \figref{reflect}).
Nous parlons d'\emph{intercession}: elle est principalement utilisée dans les langages de programmation dynamique et de manière plus limitée dans les langages statiques.

Un programme qui manipule d'autres programmes (dont lui-même) est un \emphind{méta-programme}.
Pour qu'un langage de programmation soit réflexif, il faut qu'il supporte à la fois l'\ind{introspection} et l'\ind{intercession}. L'introspection est la capacité \emph{d'examiner} les structures de données qui définissent le programme comme les objets, classes, méthodes ou pile d'exécution. L'intercession est la capacité de modifier ces structures, en d'autres termes de changer la sémantique du langage et le comportement d'un programme depuis le programme lui-même.
La \emph{réflexivité structurelle} s'intéresse à l'exploration et à la modification des structures lors de l'exécution du système, alors que la \emph{réflexivité de comportement} concerne l'interprétation de ces structures.

Dans ce chapitre, nous allons principalement nous intéresser à la \ind{réflexivité structurelle}.
Nous illustrerons avec plusieurs exemples pratiques comment \st supporte l'introspection et la méta-programmation.

%======================================
\section{Introspection}

En utilisant un inspecteur, il est possible d'examiner un objet, de changer les valeurs de ses variables d'instances et même de lui envoyer un message.

\dothis{Évaluez le code qui suit dans un Workspace:}
\begin{code}{| w |}
w := Workspace new.
w openLabel: 'My Workspace'.
w inspect
\end{code}

Ceci va ouvrir un deuxième Workspace et un inspecteur.
L'inspecteur montre l'état interne de ce nouveau Workspace: la liste de ses variables d'instances dans la partie gauche (\ct!dependents!, \ct!contents!, \ct!bindings!...) et la valeur de la variable d'instance sélectionnée dans la partie droite.
La variable d'instance \ct!contents! représente ce que le Workspace affiche dans sa zone de texte. Ainsi si vous la sélectionnez, la partie droite montrera une chaîne de caractères vide.

\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{workspaceInspector}
	\caption{Inspecter un \ct!Workspace!.\figlabel{workspaceInspector}}
\end{figure}

\dothis{Maintenant tapez \ct!'hello'! à la place de la chaîne de caractères vide, puis ensuite faites \menu{accept}.}
La valeur de la variable \ct!contents! change, mais la fenêtre du Workspace n'en sera pas notifiée, c'est-à-dire qu'elle ne réaffiche pas son contenu.
Afin d'activer le rafraîchissement de la fenêtre, évaluez \ct!self contentsChanged! dans la partie inférieure de l'inspecteur.

%-----------------------------------------------------------------
\subsection{Accéder aux variables d'instances}

Comment fonctionne l'inspecteur ?
En \st, toutes les variables d'instances sont protégées.
En théorie, il est impossible d'y accéder depuis un autre objet si la classe ne définit pas d'accesseur.
En pratique, l'inspecteur peut accéder aux variables sans avoir besoin d'accesseurs, parce qu'il utilise les capacités réflexives de \st.
En \st, les classes définissent les variables d'instances soit par nom soit au moyen d'indices numériques.
L'inspecteur utilise des méthodes définies dans la classe \ct!Object! afin d'y accéder :  \lct{instVarAt: \emph{index}} et \lct{instVarNamed: \emph{aString}} peuvent être utilisées pour obtenir respectivement la valeur de la variable d'instance à la position \lct{\emph{index}} ou celle de la variable identifiée par \lct{\emph{aString}}; pour associer de nouvelles valeurs à ces variables d'instances, nous utilisons \ct!instVarAt:put:! et \ct!instVarNamed:put:!.
\mthindex{Object}{instVarAt:}
\mthindex{Object}{instVarNamed:}
\mthindex{Object}{instVarAt:put:}
\mthindex{Object}{instVarNamed:put:}

Par exemple, vous pouvez changer la valeur de la variable d'instance \ct!contents! de \ct!w! précédemment définie en évaluant :
\begin{code}{}
w instVarNamed: 'contents' put: 'howdy!'; contentsChanged
\end{code}

\important{\emph{Mise en garde:} Bien que ces méthodes soient utiles pour construire les outils de l'environnement de développement, les utiliser dans le cadre d'une application conventionnelle est une mauvaise idée: ces méthodes réflexives rompent l'encapsulation des objets et peuvent rendre votre code plus difficile à comprendre et à maintenir.}
% \lr{Why? The access does not show up when looking for all readers/writers in the code browser.}

\ct!instVarAt:! et \ct!instVarAt:put:! sont des \subind{méthode}{primitives}, \ie qu'elles sont implémentées comme des opérations primitives de la machine virtuelle \pharo.
Si vous consultez le code de ces méthodes, vous constaterez l'emploi de cette
syntaxe spéciale
\ct!<primitive: N>! où \ct!N! est un entier:
%ajout martial
il s'agit d'exemple de \ind{pragma}. Nous en parlerons plus loin dans ce chapitre. % c'est plus clair comme ça
% \lr{actually this is the syntax of \pragmas (method annotations), \ct!primitive:! is just a special kind of \pragma}

\needlines{5}
\begin{code}{}
Object>>>instVarAt: index 
	"Primitive. Answer a fixed variable in an object. (...)"
	!\textbf{<primitive: 73>}!
	"Access beyond fixed variables."
	^ self basicAt: index - self class instSize		
\end{code}

Généralement le code après l'invocation de la primitive n'est pas exécuté. Il est exécuté seulement si la primitive échoue. Dans le cas qui nous intéresse, si nous essayons d'accéder à une variable qui n'existe pas, alors le code qui suit la primitive sera essayé. Ceci permet aussi d'utiliser le débogueur sur des méthodes primitives.
Bien qu'il soit possible de modifier le code des méthodes primitives, ceci est risqué pour la stabilité de votre image \pharo.

\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{allInstanceVariables}
	\caption{Afficher toutes les variables d'instance d'un \ct!Workspace! avec un \menu{print it}.\figlabel{allInstanceVariables}}
\end{figure}

\Figref{allInstanceVariables} montre comment afficher les valeurs des variables d'instances d'une instance (\ct!w!)  de la classe \ct!Workspace!.
La méthode \ct!allInstVarNames! retourne l'ensemble des noms de variables d'instances d'une classe donnée.

De la même façon, il est possible de collecter les instances qui ont certaines propriétés.
Par exemple, pour avoir toutes les instances de la classe \ct!SketchMorph! dont la variable d'instance \ct!owner! est initialisée avec un morph de type World (\ie les morphs dont l'affichage est persistant), évaluez cette expression:
\begin{code}{}
SketchMorph allInstances select: [:c | (c instVarNamed: 'owner') isWorldMorph]
\end{code}

%-----------------------------------------------------------------
\subsection{Parcourir les variables d'instances}

\mthindex{Object}{instanceVariableValues}
Considérons le message \ct!instanceVariableValues!, qui retourne une collection de toutes les valeurs des variables d'instances définies dans la classe, hormis les variables d'instances héritées.
Par exemple :
\begin{code}{@TEST}
(1@2) instanceVariableValues --> an OrderedCollection(1 2)
\end{code}

\noindent{} La méthode est implémentée dans \ct{Object} de la manière suivante :
\needlines{9}
\begin{code}{}
Object>>>instanceVariableValues
	"Answer a collection whose elements are the values of those instance variables of the receiver which were added by the receiver's class."	
	| c |
	c := OrderedCollection new.
	self class superclass instSize + 1
		to: self class instSize
		do: [ :i | c add: (self instVarAt: i)].
	^ c
\end{code}

Cette méthode parcourt par indice les variables d'instances que la classe définit, à partir du dernier \emph{index} utilisé par les superclasses\,---\,la méthode \ct!instSize! retourne le nombre des variables d'instances nommées que la classe définit.

%-----------------------------------------------------------------
\subsection{Faire des requêtes sur les classes et interfaces}

Les outils de développement \pharo tels que le navigateur de code, le débogueur ou l'inspecteur utilisent tous les mécanismes réflexifs que nous avons vu jusqu'à présent.

Voici quelques messages supplémentaires qui peuvent être utiles afin de construire des outils de développement :

\lct{isKindOf: \emph{aClass}} retourne vrai si le receveur est une instance de \lct{\emph{aClass}} ou d'une de ses superclasses.
Par exemple :
\begin{code}{@TEST}
1.5 class                     --> Float
1.5 isKindOf: Number --> true
1.5 isKindOf: Integer   --> false
\end{code}
\mthindex{Object}{class}
\mthindex{Object}{isKindOf:}

\lct{respondsTo: \emph{aSymbol}} retourne vrai si le receveur a une méthode dont le sélecteur est \lct{\emph{aSymbol}}.
Par exemple :
\needlines{3}
\begin{code}{@TEST}
1.5 respondsTo: #floor      --> true    "car Number !implémente! floor"
1.5 floor                            --> 1
Exception respondsTo: #, --> true    "car les classes d'exception peuvent !être! !regroupées!"
\end{code}
\mthindex{Object}{respondsTo:}

\important{\emph{Mise en garde:} Bien que tous ces outils soient particulièrement utiles pour construire des outils de développements, ils ne sont pas appropriés pour une application classique.
Demander à un objet sa classe ou bien l'interroger pour connaître les messages qu'il comprend, sont un signe indiquant une mauvaise conception objet, puisque généralement cela signifie une violation du principe d'encapsulation.
Les outils de développements ne sont pas considérés comme des applications comme les autres, puisque leur domaine d'applications porte sur le logiciel. Ces outils doivent nécessairement accéder aux détails internes du code.}

%There also exist mechanisms for introspecting on various parts of the run-time system, such as  the process scheduler, the memory manager and so on. For now we will focus on navigating through objects, classes and methods, and we will look more closely at rest of the runtime system in an other chapter.
%\on{let's not mention this if we don't actually write such a chapter!}

%-----------------------------------------------------------------
\subsection{Métriques de code}

Voyons maintenant comment nous pouvons utiliser les mécanismes d'introspection de \st pour rapidement pouvoir construire des métriques de code. Les \ind{métriques} de code mesurent certains aspects comme la profondeur de l'arbre d'héritage, le nombre de sous-classes directes ou indirectes, le nombre de méthodes ou de variables d'instances de chaque classe ou enfin le nombre local de méthodes ou de variables d'instances.
Voici quelques résultats de métriques pour la classe \ct!Morph!, qui est la superclasse de tous les objets graphiques de \pharo, révélant qu'il s'agit d'une classe d'une taille conséquente et qu'elle est la racine d'une hiérarchie importante. Peut-être qu'elle nécessiterait d'être refactorisée !

\mthindex{Behavior}{allSuperclasses}
\mthindex{Behavior}{allSelectors}
\mthindex{Behavior}{allInstVarNames}
\mthindex{Behavior}{selectors}
\mthindex{Behavior}{instVarNames}
\mthindex{Behavior}{subclasses}
\mthindex{Behavior}{allSubclasses}
\mthindex{ClassDescription}{linesOfCode}
\begin{code}{}
Morph allSuperclasses size.  -->       2 "profondeur d'!héritage!"
Morph allSelectors size.        --> 1378 "nombre de !méthodes!"
Morph allInstVarNames size. -->      6 "nombre de variables d'instances"
Morph selectors size.             -->  998 "nombre de nouvelles !méthodes!"
Morph instVarNames size.     -->      6 "nombre de nouvelles variables"
Morph subclasses size.          -->    45 "sous-classes directes"
Morph allSubclasses size.      -->  326 "total de sous-classes"
Morph linesOfCode.               --> 5968 "nombre total de lignes de codeBANG"
\end{code}

Une des métriques les plus intéressantes dans le domaine de la programmation par objet est le nombre de méthodes qui étendent les méthodes héritées de la superclasse. Ceci nous informe de la relation entre une classe et ses superclasses.
Dans les prochaines sections, nous verrons comment exploiter notre connaissance des mécanismes d'exécution pour répondre à de telles questions.

%======================================
\section{Parcourir le code}

En \st, \mantra. Les classes sont en particulier des objets qui fournissent des mécanismes utiles afin de parcourir leurs instances.
La plupart des messages que nous allons voir maintenant sont implémentés dans la classe \ct{Behavior}. Ils sont donc compris de toutes les classes.

Comme nous avons vu précédemment, nous pouvons obtenir une instance particulière d'une classe donnée en lui envoyant le message \ct!someInstance!.
\mthindex{Behavior}{someInstance}
\begin{code}{@TEST} % Possibly fragile!
Point someInstance --> 0@0
\end{code}

Vous pouvons également rassembler toutes les instances avec \ct!#allInstances! ou déterminer le nombre d'instances en mémoire avec \ct!#instanceCount!.

%\alex{In a Pharo0.1-10342dev09.96.3, I have "ByteString instanceCount --> 63607"}
\mthindex{Behavior}{allInstances}
\mthindex{Behavior}{instanceCount}
\mthindex{Behavior}{allSubInstances}
\begin{code}{} % Cannot test this
ByteString allInstances        --> #('collection' 'position'  ...)
ByteString instanceCount    --> 104565
String allSubInstances size -->  101675
\end{code}

Ces caractéristiques peuvent être très utiles lors du débogage d'une application, car il est possible de demander à une classe d'énumérer les méthodes possédant des propriétés spécifiques.
\begin{itemize}
\item \mthind{Behavior}{whichSelectorsAccess:} retourne la liste de tous les sélecteurs de méthodes qui lisent ou écrivent dans une variable dont le nom est passé en argument;
\item \mthind{Behavior}{whichSelectorsStoreInto:} retourne les sélecteurs des méthodes qui modifient la valeur d'une variable d'instance;
\item \mthind{Behavior}{whichSelectorsReferTo:} retourne les sélecteurs des méthodes qui envoient un certain message;
\item \mthind{Behavior}{crossReference} associe chaque message avec l'ensemble des méthodes qui l'envoie.
\end{itemize}

\begin{code}{} % TOO FRAGILE TO TEST
Point whichSelectorsAccess: 'x'    --> an IdentitySet(#'\\' #= #scaleBy: ...)
Point whichSelectorsStoreInto: 'x' --> an IdentitySet(#setX:setY: ...)
Point whichSelectorsReferTo: #+  --> an IdentitySet(#rotateBy:about: ...)
Point crossReference --> an Array(
		an Array('*' an IdentitySet(#rotateBy:about: ...))
		an Array('+' an IdentitySet(#rotateBy:about: ...))
		...)
\end{code}

Les messages qui suivent prennent en compte l'héritage:
\begin{itemize}
\item \mthind{Behavior}{whichClassIncludesSelector:} retourne la super-classe qui implémente le message concerné;
\item \mthind{Behavior}{unreferencedInstanceVariables} retourne la liste des variables d'instances qui ne sont utilisées ni dans la classe du receveur ni dans aucune de ses sous-classes.
\end{itemize}

\begin{code}{@TEST}
Rectangle whichClassIncludesSelector: #inspect --> Object
Rectangle unreferencedInstanceVariables            --> #()
\end{code}

%% \clsind{SystemNavigation} is a facade that supports various useful methods for querying and browsing the source code of the system.
%% \ct{SystemNavigation} \mthind{SystemNavigation class}{default} returns an instance you can use to navigate the system.

\clsind{SystemNavigation} est une façade qui comporte plusieurs méthodes utiles pour examiner et parcourir le code source du système.
\ct{SystemNavigation} \mthind{SystemNavigation class}{default} retourne une instance que vous pouvez utiliser pour naviguer dans le système. À titre d'exemple, évaluez l'expression suivante:

\mthindex{SystemNavigation}{allClassesImplementing:}
\begin{code}{@TEST}
SystemNavigation default allClassesImplementing: #yourself --> {Object}
\end{code}

Les messages suivants devraient être également compréhensibles par eux-mêmes :

\mthindex{SystemNavigation}{allSentMessages}
\mthindex{SystemNavigation}{allUnsentMessages}
\mthindex{SystemNavigation}{allUnimplementedCalls}
\begin{code}{}
SystemNavigation default allSentMessages size          --> 24930
SystemNavigation default allUnsentMessages size      --> 6431
SystemNavigation default allUnimplementedCalls size --> 270
\end{code}

Notons que les messages implémentés mais non envoyés ne sont pas nécessairement inutiles: ils peuvent être envoyés implicitement (\eg en utilisant \ct{perform:}).
Les messages envoyés mais non implémentés sont plus problématiques puisque les méthodes envoyant ces messages vont échouer à l'exécution. Ceci peut être le signe d'une implémentation non finie, d'une API obsolète ou bien de bibliothèques manquantes.

\mthindex{SystemNavigation}{allCallsOn:}
\ct!SystemNavigation default allCallsOn: #Point! retourne tous les messages envoyés explicitement à \ct!Point! comme receveur du message.

Toutes ces fonctionnalités sont intégrées dans l'environnement de programmation \pharo, en particulier dans les navigateurs de code.
% martial: j'ai mis implementors et senders puisqu'ils ont été definis ainsi précédemment
Comme vous avez déjà pu vous en apercevoir, il existe des raccourcis-clavier pour parcourir tous les \immplementors
%i\underline{m}plémenteurs
(\short{m}) et
\sennders
% e\underline{n}voyeurs
(\short{n}) d'un message particulier.
Ce qui est moins connu est l'existence d'un certain nombre de méthodes pour faire des requêtes similaires dans le protocole \prot{browsing} dans la classe \ct{SystemNavigation}.
Par exemple, vous pouvez parcourir de manière programmatique tous les \implementors du message \ct{ifTrue:} 
% ajout martial
(\ie toutes ses implémentations)
en évaluant:
\mthindex{SystemNavigation}{browseAllImplementorsOf:}
\begin{code}{}
SystemNavigation default browseAllImplementorsOf: #ifTrue:
\end{code}

\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{implementors}
	\caption{Parcourir toutes les implémentations de \ct!\#ifTrue:!.\figlabel{implementors}}
\end{figure}

Des méthodes qui sont particulièrement utiles sont les méthodes \ct{browserAllSelect:} et \lct{browserMethodsWithSourceString:}. 
Voici deux différentes façons de parcourir les méthodes d'un système qui utilisent des appels à \super (la première façon est plutôt brutale; la deuxième est meilleure et élimine certains faux positifs):
\mthindex{SystemNavigation}{browseMethodsWithSourceString:}
\mthindex{SystemNavigation}{browseAllSelect:}
\begin{code}{}
SystemNavigation default browseMethodsWithSourceString: 'super'.
SystemNavigation default browseAllSelect: [:method | method sendsToSuper ].
\end{code}

%======================================
\section{Classes, dictionnaires de méthodes et méthodes}

Comme les classes sont des objets, il est possible de les inspecter ou de les explorer de la même manière que les objets.

\mthindex{Object}{explore}
\dothis{Évaluez \ct{Point explore}.}

Dans \figref{CompiledMethod}, l'\ind{explorateur} montre la structure de la classe \clsind{Point}.
Vous pouvez remarquer que la classe stocke ses méthodes dans un dictionnaire, indexées par leur sélecteur.
Le sélecteur \ct{#*} pointe vers le \emphind{bytecode} décompilé de \ct!Point>>>*!.

\begin{figure}[ht]\centering    % figure déplacée pour plus de
                                % lisibilité 
	\includegraphics[width=.5\linewidth]{CompiledMethod}
	\caption{L'explorateur de la classe \ct!Point! et le \emph{bytecode} de sa méthode \ct!\#*!.\figlabel{CompiledMethod}}
\end{figure}

Examinons la relation entre classes et méthodes.
Dans \figref{MethodsAsObjects}, nous voyons que classes et méta-classes ont en commun la super-classe \ct{Behavior}. C'est dans cette super-classe que la méthode \mthind{Behavior}{new} est définie, parmi d'autres méthodes-clés pour ces classes. 
Chaque classe possède un dictionnaire de méthode qui associe chaque sélecteur de méthodes à sa \ind{méthode compilée}.
Chaque méthode compilée connaît la classe dans laquelle elle est installée.
Dans \figref{CompiledMethod}, nous pouvons même remarquer que l'information est conservée au moyen d'une association dans \ct{literal5}.

\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{MethodsAsObjects}
	\caption{Classes, dictionnaires de méthodes et méthodes compilées\figlabel{MethodsAsObjects}}
\end{figure}

Nous pouvons exploiter les relations établies entre classes et méthodes pour effectuer des requêtes sur le système.
Par exemple, pour connaitre quelles méthodes viennent d'être introduites dans une classe donnée\,---\,autrement dit celles qui ne surchargent pas les méthodes de la super-classe\,---\,nous pouvons naviguer depuis la classe vers le dictionnaire de méthodes de cette manière :

\needlines{4}
\mthindex{Behavior}{methodDict}
\begin{code}{}
[:aClass| aClass methodDict keys select: [:aMethod |
  (aClass superclass canUnderstand: aMethod) not ]] value: SmallInteger
  --> an IdentitySet(#threeDigitName #printStringBase:nDigits: ...)
\end{code}

Une méthode compilée ne stocke pas simplement le \emph{bytecode} de la méthode.
C'est aussi un objet qui fournit de nombreuses méthodes utiles pour interroger le système. 
Une de ces méthodes se nomme \ct{isAbstract} (qui nous renseigne si la méthode envoie \ct{subclassResponsibility}).
Nous pouvons l'utiliser pour identifier toutes les méthodes abstraites d'une classe abstraite.

\needlines{4}
\begin{code}{}
[:aClass| aClass methodDict keys select: [:aMethod |
  (aClass>>aMethod) isAbstract ]] value: Number
  --> an IdentitySet(#storeOn:base: #printOn:base: #+ #- #* #/ ...)
\end{code}

Remarquez que ce code envoie le message \ct{>>} à la classe pour obtenir la méthode compilée d'un sélecteur donné.

% As a slightly more complex example, we can browse 

Pour parcourir les méthodes d'une classe-mère au sein d'une hiérarchie donnée, par exemple de la hiérarchie de Collections, nous pouvons poser une requête plus sophistiquée : 
\begin{code}{}
class := Collection.
SystemNavigation default
  browseMessageList: (class withAllSubclasses gather: [:each |
    each methodDict associations
      select: [:assoc | assoc value sendsToSuper]
      thenCollect: [:assoc | MethodReference class: each selector: assoc key]])
  name: 'Supersends of ' , class name , ' and its subclasses'
\end{code}
Remarquez comment nous naviguons en partant des classes pour aller vers les dictionnaires de méthodes puis vers les méthodes compilées pour identifier les méthodes recherchées. 
Une \ct{MethodReference} est un \emph{proxy} léger pour une méthode compilée qui est utilisée par de nombreux outils.
Il existe une méthode adaptée \clsmthind{CompiledMethod}{methodReference} qui retourne la référence de la méthode pour une méthode compilée.

\begin{code}{@TEST}
(Object>>#=) methodReference methodSymbol --> #=
\end{code}

%======================================
\section{Environnements de navigation du code}

Même si \clsind{SystemNavigation} offre quelques façons utiles d'interroger le système par programmes et de parcourir le code système, il existe une meilleure manière. Le \ind{Refactoring Browser}, qui est intégré à \pharo, permet de poser des questions complexes à la fois de manière interactive et par programme.

Supposons que nous voulions découvrir quelle méthode dans la hiérarchie \lct{Collection} envoie un message à \super qui soit différent depuis le sélecteur de méthodes. Ceci est généralement considéré comme un \ind{mauvais code}~\footnote{NdT: \arelire{nous pouvons entendre dans la culture informaticienne la notion de \emph{code smell} pour se référer au fait que le mauvais code \emph{ne sent pas bon}.}} puisqu'un tel envoi à \super devrait normalement être remplacé par un envoi à \self ~\footnote{Pensez à cela --- vous ne devriez avoir besoin de \super que pour étendre une méthode que vous êtes en train de surcharger; toutes les autres méthodes héritées peuvent être accédées par un \self!}. % CHANGE plus elegant en footnote
\seeindex{code smell}{mauvais code}

Le Refactoring Browser nous permet de manière élégante de restreindre nos interrogations uniquement aux classes et méthodes qui nous intéressent. 

\dothis{Ouvrez un Browser sur la classe \ct{Collection}.
\Actclick sur le nom de la classe et sélectionner \mbox{\menu{refactoring scope>subclasses with}.}
Ceci ouvrira un nouveau BrowserEnvironnement sur la hiérarchie \mbox{\ct{Collection}.}
Dans ce champ restreint, sélectionner \menu{refactoring scope>super-sends} pour ouvrir un nouvel environnement avec toutes les méthodes qui font des envois à \super dans la hiérarchie \ct{Collection}. Maintenant \click sur n'importe quelle méthode et sélectionner \menu{refactor>code critics}.
Naviguer dans \menu{Lint checks>Possible bugs>Sends different super message}~\footnote{NdT:
% ajout martial
\arelire{``Lint checks'' peut se traduire par ``vérifications par analyse lexicale''.}%
} et \actclick pour sélectionner \menu{browse}.}

Dans \figref{sendDifferentSuper}, nous pouvons voir que 19 méthodes de la sorte ont été trouvées dans la hiérarchie \ct{Collection}, incluant \ct{Collection>>>printNameOn:}, laquelle envoie \ct{super printOn:}.
\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{sendDifferentSuper}
	\caption{Trouver les méthodes qui envoient un message différent de super.
 	\figlabel{sendDifferentSuper}}
\end{figure}

Un environnement de navigation du code peut aussi être créé par programme.
Ici, par exemple, nous créons un nouveau \clsind{BrowserEnvironment} pour \clsind{Collection} et ses sous-classes, nous sélectionnons les méthodes qui envoient à \super et nous ouvrons l'environnement résultant.
\needlines{4}
\begin{code}{}
((BrowserEnvironment new forClasses: (Collection withAllSubclasses))
	selectMethods: [:method | method sendsToSuper])
	label: 'Collection methods sending super';
	open.
\end{code}{}

Notez à quel point ce moyen est considérablement plus compact que les exemples précédents utilisant \ct{SystemNavigation}.

Finalement, nous pouvons trouver uniquement les méthodes qui envoient un message différent de \super comme ceci :
\needlines{6}
\begin{code}{}
((BrowserEnvironment new forClasses: (Collection withAllSubclasses))
	selectMethods: [:method | 
		method sendsToSuper
		and: [(method parseTree superMessages includes: method selector) not]])
	label: 'Collection methods sending different super';
	open
\end{code}
Dans cet exemple, nous demandons à chaque méthode compilée son arbre d'analyse (Refactoring Browser), dans le but de trouver quels messages à destination de \super diffèrent des sélecteurs de méthodes.
Regardez le protocole \prot{querying} de la classe \ct{RBProgramNode} pour voir un certain nombre d'exemples de ce que nous pouvons demander aux arbres d'analyse. 

% Here we ask each compiled method for its (Refactoring Browser) parse tree, in order to find out whether the super messages differ from the method's selector.
% Have a look at the \prot{querying} protocol of the class \ct{RBProgramNode} to see some the things we can ask of parse trees.

%======================================
\section{Accéder au contexte d'exécution}

Nous avons vu comment les capacités réflexives de \st, nous permettent d'interroger et d'explorer les objets, les classes et les méthodes. Qu'en est-il de l'environnement d'exécution?

%-----------------------------------------------------------------
\subsection{Contextes des méthodes}

En fait, le contexte d'exécution d'une méthode se trouve dans la machine virtuelle et pas dans l'image. Mais visiblement, le \ind{débogueur} a accès à cette information et nous pouvons explorer le contexte d'exécution, comme n'importe quel autre objet? Comment cela est possible?

En fait, il n'y a rien de magique avec le débogueur.
Le secret réside dans la pseudo-variable \pvind{thisContext}, que nous avons brièvement rencontré précédemment.
Lorsque l'on accède à \ct{thisContext} dans une méthode qui s'exécute, tout le contexte d'exécution de cette méthode est réifié et rendu disponible dans l'image comme une liste chainée d'objets \clsind{MethodContext}.
Nous pouvons facilement expérimenter ce mécanisme par nous-même.

\dothis{Changez la définition de \ct{Integer>>>factorial} en insérant l'expression soulignée ci-dessous:}
\mthindex{Object}{halt}
\begin{code}{}
Integer>>>factorial
	"Answer the factorial of the receiver."
	self = 0 ifTrue: [!\underline{thisContext explore. self halt.}! ^ 1].
	self > 0 ifTrue: [^ self * (self - 1) factorial].
	self error: 'Not valid for negative integers'
\end{code}

\dothis{Maintenant évaluez \ct{3 factorial} dans un espace de travail. Vous devez normalement obtenir une fenêtre de débogage et un explorateur comme nous pouvons le voir dans \figref{exploringThisContext}.}

\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{exploringThisContext}
	\caption{Explorer \ct{thisContext}.\figlabel{exploringThisContext}}
\end{figure}

Bienvenue dans le débogueur du pauvre! 
Si maintenant nous parcourons la classe de l'objet exploré (\ie en évaluant \ct{self browse} dans le panneau du bas de l'explorateur), vous aller découvrir que c'est une instance de la classe \lct{MethodContext}, comme tous les \senders en série.
% All of these objects have been created dynamically in the image by the \st virtual machine at the point where \ct{thisContext} was referred to in the \ct{factorial} method. \lr{Not actually. In all the currently available VMs the context objects are created with every method activation, no matter if they are accessed using \ct{thisContext} or not.}

\ct{thisContext} n'est pas destiné à être utilisé dans la programmation de tous les jours, mais il est essentiel pour réaliser des outils comme des débogueurs et lorsque l'on a besoin d'accéder à des informations concernant la pile d'appels de méthodes.
Nous pouvons évaluer l'expression suivante pour découvrir quelles méthodes utilisent \ct{thisContext}:

\begin{code}{}
SystemNavigation default browseMethodsWithSourceString: 'thisContext'
\end{code}

Comme nous pouvions nous en douter, une des applications les plus répandues est de découvrir le \sender d'un message.
Voici une application courante :
\begin{code}{}
Object>>>subclassResponsibility
	"This message sets up a framework for the behavior of the class' subclasses.
	Announce that the subclass should have implemented this message."

	self error: 'My subclass should have overridden ', thisContext sender selector printString
\end{code}

% ajout vf
Le commentaire de la méthode nous indique que ``ce message change le comportement des sous-classes de la classe (qui reçoit ce message) et informe la sous-classe de la nécessité d'implémenter la méthode''.% AJOUT
% fin ajout vf
Par convention, les méthodes \st qui envoient le message \ct{self subclassResponsibility} sont considérées comme abstraites. Mais
comment \mbox{\clsmthind{Object}{subclassResponsibility}} indique un message d'erreur utile indiquant quelle méthode abstraite a été appelée? Simplement, en interrogant la pseudo-variable \ct{thisContext} du \sender du message.

%\lr{I think co-routines and continuations should at least mentioned here. Another very practical application that is simple and could be shown here is the ``escaper''. Store the current context into a temp or inst-var \ct{target := thisContext} and jump back to that stack frame at a later point in time using \ct{target return: 123}.}
%\sd{lukas maybe we should have another chapter showing such kind of beasts. I would love to read it. Showing how to use block to build exception and such a kind of point. I think that this chapter should be an introduction may be we should have a Reflection applied chapter}
%\lr{I would love to help writing such a chapter}
%-----------------------------------------------------------------
\subsection{Points d'arrêts intelligents}

\mthindex{Object}{halt}
En \st la façon de mettre des points d'arrêts dans un programme consiste à évaluer \ct{self halt} aux endroits correspondants. Ceci va provoquer la réification de \ct{thisContext} et une fenêtre de \ind{débogage} va s'ouvrir sur ce point d'arrêt.
Malheureusement ceci peut poser des problèmes pour des méthodes qui sont utilisées partout dans le système.

Supposons par exemple, que nous voulions explorer l'exécution de \ct{OrderedCollection>>>add:}.
Mettre un point d'arrêt sur cette méthode est problématique.

\dothis{%
\arevoir{Sauvegardez votre session en l'état via \menu{World\go{}Save}. Ajoutez le point d'arrêt suivant:} % prendre une nouvelle image est FAUX désormais (vf OneClick / martial)
} % RELIRE car ajout important

\needlines{3}
\begin{code}{}
OrderedCollection>>>add: newObject
	!\underline{self halt.}!
	^ self addLast: newObject
\end{code}

Nous remarquons que notre image se fige instantanément! Nous n'avons même pas eu de fenêtre de débogage.
Le problème devient évident lorsque nous comprenons que (i) \ct{OrderedCollection>>>add:} est utilisé en de nombreux endroits du système, de telle sorte que le point d'arrêt est déclenché peut après que nous ayons accepté cette modification et (ii) que le \emph{débogueur lui-même} envoie le message \ct{add:} à une instance de \ct{OrderedCollection}, l'empéchant d'ouvrir la fenêtre de débogage!
Ce dont nous avons besoin est de pouvoir faire \emph{un point d'arrêt conditionnel} seulement lorsque nous sommes dans le contexte qui nous intéresse.
C'est exactement ce qu'offre \clsmthind{Object}{haltIf:}.

Supposons que nous voulions arrêter le programme seulement si le message \ct{add} est envoyé dans le contexte de \ct{OrderedCollectionTest>>>testAdd}.

\dothis{\arevoir{Après avoir quitté l'image gelé (en détruisant le processus de la machine virtuelle), relancez \pharo{} et mettez le point d'arrêt ci-dessous:}} % RELIRE car ajout important

\begin{code}{}
OrderedCollection>>>add: newObject
	!\underline{self haltIf: \#testAdd.}!
	^ self addLast: newObject
\end{code}

Cette fois ci, l'image ne se fige pas. Essayez d'exécuter \mbox{\ct{OrderedCollectionTest}{},} que vous pouvez trouver dans la catégorie \mbox{\scat{CollectionsTests-Sequenceable}.}

\noindent{} Comment cela fonctionne-t-il? Regardons le code de \mbox{\clsmthind{Object}{haltIf:}:}
\begin{code}{}
Object>>>haltIf: condition
	| cntxt |
	condition isSymbol ifTrue: [
		"only halt if a method with selector symbol is in callchain"
		cntxt := thisContext.
		[cntxt sender isNil] whileFalse: [
			cntxt := cntxt sender. 
			(cntxt selector = condition) ifTrue: [Halt signal]. ].
		^ self.
	].
	...
\end{code}

À partir de \ct!thisContext!, \ct!haltIf:! parcourt la pile d'exécution en vérifiant que le nom de la méthode appelante est le même que celle passée en paramètre. Si c'est le cas, la méthode déclenche une exception qui, par défaut, déclenche le débogueur.

Il est également possible de fournir une valeur booléenne ou un bloc qui retourne un booléen comme argument de \ct{haltIf:}, mais dans ce cas, cela devient plus simple et nous n'utilisons plus \ct{thisContext}.

%======================================
\section{Intercepter les messages non compris}
\seclabel{msgnotunderstood}
% traduction de martial à partir de ce point

Pour l'instant, nous avons utilisé les capacités réflexives de \st principalement pour interroger et explorer les objets, les classes, les méthodes et la pile d'exécution du système. Nous allons maintenant voir comment utiliser notre connaissance de \st pour intercepter des messages et modifier le comportement du système à l'exécution.

Lorsque un objet reçoit un message, il cherche d'abord dans son dictionnaire de méthodes la méthode correspondante pour répondre au message.
Si aucune méthode correspondante n'existe, il va continuer son exploration en remontant dans la hiérarchie de classe, jusqu'à atteindre la classe \ct{Object}.
Si toujours aucune méthode n'est trouvée pour ce message, l'objet \emph{s'enverra à lui-même} %send itself
le message \ct{doesNotUnderstand:} avec le selecteur du message comme argument.
La recherche reprend alors encore jusqu'à ce que la méthode
\clsmthind{Object}{doesNotUnderstand:} soit trouvée; puis le débogueur se lance.

Mais que se passerait-il si la méthode \ct{doesNotUnderstand:} est surchargée 
par une des sous-classes de \ct{Object} situées dans le chemin de recherche? %lookup path?
Il s'avère qu'il s'agit d'une méthode pratique pour construire certains types de comportements très dynamiques. Un objet qui ne comprend pas un message peut, par la surcharge de \ct{doesNotUnderstand:}, se retrouver dans une stratégie alternative pour répondre à ce message.

L'implémentation de \ind{proxies légers}~\footnote{NdT: un \emph{proxy}, des \emph{proxies}.} pour objets et la compilation dynamique ou le chargement de code manquant sont deux applications très courantes de cette technique.
% Two very common applications of this technique are (1) to implement \ind{lightweight proxies} for objects, and (2) to dynamically compile or load missing code.

%-----------------------------------------------------------------
\subsection{\emph{Proxy} légers}

Dans ce cas, nous introduisons un ``\ind{objet minimal}''
%``\ind{minimal object}''
agissant comme un \emph{proxy} pour un objet existant.
Puisque le \emph{proxy} n'implémentera virtuellement aucune méthode de lui-même, tout message qui lui sera envoyé sera capturé par la méthode
 \ct{doesNotUnderstand:}. En implémentant cette dernière, le \emph{proxy} peut alors prendre des mesures spéciales avant de déléguer le message à l'objet réel que cache ce \emph{proxy}.
%By implementing this message, the proxy can then take special action before delegating the message to the real subject it is the proxy for.

Jetons un coup d'\oe il sur une solution proposée pour programmer ceci~\footnote{Vous pouvez télécharger le paquetage \pkg{PBE-Reflection} sur \url{http://www.squeaksource.com/PharoByExample/}}.
Nous définissons un \emph{proxy} de journalisation ou \ct{LoggingProxy} ainsi:

\begin{code}{}
ProtoObject subclass: #LoggingProxy
	instanceVariableNames: 'subject invocationCount'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PBE-Reflection'
\end{code}
Notez que nous sous-classons la classe \ct{ProtoObject} plutôt que la classe
\ct{Object} parce que nous ne voulons pas que notre \emph{proxy} hérite de \emph{400 méthodes et plus} de notre classe \ct{Object}.

\begin{code}{}
Object methodDict size --> 408
\end{code}

Notre \emph{proxy} a deux variables d'instance:
\ct{subject} représentant notre objet pour lequel notre \emph{proxy} est destiné et, un compteur de messages interceptés que nous nommons \ct{count}.
Nous initialisons ces deux variables d'instance et nous ajoutons un accesseur pour notre compteur.
Au départ, \ct{subject} pointe sur l'objet \emph{proxy} lui-même.

\begin{code}{}
LoggingProxy>>>initialize
	invocationCount := 0.
	subject := self.
\end{code}

\begin{code}{}
LoggingProxy>>>invocationCount
	^ invocationCount
\end{code}

Nous interceptons tout simplement les messages non-compris et les imprimerons dans la fenêtre Transcript; puis nous mettrons à jour le compteur de messages et transmettrons le message à l'objet réel \ct{subject}.

\begin{code}{}
LoggingProxy>>>doesNotUnderstand: aMessage 
	Transcript show: 'performing ', aMessage printString; cr.
	invocationCount := invocationCount + 1.
	^ aMessage sendTo: subject
\end{code}

C'est ici qu'opère la magie!
Nous créons un nouvel objet \ct{Point} que nous appelerons \ct{point} et un nouvel objet \ct{LoggingProxy}. Nous disons ensuite au \emph{proxy} de devenir (en anglais ``\emph{become}'') ce \ct{point} via le message \mbox{\mthind{ProtoObject}{become:}:}
\seeindex{\ct{become:}}{\ct{ProtoObject>>>become:}}
\begin{code}{}
point := 1@2.
LoggingProxy new !\underline{become:}! point.
\end{code}

Cela a pour effet d'échanger toutes les références dans l'image entre le \ct{point} et le \emph{proxy}. 
Plus important encore, la variable d'instance \ct{subject} du \emph{proxy} se réfère désormais au \ct{point}.
% This has the effect of swapping all references in the image to the point to now refer to the proxy, and vice versa. Most importantly, the proxy's \ct{subject} instance variable will now refer to the point!

\begin{code}{}
point invocationCount --> 0
point + (3@4)             --> 4@6
point invocationCount --> 1
\end{code}

\noindent{} Ceci fonctionne dans la plupart des cas mais il y a des insuffisances:

\begin{code}{}
point class --> LoggingProxy
\end{code}
Curieusement, la méthode \ct{class} n'est pas implémentée dans 
\ct{ProtoObject} mais dans \ct{Object} dont \ct{LoggingProxy} n'hérite pas!
La réponse à cette énigme est que \ct{class} n'est jamais envoyé comme message mais est directement géré par la machine virtuelle~\footnote{\ct{yourself} aussi n'est jamais vraiment envoyé.
Les autres messages qui peuvent être interprétés par la machine virtuelle selon le receveur sont:
\mbox{\ct{+},}
\mbox{\ct{-},}
\mbox{\ct{<},}
\mbox{\ct{>},}
\mbox{\ct{<=},}
\mbox{\ct{>=},}
\mbox{\ct{=},}
\mbox{\ct{\~=},}
\mbox{\ct{*},}
\mbox{\ct{/},}
\mbox{\lct{\textbackslash},}
\mbox{\ct{==},}
\mbox{\ct{@},}
\mbox{\ct{bitShift:},}
\mbox{\ct{//},}
\mbox{\ct{bitAnd:},}
\mbox{\ct{bitOr:},}
\mbox{\ct{at:},}
\mbox{\ct{at:put:},}
\mbox{\ct{size},}
\mbox{\ct{next},}
\mbox{\ct{nextPut:},}
\mbox{\ct{atEnd},}
\mbox{\ct{blockCopy:},}
\mbox{\ct{value},}
\mbox{\ct{value:},}
\mbox{\ct{do:},}
\mbox{\ct{new},}
\mbox{\ct{new:},}
\mbox{\ct{x}} et \mbox{\ct{y}.}
Les sélecteurs ne sont jamais envoyés parce qu'ils sont codés directement par le compilateur et transformés en \emph{bytecodes} % REVOIR voir comment bien formuler ça
%% Selectors that are never sent, because they are inlined by the compiler and transformed to comparison and jump \emph{bytecodes}:
\mbox{\ct{ifTrue:},}
\mbox{\ct{ifFalse:},}
\mbox{\ct{ifTrue:ifFalse:},}
\mbox{\ct{ifFalse:ifTrue:},}
\mbox{\ct{and:},}
\mbox{\ct{or:},}
\mbox{\ct{whileFalse:},}
\mbox{\ct{whileTrue:},}
\mbox{\ct{whileFalse},}
\mbox{\ct{whileTrue,}}
\mbox{\ct{to:do:},}
\mbox{\ct{to:by:do:},}
\mbox{\ct{caseOf:},}
\mbox{\ct{caseOf:otherwise:},}
\mbox{\ct{ifNil:},}
\mbox{\ct{ifNotNil:},}
\mbox{\ct{ifNil:ifNotNil:}} et
\mbox{\ct{ifNotNil:ifNil:}}.

Des tentatives pour envoyer ces messages à des objets non-booléens peuvent être interceptées et leur exécution peuvent être reprise avec un booléen valide en surchargeant la méthode \ct{mustBeBoolean} dans le receveur ou en capturant l'exception \ct{NonBooleanReceiver}.}.
%% Attempts to send these messages to non-boolean objects can be intercepted and execution can be resumed with a valid boolean value by overriding \ct{mustBeBoolean} in the receiver or by catching the \ct{NonBooleanReceiver} exception.
%%  The answer to this riddle is that \ct{class} is never sent as a message but is directly answered by the virtual machine.\footnote{\ct{yourself} is also never truly sent.
%% Other messages that may be directly interpreted by the VM, depending on the receiver, include:
%% \ct{+- < > <= >= = ~= * / \ ==}
%% \ct{@ bitShift: // bitAnd: bitOr:}
%% \ct{at: at:put: size}
%% \ct{next nextPut: atEnd}
%% \ct{blockCopy: value value: do: new new: x y}.
%% Selectors that are never sent, because they are inlined by the compiler and transformed to comparison and jump \emph{bytecodes}:
%% \ct{ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:}
%% \ct{and: or:}
%% \ct{whileFalse: whileTrue: whileFalse whileTrue}
%% \ct{to:do: to:by:do:}
%% \ct{caseOf: caseOf:otherwise:}
%% \ct{ifNil: ifNotNil:  ifNil:ifNotNil: ifNotNil:ifNil:}
%% Attempts to send these messages to non-boolean objects can be intercepted and execution can be resumed with a valid boolean value by overriding \ct{mustBeBoolean} in the receiver or by catching the \ct{NonBooleanReceiver} exception.
%% }% NB: Notes by Lukas Renggli

Même si nous pouvons ignorer de tels envois de messages spéciaux, il existe un autre problème fondamental qui ne peut pas être surmonté par cette approche: les envois à \self ne peuvent pas être interceptés:
\begin{code}{}
point := 1@2.
LoggingProxy new become: point.
point invocationCount --> 0
point rect: (3@4)        --> 1@2 corner: 3@4
point invocationCount --> 1
\end{code}

\noindent{} Notre \emph{proxy} a été privé de deux envois à \self dans la méthode \mbox{\ct{rect:}:} 
%% Our proxy has been cheated out of two \self-sends in the \ct{rect:} method:
\begin{code}{}
Point>>>rect: aPoint 
	^ Rectangle  origin: (self min: aPoint) corner: (self max: aPoint)
\end{code}

Bien que les messages puissent être interceptés par des \emph{proxies} basés sur cette technique, nous devons faire attention aux inhérentes limites de ce procédé. Dans \secref{wrapper}, nous verrons une autre approche plus générique pour l'interception de messages.

%-----------------------------------------------------------------
\subsection{Générer des méthodes manquantes}

Charger ou générer dynamiquement des méthodes manquantes est 
l'autre application la plus courante de l'interception des messages non-compris.
Considérons une grande bibliothèque de classes disposant du grand nombre de méthodes. Plutôt que de charger la bibliothèque dans son entier, nous pouvons charger
des morceaux pour chaque classe de la bibliothèque;
%ajout vf
en informatique des réseaux, nous parlons de \emph{stub}.
Ces \emph{stubs} savent où trouver le code source de toutes leurs méthodes Ils piègent simplement tous les messages non-compris et chargent dynamiquement les méthodes manquantes à la demande.  

% Consider a very large library of classes with many methods.  Instead of loading the entire library, we could load a stub % for each class in the library. The stubs know where to find the source code of all their methods.  The stubs simply trap % all messages not understood, and dynamically load the missing methods on-demand.  At some point, this behaviour can be 
% deactivated, and the loaded code can be saved as the minimal necessary subset for the client application. 

Considerez une très grande bibliothèques de classes comportant beaucoup de méthodes. Au lieu de charger toute la bibliothèque, nous pouvons seulement charger une partie pour chaque classe de la bibliothèque. Ces parties captureront tous les messages non compris, de façon dynamique chargeront à la demande les méthodes manquantes. À un certain moment, ce comportement peut être désactivé et le code chargé peut être enregistré en tant que sous-ensemble minimal utile pour l'application cliente.

%\on{Stef sez: check ObjectOut -- I looked, but this seems to be very old. Depends on SqueakPage.}

Observons une simple variante de cette technique dans le cas où nous avons une classe qui ajoute automatiquement des accesseurs à la demande pour ces variables d'instances:
% \lr{the last statement should return the result of the message, otherwise you cannot proceed with the debugger} \alex{all redefinition of doesNotUnderstand: includes a return statement. However, I do not see your comment lukas, I tried to insert a 'self halt' in the method, I was able to proceed. I added the return in the function} \lr{Of course it depends on the exact circumstances. If you perform a message on self that returns self it does not matter, but in any other case a forgotten return can introduce strange side effects. There was no return in the listing below, but now there is and the problem is solved.}

\begin{code}{}
DynamicAcccessors>>>doesNotUnderstand: aMessage
	| messageName |
	messageName := aMessage selector asString.
	(self class instVarNames includes: messageName)
		ifTrue: [
			self class compile: messageName, String cr, ' ^ ', messageName.
			^ aMessage sendTo: self ].
	^ super doesNotUnderstand: aMessage
\end{code}
Tout message non-compris est capturé ici. Si une variable d'instance avec le même nom que le message existe alors nous pouvons demander à notre classe de compiler un accesseur pour cette variable d'instance et nous pouvons envoyer ce message à nouveau
% ajout vf
à cette même instance de classe.
%Any message not understood is trapped here. If an instance variable with the same name as the message sent exists, then we ask our class to compile an accessor for that instance variables and we re-send the message.

Supposons que la classe \ct{DynamicAcccessors} ait une variable d'instance
(non-initialisée) \ct{x} mais qu'elle ne définisse pas d'accesseur.
Le code suivant va ainsi générer dynamiquement l'accesseur et va récupérer la valeur de cette variable d'instance.
\needlines{2}
\begin{code}{}
myDA := DynamicAccessors new.
myDA x --> nil
\end{code}

Regardons pas à pas ce qu'il se passe la première fois que le message 
\ct{x} est envoyé à notre objet en nous appuyant sur \figref{DynamicAccessors}).

\begin{figure}[ht]\centering
	\includegraphics[width=\linewidth]{DynamicAccessors}
	\caption{Création dynamique d'accesseurs.\figlabel{DynamicAccessors}}
	% \alex{not sure whether the figure is highly necessary. The code is rather simple and the figure complete to follow in my opinion.}}
	% \on{trust me, it is useful to see all the steps.}
\end{figure}

Nous envoyons (1) le message \ct{x} à \ct{myDA}; (2) le message est recherché dans la classe et (3) n'est pas trouvé non plus dans la hiérarchie de la classe. (4) Ceci entraîne en retour l'envoi du message \ct{self doesNotUnderstand: #x} à l'objet (5) déclenchant ainsi une nouvelle recherche. Cette fois, \ct{doesNotUnderstand:} est immédiatemment trouvé dans la classe \ct{DynamicAccessors} (6) qui demande à sa classe de compiler la chaîne de caractères \ct{'x ^ x'}. La méthode \ct{compile} est recherchée (7) jusqu'à être finalement trouvée (8) dans la classe \ct{Behavior} qui (9-10) ajoute la nouvelle méthode compilée au dictionnaire de méthodes de \ct{DynamicAccessors}. Finalement (11-13) le message est renvoyé à nouveau; cette fois, il est trouvé.

La même technique peut être utilisée pour générer des mutateurs pour les variables d'instance ou d'autres types de code réutilisable tels que les méthodes de visites d'une classe de conception de type \emph{Visitor}~\footnote{NdT: un des modèles de conception classiques connues sous l'appelation ``Design Patterns'' et faisant office de référence en matière de programmation objet.}.

Notez que la méthode \clsmthind{Object}{perform:} à l'étape (13) peut être utilisée pour envoyer les messages composés à l'exécution:
\begin{code}{@TEST}
5 perform: #factorial                                             --> 120
6 perform: ('fac', 'torial') asSymbol                       --> 720
4 perform: #max: withArguments: (Array with: 6) --> 6
\end{code}

%======================================
\section{Des objets comme \emph{wrappers} de méthode}
\seclabel{wrapper}

Nous avons déjà vu qu'en \st, les méthodes compilées sont de simples objets et qu'il existe un grand nombre de méthodes qui permettent au programmeur d'interroger le système d'exécution.
Ce qui peut paraître un peu surprenant, c'est qu'\emph{aucun objet} ne peut jouer le rôle de méthode compilée. Tout ce qu'il peut faire, c'est répondre à quelques messages importants tels que \ct{runs:with:in:}.
%% What is perhaps a bit more surprising, is that \emph{any object} can play the role of a compiled method. 
%% All it has to do is respond to the method \ct{run:with:in:} and a few other important messages.

\dothis{Définissez une classe vide \ct{Demo}. Imprimez \ct{Demo new answer42}~\footnote{NdT: référence au roman de science-fiction humoristique, le ``Guide du Voyageur Galactique'' par Douglas Adams dans lequel la réponse (\emph{answer}) à ``la Vie, l'Univers et le Reste'' est $42$.}.
%ajout vf
via \menu{print it}
et constatez comment l'habituelle erreur ``Message Not Understood'' est levée.}
%% {and notice how the usual ``Message Not Understood'' error is raised.}

Maintenant nous pouvons installer un simple \st objet
dans le dictionnaire de méthodes de notre classe \ct{Demo}.

\dothis{Évaluez l'expression \lct{Demo methodDict at: \#answer42 put:}~\mbox{\ct{ObjectsAsMethodsExample new.}}
Essayez maintenant d'imprimer à nouveau le résultat de \ct{Demo new answer42}.
Cette fois-ci nous pouvons obtenir la réponse \ct{42}.}

Si nous nous penchons sur la classe \clsind{ObjectsAsMethodsExample} nous y trouvons les méthodes suivantes:
%\alex{I would prefer having return 42 in the run:with:in: method, and not having answer42 defined in ObjectsAsMethodsExample, this could be confusing I imagine}
%\on{ObjectsAsMethodsExample is part of the standard pharo image -- it is not in PBE-Reflection}
\needlines{5}
\begin{code}{}
answer42
	^ 42

run: oldSelector with: arguments in: aReceiver
	^ self perform: oldSelector withArguments: arguments
\end{code}

Lorsque notre instance de \ct{Demo} reçoit le message \ct{answer42}, la recherche de la méthode se fait normalement mais la machine virtuelle détecte qu'en lieu et place d'une méthode compilée, un objet ordinaire \st tente de jouer ce rôle.
La machine virtuelle enverra alors à cet objet un nouveau message \ct{run:with:in:} avec les sélecteurs de méthode, les arguments et les receveurs originels comme arguments.
Puisque la classe \ct{ObjectsAsMethodsExample} implémente cette méthode, elle intercepte le message et le délègue à elle-même. 
%% this method, it intercepts the message and delegates it to itself.


Nous pouvons maintenant enlever la fausse méthode ainsi:
\begin{code}{}
Demo methodDict removeKey: #answer42 ifAbsent: []
\end{code}

Si nous regardons attentivement la classe \ct{ObjectsAsMethodsExample}, nous verrons que sa super-classe implémente aussi les méthodes \ct{flushcache}, \ct{methodClass:} et \lct{selector:} mais qu'elles sont vides.
Elles peuvent être \arevoir{attachées} % REVOIR: martial: et pas envoyés !?
% rene : ces messages peuvent être envoyés
à des méthodes compilées et doivent donc être implémentées dans un objet prétendant être une méthode compilée (\ct{flushCache} est la plus important méthode à être implémentée; les autres peuvent être requises selon que la méthode est installée par \clsmthind{Behavior}{addSelector:withMethod:} ou directement par \clsmthind{MethodDictionary}{at:put:}).
%% , but they are all empty.  These messages may be sent to a compiled methods, so they need to be implemented by an object pretending to be a compiled method.  (\ct{flushcache} is the most important method to be implemented; others may be required depending on whether the method is installed using \clsmthind{Behavior}{addSelector:withMethod:} or directly using \clsmthind{MethodDictionary}{at:put:}.)

%-------------------------------------------------------------------------
\subsection{Utiliser les \emph{wrappers} de méthode pour effectuer la couverture de tests}
%% {to perform test coverage}

Les \emph{wrappers}~\footnote{NdT: Appelés ainsi parce qu'ils s'enroulent (en anglais, \emph{wrap}) autour des méthodes}. de méthode sont une technique bien connue pour intercepter les messages~\cite{Bran98a}.
Dans l'implémentation originale~\footnote{http://www.squeaksource.com/MethodWrappers.html}, un \emph{wrapper} de méthode est une instance d'une sous-classe de \ct{CompiledMethod}.
Une fois installé, un \emph{wrapper} peut effectuer des actions spéciales avant ou après l'exécution % REVOIR martial > 'invoking' dans VO (À SIGNALER)
de la méthode originale.
%% When installed, a method wrapper can perform special actions before or after invoking the original method.
Lorsqu'il est désinstallé, la méthode originale retrouve sa place dans le dictionnaire de méthodes.
%% When uninstalled, the original method is returned to its rightful position in the method dictionary.

Dans \pharo, les \ind{wrappers de méthodes} peuvent être écrits plus simplement 
en implémentant \ct{run:with:in:} au lieu de sous-classer la classe \ct{CompiledMethod}.
En fait, il existe une implémentation allégée d'objets comme \emph{wrappers}~\footnote{http://www.squeaksource.com/ObjectsAsMethodsWrap.html} mais elle ne fait pas partie intégrante de la version officielle de \pharo à l'heure où ce livre est écrit.

De toutes manières, le Test Runner de \pharo utilise précisement cette technique pour évaluer la \emph{couverture de tests} (en anglais \emph{test coverage}).
Regardons comment tout cela fonctionne.

Le point d'entrée de la couverture de tests est la méthode \clsmthind{TestRunner}{runCoverage}:
\begin{code}{}
TestRunner>>>runCoverage
	| packages methods |
	... "identify methods to check for coverage"
	self collectCoverageFor: methods
\end{code}

La méthode \clsmthind{TestRunner}{collectCoverageFor:} illustre clairement \arelire{l'algorithme de validation}: % ou de vérification ? de la couverture de tests}:
\begin{code}{}
TestRunner>>>collectCoverageFor: methods
	| wrappers suite |
	wrappers := methods collect: [ :each | TestCoverage on: each ].
	suite := self
		reset;
		suiteAll.
	[ wrappers do: [ :each | each install ].
	  [ self runSuite: suite ] ensure: [ wrappers do: [ :each | each uninstall ] ] ] valueUnpreemptively.
	wrappers := wrappers reject: [ :each | each hasRun ].
	wrappers isEmpty 
		ifTrue: 
			[ UIManager default inform: 'Congratulations. Your tests cover all code under analysis.' ]
		ifFalse: ...
\end{code}
Un \emph{wrapper} est créé et installé pour chaque méthode à valider.
Après le lancement des tests, tous les \emph{wrappers} sont désinstallés.
En retour, l'utilisateur est informé des méthodes qui n'ont pas été couvertes. 
%% Finally the user obtains feedback concerning the methods that have not been covered.

Comment le \emph{wrapper} fonctionne?
Le \emph{wrapper} \ct{TestCoverage} a trois variables d'instance: \ct{hasRun}, \ct{reference} et \ct{method}.
Elles sont initialisées comme suit:
\begin{code}{}
TestCoverage class>>>on: aMethodReference
	^ self new initializeOn: aMethodReference

TestCoverage>>>initializeOn: aMethodReference
	hasRun := false.
	reference := aMethodReference.
	method := reference compiledMethod
\end{code}

Les méthodes d'installation et de désinstallation mettent à jour tout simplement le dictionnaire des méthodes de façon évidente:
\begin{code}{}
TestCoverage>>>install
	reference actualClass methodDictionary
		at: reference methodSymbol
		put: self

TestCoverage>>>uninstall
	reference actualClass methodDictionary
		at: reference methodSymbol
		put: method
\end{code}
\noindent
La méthode \ct{run:with:in:} quant à elle met à jour la variable \ct{hasRun}, désinstalle le \emph{wrapper} (puisque la couverture a été vérifiée) et \arevoir{refait un envoi du message avec la méthode originale}. % REVOIR martial: bizarre!
%% and resends the message to the original method
\begin{code}{}
run: aSelector with: anArray in: aReceiver
	self mark; uninstall.
	^ aReceiver withArgs: anArray executeMethod: method

mark
	hasRun := true
\end{code}
En aparté, vous pouvez jeter un coup d'\oe il à la méthode de classe
\clsmthind{ProtoObject}{withArgs:executeMethod:} pour voir comment
une méthode hors du dictionnaire de méthode peut être appelée.
%% to see how a method displaced from its method dictionary can be invoked.

C'est tout!
%That's all there is to it!
Les \emph{wrappers} de méthode peuvent être utilisés pour effectuer toutes sortes d'actions avant ou après les opérations d'une méthode.  Les applications classiques sont \arelire{l'instrumentation du code source (collecter des données statistiques sur les appels de méthodes), les clauses optionnelles pré-conditionnelles ou post-conditionnelles de vérification et la \emph{mémoization} %% wikipedia
(mise en cache facultative de valeurs résultantes de méthodes)}.

%======================================
\section{Les \pragmas}

Un \emphind{pragma} est une annotation qui donne des informations sur un programme mais qui n'est pas directement impliqué dans l'exécution de ce programme. Les \pragmas n'ont pas d'effet direct lors du déroulement d'une méthode annotée.
Les \pragmas sont très utiles notamment pour:
\begin{itemize}
\item donner de l'information au compilateur: les \indmain{pragmas} peuvent être utilisés par le compilateur pour qu'une méthode appelle une fonction primitive. Cette fonction doit être définie par la machine virtuelle ou au moyen d'un greffon externe;
\item donner de l'information à l'exécution.
\end{itemize}

Les \pragmas s'utilisent uniquement lors de la déclaration des méthodes d'un programme. Une méthode peut déclarer un ou plusieurs \pragmas qui sont écrits avant toutes expressions \st. En réalité, un \pragma défini une sorte de message statique avec des arguments qui sont des littéraux.

Nous avons déjà parlé brièvement des \pragmas lorsque nous avons briévement introduit la notion de primitives précédemment dans ce chapitre. Une primitive n'est rien moins qu'une déclaration de \pragma. 
Considérons par exemple \ct{<primitive: 73>} qui se trouve dans la méthode \ct{instVarAt:}. Le sélecteur du \pragma est \ct{primitive:} et son argument est le littéral \ct{73}. 

Le compilateur \st est probablement l'un des utilisateurs les plus important des \pragmas. \sunit est un autre outil qui utilise les annotations. \sunit est capable de déterminer la couverture d'une application à partir d'un test unitaire. Il est parfois souhaitable d'exclure certaines méthodes de ce calcul de couverture. C'est le cas par exemple de la méthode \ct!documentation! dans la classe \ct!SplitJointTest! :

\begin{code}{}
SplitJointTest class>>>documentation
	<ignoreForCoverage>
	"self showDocumentation"
	
	^ 'This package provides function... "
\end{code}

En annotant une méthode par un \pragma \ct!<ignoreForCoverage>!, il est possible de limiter le champ d'application du calcul de la couverture.

%Beside the compiler, Lint is a heavy user of \pragmas. Lint is a static code analyzer that flags suspicious, non-portable constructs and code that is likely to contain bugs. It may happen that a method needs to be excluded from Lint analysis. This is the case here:

%\begin{code}{}
%MorphObjectOut>>>doesNotUnderstand: aMessage 
%	"Bring in the object, install, then resend aMessage"
%	"Transcript show: thisContext sender selector; cr."
%	"useful for debugging"
%	
%	! \textbf{<lint: 'Unnecessary "= true"' rationale: 'recursionFlag may be nil' author: 'stephane.ducasse'>}!
%	...
%\end{code}	

%One of the \pragmas used by Lint to filter out methods is \ct{lint:rationale:author:}.

Instances de la classe \clsind{Pragma}, les \pragmas sont donc de véritables objets. Une méthode compilée peut retourner une réponse au message \mthind{CompiledMethod}{pragmas}. Cette méthode retourne un tableau de \pragmas.

\begin{code}{@TEST}
(SplitJoinTest class >> #showDocumentation) pragmas. --> an Array(<ignoreForCoverage>)
(Float>>#+) pragmas --> an Array(<primitive: 41>)
\end{code}

Les méthodes définissant une requête particulière peuvent être retrouvées à partir d'une classe. La classe \ct!SplitJoinTest! contient certaines méthodes de classes annotées avec \ct!<ignoreForCoverage>! :

\begin{code}{@TEST}
Pragma allNamed: #ignoreForCoverage in: SplitJoinTest class  --> an Array(<ignoreForCoverage> <ignoreForCoverage> <ignoreForCoverage>)
\end{code}

Une variante de la méthode \ct{allNamed:in:} peut être trouvée dans les méthodes de classe de \ct{Pragma}.

Un \pragma sait dans quelle méthode il a été défini \mbox{(en utilisant \ct{method})}, le nom de la méthode (\ct{selector}), la classe qui contient la méthode \mbox{(\ct{methodClass})}, le nombre de ses arguments (\ct{numArgs}) et quel littéral a été défini comme argument du \pragma (\ct{hasLiteral:} et \ct{hasLiteralSuchThat:}).

%\lr{Typically \pragmas are performed on an interpreter object that understands the \pragma message.}

%======================================
\section{Résumé du chapitre}

Le réflexivité se définit par la faculté d'interroger, d'examiner et même de modifier les méta-objets du système d'exécution tels que de simples objets. Nous avons vu que:

\begin{itemize}
\item L'inspecteur utilise \ct{instVarAt:} et les méthodes connexes pour observer et modifier les variables d'instance ``privées'' des objets.
\item Nous pouvons envoyer \ct{Behavior>>>allInstances} pour requêter les instances d'une classe.
\item Les messages \ct{class}, \ct{isKindOf:}, \ct{respondsTo:}\etc sont utiles pour recueillir des métriques ou construire des outils de développement tout en gardant à l'esprit qu'il faut éviter d'utiliser ces messages dans des applications courantes: ils violent l'encapsulation des objets et rendent le code plus complexe à comprendre et à maintenir.
\item \ct{SystemNavigation} est une classe utilitaire contenant de nombreuses requêtes utiles pour la navigation dans la hiérarchie de classes. Par exemple, utiliser \ct{SystemNavigation default browseMethodsWithSourceString: 'pharo'.} permet de localiser et de parcourir (lentement!) toutes les méthodes avec une chaîne de caractère \emph{source} donnée.
\item Toutes les classes \st pointent vers une instance de \ct{MethodDictionary} qui associe les sélecteurs aux méthodes compilées, instances de \ct{CompiledMethod}. Une méthode compilée connaît sa classe (ce qui ferme la boucle).
\item \ct{MethodReference} est une version allégée d'un \emph{proxy} pour une méthode compilée, disposant de méthodes de commodités additionnelles; il est utilisé par de nombreux outils \st.
\item \ct{BrowserEnvironment}, partie prenante de l'infrastructure du Refactoring Browser, offre une interface plus raffinée que \ct{SystemNavigation} pour interroger le système puisque le résultat d'une requête peut être utilisé comme champ d'une nouvelle requête. Les interfaces disponibles sont à la fois graphiques et programmatiques.
%% since the result of a query can be used as a the scope of a new query. Both GUI and programmatic interfaces are available.
\item \ct{thisContext} est une \emph{pseudo-variable} qui réifie la pile d'exécution de la machine virtuelle. Elle est essentiellement utilisée par le débogueur pour construire dynamiquement une vue interactive de la pile. Elle est aussi spécialement utile pour déterminer dynamiquement le \sender d'un message.
\item Les points d'arrêts intelligents peuvent être disposés en utilisant \ct{haltIf:} avec un sélecteur de méthode comme argument.
\ct{haltIf:} suspend seulement si la méthode nommée apparaît comme \sender dans une pile d'exécution.
%% occurs as a sender in the run-time stack.
\item Une méthode courante pour intercepter les messages envoyés à une cible donnée consiste à utiliser un ``objet minimal'' comme \emph{proxy} de cette object-cible. Le \emph{proxy} implémente aussi peu de méthodes que possible et capture tous les messages envoyés en implementant \ct{doesNotunderstand:}. Il peut effectuer ensuite certaines actions complémentaires et faire suivre le message à la cible d'origine.
\item Nous pouvons envoyer \ct{become:} pour intervertir les références de deux objets tels qu'un \emph{proxy} et sa cible.
\item Nous devons faire attention au fait que certains messages tels que \ct{class} et \ct{yourself} ne sont jamais véritablement envoyés mais sont interprétés par la machine virtuelle. D'autres messages comme \ct{+}, \ct{-} et \ct{ifTrue:} peuvent être directement interprétés ou \emph{inline} dans la machine virtuelle en fonction du receveur.
%% inlined by the VM depending on the receiver.
\item Le chargement paresseux ou la compilation de méthodes manquantes est une
autre utilisation typique de la surcharge de \ct{doesNotUnderstand:}.
\item \ct{doesNotUnderstand:} ne peut pas capturer les envois à \self.
\item Utiliser un objet comme un \emph{wrapper} de méthode est une technique plus rigoureuse pour intercepter les messages. De tels objets sont installés dans un dictionnaire de méthodes à la place d'une méthode compilée.
Ces \emph{wrappers} doivent implémenter \ct{run:with:in:} qui est envoyé par la machine virtuelle quand elle détecte un objet ordinaire au lieu d'une méthode compilée dans le dictionnaire de méthodes. 
%% ERREUR dans VO pragma vs wrappers
% ajout vf only
\item Les \pragmas apportent à \pharo un moyen d'expression fantastique. Ces annotations sont utilisées par le Test Runner de \sunit pour collecter les données de couverture des tests passés.
\end{itemize}

%=========================================================
\ifx\wholebook\relax\else
   \bibliographystyle{jurabib}
   \nobibliography{scg}
   \end{document}
\fi
%=========================================================

%Other stuff:
%- anonymous classes (uses compile: and primitiveChangeClassTo:) ???
%- collect direct senders; class collaborations
%- Object primitiveChangeClassTo: become: and becomeForward: (see tests and slides with minimal object example)
%- PointerFinder?
%- anonymous classes (see slides) ?

%Test  Coverage using ObjectsAsMethodsWrap package:
%\begin{code}{}
%category := 'SCGPier'.
%w := (ObjectAsOneTimeMethodWrapper installOnClassCategory: category).
%tr := TestRunner new.
%ToolBuilder open: tr.
%[tr
%	categoryAt: (tr categoryList indexOf: 'SCGPier') put: true;
%	selectAllClasses;
%	runAll.]
%ensure: [[w do: [:each| each uninstall ]] valueUnpreemptively].
%((w select: [:each | each executed not ])
%	collect: [:each | each wrappedClass name, '>>', each selector name ]) explore.
%\end{code}

%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% ispell-local-dictionary: "fr"
%%% TeX-master: t
%%% TeX-PDF-mode: t
%%% End:

