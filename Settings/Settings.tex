% $Author: ducasse $
% $Date: 2009-08-24 10:17:33 +0200 (Mon, 24 Aug 2009) $
% $Revision: 28563 $

% HISTORY:
% 2010-02-19 - Stef started

%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
\fi
%=================================================================
%\renewmessage{\nnbb}[2]{} % Disable editorial comments
\sloppy
%=================================================================
\chapter{The Settings Framework}

When an application gets mature it often needs to provide variations such as the default selection color, the default font and the default font size... Often such variations represent user preferences of possible software customizations. 
Since the 1.1 release, Pharo contains and uses the Settings framework to manage its preferences. With Setting, an application can expose its configuration. Settings is not limited to manage Pharo preferences but we suggest to use for any application. The nice thing about Settings is that it is not intrusive, it supports a modular decomposition of software and can be added to an application after its inception. This is what we will see now.

\section{Settings in a Nutshell}

Setting supports an object-oriented approach to preferences definition and manipulation. What we want to express by this sentence is that each package or subsystem should define its own customization points (often represented as a variable). The code of a subsystem then freely accesses such customization value and use it to change it behavior to reflect the preference. Then using Setting, a subsystem describe its preferences so that the end user can manipulate them. However, at not point in time, the code of a subsystem will explicit refer to setting objects to adapt its behavior. The control flow of a subsystem does not involve Setting. This is the major point of difference between Setting and the preference system available in Pharo1.0.

A preference is a particular \emph{value} which is usually accessible. Basically such a preference value is stored in a class variable or in an instance variable of a singleton and is directly managed through the use of simple accessors. Pharo contains numerous preferences such as the user interface theme, the desktop background color or a boolean flag to allow or prohibit the use of sound are currently declared as preferences. We will show how we can define a preference in Section~\ref{sec:ProgrammingAPreference}. 

Pharo users need to browse existing preferences and eventually change their value, this is the major role of the settings browser presented in section~\ref{sec:TheSettingsBrowser}.

A setting is a \emph{declaration} (description) of a preference value. To be viewed and updated through the setting browser, a preference value must be described by a setting. Such a setting is built by a particular method tagged with a pragma. The section~\ref{sec:DeclaringASetting} explains how to declare a setting.

\section{The Setting Browser}
\label{sec:TheSettingsBrowser}

The setting browser, shown in figure~\figref{fig:TheSettingsBrowser}, mainly allows the browsing of all currently declared settings and to change related preference values. To open it, just use the World menu (\menu{World \go System \go Settings}) or evaluate the following expression:
\begin{code}{}
SettingBrowser open
\end{code}
The settings are presented in several trees in the middle panel. Setting searching and filtering is available from the top toolbar whereas the bottom panels show currently selected setting description (left bottom panel) and current package set (right bottom panel). 
\begin{figure}[tbh]
\begin{center}
\includegraphics[scale=0.3]{SettingBrowser}
\caption{The settings browser}
\figlabel{fig:TheSettingsBrowser}
\end{center}
\end{figure}

\subsection{Browsing and changing preference values}
Setting declarations are organized in trees which can be browsed in the middle panel. In order to get a description for a setting, just click on it: the setting is selected and the left bottom panel is updated with informations about the selected setting. 

Changing a preference value is simply done through the browser: each line holds a widget on the right with which you can update the value. The kind of widget depends on the actual type of the preference value. Whereas a preference value can be of any kind, the setting browser is currently able to present a specific input widget for the following types: \textit{Boolean}, \textit{Color}, \textit{FilePath}, \textit{FileDirectory}, \textit{Font}, \textit{Number}, \textit{Point} and \textit{String}. A drop-list, a password field or a range input widget using a slider can also be used. Of course, the list of possible widgets is not closed as it is possible to make the setting browser support new kind of preference values or use different input widgets. This point is explained in section~\ref{sec:ExtendingTheSettingsBrowser}.
\sd{do you explain how we can script also settings? }

If the actual type of a setting is either \textit{String}, \textit{FilePath}, \textit{FileDirectory}, \textit{Number} or \textit{Point},  to change a value, the user has to enter some text in a editable drop-list widget. In such a case, the input must be confirmed by hitting the return key (or with cmd-s). If such a setting value is changed often, the drop-list widget is very handy because you can retrieve and use previously entered values in one click!

Other possible actions are all accessible from the contextual menu.
Depending on the selected setting, they may be different. Three versions of it are shown in \figref{fig:TheSettingsBrowserPopupMenu}.
\begin{figure}[tbh]
\begin{center}
\begin{tabular}{ccc}
\includegraphics[scale=0.5]{popup0.png} & 
	\includegraphics[scale=0.5]{popup1.png} & 
	\includegraphics[scale=0.5]{popup2.png} \\ 
\end{tabular} 
\caption{The contextual popup menu}
\figlabel{fig:TheSettingsBrowserPopupMenu}
\end{center}
\end{figure}
\begin{itemize}
\item \textbf{Browse (b)}: opens a system browser on the method which declares the setting. It is also accessible via the keyboard shortcut \textit{cmd-b} or if you double-click on a setting. It is very handy if you want to change the setting implementation or simply see how it is implemented to understand the framework by investigating some examples (how to declare a setting is explained in Section~\ref{sec:DeclaringASetting}).
\item \textbf{Set to default (d)}: set the selected setting value to the default one. It is very handy if, as an example, you have played with a setting to observe its effect and finally decide to come back to its default. It is also possible to set to default all settings is one single action, this is explained in Section \ref{sec:SettingStylesManagement}.
\item \textbf{Empty list (e)}: If the input widget is an editable drop-list, this menu item allows one to forget previously entered values by emptying the recorded list.
\end{itemize}

\subsection{Searching and filtering settings}
Pharo contains a lot of settings and finding one of them can be tedious. 
You can filter the settings list by entering something in the search text field of the top bar of the SettingsBrowser. Then, only the settings which name or description contains the text you've entered will be shown. The text can be a regular expression if the "Regexp" checkbox is checked.

Another way to filter the list of settings is to choose them by package. Just click on the "Choose package" button, then a dialog is opened with the list of packages in which some settings are declared. If you choose one or several of them, then, only settings which are declared in the selected packages will be shown. Notice that the bottom right text pane is updated with the name of the selected packages.

Depending on where and when you are using Pharo, you may have to change preferences repeately. As an example, when you are doing a demonstration, you may want to have bigger fonts, at work you may need to set a proxy whereas at home none is needed. Having to change a set of preferences depending on where you are and what you are doing can be very tedious and boring. With the setting browser it is possible to save the current set of preference values in a named style that can be reloaded later. Setting style management is presented in Section~\ref{sec:SettingStylesManagement}.
\sd{How do you save a preference list? BTW you have remove and all the other item of the style starts with uppercase}

\section{Declaring a setting}
\label{sec:DeclaringASetting}

All global preferences of Pharo can be viewed or changed using the SettingBrowser. A preference is typically a class variable or an instance variable of a singleton. If one want to be able to change its value from the \textit{SettingsBrowser}, then a setting must be declared for it.
A setting is declared by a particular class method which have to be implemented as follows: it takes a builder as argument and it is tagged by the \textit{<systemsettings>} simple pragma. 
%As an example: 
%\begin{code}{}
%AClassInMyPackage class>>settingOn: aBuilder
%  <systemSettings>
%  (aBuilder group: #MySettings)
%    label:'My settings' ...
%\end{code}
The argument \ct{aBuilder} serves as a facade for setting declarations building and the pragma allows the SettingBrowser to dynamically discover current setting declarations.

The important point is that a setting declaration must be package specific. It means that each package is responsible for the declaring of its own settings. For a particular package, specific settings are declared by one or several of its classes. The direct benefit is that when the package is loaded, then its settings are automatically loaded and that when a package is unloaded, then its settings are automatically unloaded. In addition a Setting declaration should not refer to any Setting class but to the builder argument. This makes sure that your application is not dependent from Setting and that you will be able to remove Setting if you want to 
define extremely small footprint applications. 

\subsection{A simple setting}
Let's take the example of the \ct{caseSensitiveFinds} preference. It is a boolean preference which is used for text searching. If it is \ct{true}, then a text finding is case sensitive. This preference is stored in the \ct{CaseSensitiveFinds} class variable in \ct{ParagraphEditor}. Its value can be queried and changed by, respectively, \ct{ParagraphEditor class>>caseSensitiveFinds} and \ct{ParagraphEditor class>>caseSensitiveFinds:} given below:
\begin{code}{}
ParagraphEditor class>>caseSensitiveFinds
	^ CaseSensitiveFinds ifNil: [CaseSensitiveFinds := false]

ParagraphEditor class>>caseSensitiveFinds: aBoolean
	CaseSensitiveFinds := aBoolean
\end{code}

To define a setting for this preference (the \ct{CaseSensitiveFinds} class variable) and be able to see it and change it from the settings browser, the method below should be implemented. The result is shown in the screenshot of the \figref{fig:caseSensitiveFinds1}. 

\begin{code}{}
CodeHolderSystemSettings class>>caseSensitiveFindsSettingsOn: aBuilder
	<systemsettings>
	(aBuilder setting: #caseSensitiveFinds) 
		target: ParagraphEditor;
		label: 'Case sensitive search' translated;
		description: 'If true, then the "find" command in text will always make its searches in a case-sensitive fashion' translated;
		parent: #codeEditing.
\end{code}

\begin{figure}[tbh]
\begin{center}
\includegraphics[scale=0.4]{caseSensitiveFinds_setting_declaration1}
\caption{The \textit{caseSensitiveFinds} setting}
\figlabel{fig:caseSensitiveFinds1}
\end{center}
\end{figure}

Now, let's study this setting declaration with more details. 

\subsubsection{The header}
\begin{code}{}
CodeHolderSystemSettings class>>caseSensitiveFindsSettingsOn: aBuilder
...
\end{code}
This class method is declared in CodeHolderSystemSettings. This class is dedicated to settings and contains nothing but settings declarations. Defining such a class is not mandatory, in fact any class can have settings declarations. We define it that way to make sure that the setting declaration is simply packaged in a different package than the one of the preference definition.

This method takes a builder as argument. This object serves as a facade for settings buildings: the contents of the method essentially consists in sending messages to the builder to declare and organize a sub-tree of settings.

\subsubsection{The pragma}
A setting declaration is tagged with the \ct{<systemsettings>} pragma.
\begin{code}{}
CodeHolderSystemSettings class>>caseSensitiveFindsSettingsOn: aBuilder
	<systemsettings>
...
\end{code}
In fact, when the settings browser is opened, it first collects all settings declarations by searching all methods with the \ct{<systemsettings>} pragma. More, if you compile a setting declaration method while a settings browser is opened then it is automatically updated with the new setting. 

\subsubsection{The setting building}
A setting is simply declared by sending the message \ct{setting:} to the builder with an identifier passed as argument:
\begin{code}{}
CodeHolderSystemSettings class>>caseSensitiveFindsSettingsOn: aBuilder
	<systemsettings>
	(aBuilder setting: #caseSensitiveFinds) 
...
\end{code}
By default, the identifier passed as argument is considered as the selector which can be used by the settings browser to get the preference value and the selector for changing the preference value is by default built by adding a colon to the getter selector (\ie \ct{caseSensitiveFinds:} here).

These selectors are sent to a target which is by default the class in which the method is implemented (\ie \ct{CodeHolderSystemSettings}). Thus, this one line setting declaration would be sufficient if  \ct{caseSensitiveFinds} and \ct{caseSensitiveFinds:} accessors were implemented in \ct{CodeHolderSystemSettings}. Here, instead, these accessors are implemented in \ct{ParagraphEditor}. Then, it must be explicitly set that the target is \ct{ParagraphEditor} as done below:
\begin{code}{}
CodeHolderSystemSettings class>>caseSensitiveFindsSettingsOn: aBuilder
	<systemsettings>
	(aBuilder setting: #caseSensitiveFinds) 
		target: ParagraphEditor
\end{code}
\begin{figure}[tbh]
\begin{center}
\includegraphics[scale=0.4]{caseSensitiveFinds_setting_declaration2}
\caption{the very simple version of the \textit{caseSensitiveFinds} setting}
\figlabel{fig:caseSensitiveFinds2}
\end{center}
\end{figure}
This very short version is enough to be compiled and taken into account by the settings browser as shown by \figref{fig:caseSensitiveFinds2}.
Unfortunately, the presentation is not user-friendly because:
\begin{itemize}
\item the label shown in the settings browser is its identifier,
\item there is no description or explanation available for this setting and,
\item the new setting is simply added at the root of the setting tree. 
\end{itemize}
You can indicate a label and a description with respectively the \ct{#label:} and \ct{#description:} messages which take a string as argument. Don't forget to send \ct{#translated} to the label and the description strings, it will greatly facilitate the translation in other languages.

Concerning the classification and the settings tree organisation, there are several ways to improve it and this point is fully detailed in the next section.

\subsection{Organising your settings}

Within the settings browser, settings are organised in trees where related settings are shown as children of the same parent. 

\subsubsection{Declaring a parent}
The simplest way to declare your setting as a child of another setting is to use the \ct{#parent:} message with the identifier of the parent setting passed as argument. In the example below, the parent node is an existing node declared with the \ct{#codeEditing} identifier. 
\begin{code}{}
CodeHolderSystemSettings class>>caseSensitiveFindsSettingsOn: aBuilder
	<systemsettings>
	(aBuilder setting: #caseSensitiveFinds) 
		target: ParagraphEditor;
		label: 'Case sensitive search' translated;
		description: 'If true, then the "find" command in text will always make its searches in a case-sensitive fashion' translated;
		parent: #codeEditing.
\end{code}
Then, it means that the \ct{#codeEditing} node is also declared somewhere in the system. As an example, it could be declared as follow:
\begin{code}{}
CodeHolderSystemSettings class>>codeEditingSettingsOn: aBuilder
	<systemsettings>
	(aBuilder group: #codeEditing) 
		label: 'Editing' translated;
		parent: #codeBrowsing.
\end{code}
Notice that the \ct{#codeEditing} node is created by sending the \ct{#group:} message to the builder with its identifier passed as argument. A group is a simple node without any value and which is only used for children grouping. Notice also that, as shown in the \figref{fig:caseSensitiveFinds1}, the \ct{#codeEditing} node is not at root because it is declared itself as a child of the \ct{#codeBrowsing} node.

\subsubsection{Declaring a sub-tree}
Being able to declare its own settings as a child of a pre-existing node is very useful when a package wants to enrich existing standard settings. But it can also be very tedious for settings which are very application specific. 

Thus, directly declaring a sub-tree of settings in one method is also possible. Then, typically, a root group is declared for the application settings and the children settings themselves are also declared within the same method. This is simply done through the sending of the \ct{with:} message to the root group. The \ct{with:} message takes a block as argument. In this block, every new settings are implicitely declared as children of the root group (the receiver of the \ct{with:} message). 

\begin{figure}[tbh]
\begin{center}
\includegraphics[scale=0.47]{configurableFormatter}
\caption{Declaring a subtree in one method: the \textit{Configurable formatter} setting example}
\figlabel{fig:configurableFormatter}
\end{center}
\end{figure}
As an example, take a look at figure \figref{fig:configurableFormatter}, it shows the settings for the refactoring browser configurable formatter. This sub-tree of settings is fully declared in the method \ct{RBConfigurableFormatter class>>settingsOn:} given below. You can see that it declares the new root group \ct{#configurableFormatter} with two children, \ct{#formatCommentWithStatements} and \ct{#indentString}:
\begin{code}{}
RBConfigurableFormatter class>>settingsOn: aBuilder
	<systemsettings>	
	(aBuilder group: #configurableFormatter)
		target: self;
		parent: #refactoring;
		label: 'Configurable Formatter' translated;
		description: 'Settings related to the formatter' translated;
		with: [
			(aBuilder setting: #formatCommentWithStatements)
				label: 'Format comment with statements' translated.
			(aBuilder setting: #indentString)
				label: 'Indent string' translated]
\end{code}

\subsubsection{Optional sub-tree}
Sometime, depending on the value of a particular preference, one might want to hide some settings because it doesn't make sense to show them. As an example, if the background color of the desktop is plain then it doesn't make sense to show settings which are related to gradient background. Instead, if the user wants a gradient background, then a second color, the gradient direction and the gradient origin settings should be presented. 
Look at the \figref{fig:optional-subtree}:
\begin{itemize}
\item on the left, the \textit{Gradient} widget is unchecked meaning that its actual value is \ct{false}; in this case, it has no children, 
\item on the right, the \textit{Gradient} widget is checked, then the setting value is set to \ct{true} and as a consequence, the settings useful in order to set a gradient background are shown.
\end{itemize}
\begin{figure}[tbh]
\begin{center}
\begin{minipage}[t]{0.49\linewidth}
\includegraphics[scale=0.35]{smart-subtree1}
\end{minipage}
\begin{minipage}[t]{0.49\linewidth}
\includegraphics[scale=0.35]{smart-subtree2}
\end{minipage}
\caption{Example of optional subtree}
\figlabel{fig:optional-subtree}
\end{center}
\end{figure}

In order to handle such optional settings the only thing is to declare them as children of a boolean parent setting. In this case, children settings are shown only if the parent value is \ct{true}. Concerning the desktop gradient example, the setting is declared in \ct{PolymorphSystemSettings} as given below:
\begin{code}{}
	(aBuilder setting: #useDesktopGradientFill)
		label: 'Gradient';
		description: 'If true, then more settings will be available in order to define the desktop background color gradient';
		with: [
			(aBuilder setting: #desktopGradientFillColor)
				label: 'Other color';
				description: 'This is the second color of your gradient (the first one is given by the "Color" setting' translated.
			(aBuilder pickOne: #desktopGradientDirection)
				label: 'Direction';
				domainValues: {#Horizontal. #Vertical. #Radial}.
			(aBuilder pickOne: #desktopGradientOrigin)
				label: 'Origin';
				domainValues: {
					'Top left' translated -> #topLeft. ...
\end{code} 
The parent setting value is given by evaluating \ct{PolymorphSystemSettings class>>#useDesktopGradientFill}. If it returns \ct{true}, then the children \ct{#desktopGradientFillColor}, \ct{#desktopGradientDirection} and \ct{#desktopGradientOrigin} are shown.

\subsection{Restricting the value domain}
By default, the possible value set is not restricted and is given by the actual type of the preference. As examples, for a color preference, the widget allows you to choose whatever color, for a number, the widget allows the user to enter whatever number.
But, in some cases, only a particular set of values are desired. As an example, for the standard browser or for the user interface theme settings, the choice must be made among a finite set of classes, for the free type cache size, only a range from 0 to 50000 is allowed. In these cases, the widget must allow only particular values. So far, the domain value set can be constrained either with a range or with a list of values.

\subsubsection{Declaring a range setting}
\begin{figure}[tbh]
\begin{center}
\includegraphics[scale=0.38]{fullScreenMargin}
\caption{Example of range setting}
\figlabel{fig:range-setting}
\end{center}
\end{figure}

\subsubsection{Selecting among a list}
\begin{figure}[tbh]
\begin{center}
\includegraphics[scale=0.38]{userInterfaceTheme}
\caption{Example of list setting}
\figlabel{fig:list-setting}
\end{center}
\end{figure}
%2.2.5 Font setting
%Here the default is an instance of LogicalFont:
%------------------
%MyClass class>>codeFont
%	<setting>
%	^ CodeFont
%		ifNil: [CodeFont := (SettingManager newSetting: 'Code') description: 'The code font';
%						 parent: #fontSettingNode;
%						 default: (LogicalFont familyName: 'DejaVu Sans' 
%												fallbackFamilyNames: nil 
%												pointSize: 12 
%												stretchValue: 5 
%												weightValue: 400 
%												slantValue: 0)]
%------------------
%
%The default can also be set with a MessageSend instance:
%------------------
%MyClass class>>codeFont
%	<setting>
%	^ CodeFont
%		ifNil: [CodeFont := (SettingManager newSetting: 'Code') description: 'The code font';
%						 parent: #fontSettingNode;
%     				 default: (MessageSend receiver: self selector: #defaultStandardFont)]
%
%MyClass class>>defaultStandardFont
%	^ LogicalFont
%		familyName: 'DejaVu Sans'
%		fallbackFamilyNames: nil
%		pointSize: 12
%		stretchValue: 5
%		weightValue: 400
%		slantValue: 0
%------------------
%
%3 DECLARING A SETTING WITH FINITE SET OF VALUES
%
%3.1 PRESENTATION
%A setting can be defined so that its value is get from a restricted set of values. The setting is an instance of MultipleSettingValue. It is instanciated with #SettingManager class>>newMultiple:. The argument is the name of the setting. The collection of values from which a multiple setting takes its value is always a set of FixedSettingValue. A FixedSettingValue is created with #SettingManager class>>newFixed:.
%
%Such a setting can be of two different kinds :
%- if the valid value list is known at declaration time and is constant, then the list of values is set by sending the #domainValues: message to the setting. The argument is an array of fixed values. 
%
%Such a setting can be declared as below:
%------------------
%MyPackageSettings class>>mySetting
%	<setting>
%	^ MySetting 
%		ifNil: [MySetting := (SettingManager newMultiple: 'My setting name') 
%						description: 'A useful description'; 
%						default: aDefaultValue;
%						domainValues: aListOfFixedSettingValues]
%------------------
%					
%The default should be one of the valid values: a real value which is token from the list of possible values. 
%
%- if the valid value list is not known at declaration time, then the list of possible values is dynamically computed by the SystemSettingBrowser by evaluating the block or the MessageSend stored as the getter instance variable value. The getter instance variable is set by sending the #domainValuesGetter: message to the setting.
%
%Such a setting can be declared as below:
%------------------
%MyPackageSettings class>>mySetting
%	<setting>
%	^ MySetting 
%		ifNil: [MySetting := (SettingManager newMultiple:'My setting name') 
%						description: 'A useful description'; 
%						default: aDefaultValue;
%						domainValuesGetter: aBlockOrAMessageSend]
%------------------
%The argument of #domainValuesGetter: can be a block or a instance of MessageSend. This valuable takes no argument. 
%
%3.2 EXAMPLES 
%
%The declaration gives all possibles values for the setting. Each possible domain value is a fixed setting (read-only setting). Here is the example of #hintingSetting which value can be #Light, #Normal, #Full or #None:
%------------------
%MyClass class>>hintingSetting
%	<setting>
%	^ HintingSetting
%		ifNil: [HintingSetting := (SettingManager newMultiple: 'Hinting')
%						 description: 'Defines the glyph shapes' translated;
%						 parent: #freeTypeSettingNode;
%						 domainValues: {
%							SettingManager newFixed value: #Light. 
%							SettingManager newFixed value: #Normal. 
%							SettingManager newFixed value: #Full. 
%							SettingManager newFixed value: #None
%						}].
%------------------
%
%In the case where domain values are of simple type, as Symbol for example, the shorter declaration given below can be used:		
%------------------
%MyClass class>>hintingSetting
%	<setting>
%	^ HintingSetting
%		ifNil: [HintingSetting := (SettingManager newMultiple: 'Hinting')
%						 description: 'Defines the glyph shapes' translated;
%						 parent: #freeTypeSettingNode;
%						 domainValues: {#Light. #Normal. #Full. #None}]
%------------------
%
%The value domain can also be made of a set of complex objects. The example below shows #themeSetting setting. The value domain is an array with two fixed settings, for UIThemeStandardSqueak and for UIThemeWatery2:
%------------------
%MyClass class>>themeSetting
%	<setting>
%	^ ThemeSetting
%		ifNil: [ThemeSetting := (SettingManager newMultiple: 'UITheme')
%						description: 'The theme to use for UI look and feel';
%						parent: #uiSettingNode;
%						type: #UITheme;
%						default: UIThemeWatery2;
%						domainValues: {
%							(SettingManager newFixed: 'Standard Squeak') value: UIThemeStandardSqueak. 
%							(SettingManager newFixed: 'Watery 2') description: 'Similar to a nice OS'; value: UIThemeWatery2}]
%------------------
%
%The shorter declaration given below can also be used. The domain values is a list of association. Each association key is used as the name of the fixed setting, and the corresponding association value is used as the value of the fixed setting:
%------------------
%MyClass class>>themeSetting
%	<setting>
%	^ ThemeSetting
%		ifNil: [ThemeSetting := (SettingManager newMultiple: 'UI theme')
%						 description: 'The theme to use for UI look and feel';
%						 parent: #uiSettingNode;
%						 type: #UITheme;
%						 default: UIThemeWatery2;
%						 domainValues: {'Standard' -> UIThemeStandardSqueak. 'Watery 2' -> UIThemeWatery2}]
%------------------
%
%Previous version has a serious drawback: the list of possible values is fixed, then the first time the setting is read, the list is definitively built. After its building, there is no way to update the list except by the reinitializing of the corresponding class variable (hard reset). 
%Regarding the themeSetting example, the problem is that new instances of UITheme can be added in the system after the setting has been created and initialized. In order be able to take into account system dependent domain values, you can makes the list dynamically computed. A getter instance variable can be set to a block or to an instance of a MessageSend. Such a valuable is dynamically evaluated by the SystemSettingBrowser in order to get current and up-to-date list of valid values. Here is the themeSetting example revisited:
%
%------------------
%MyClass class>>themeSetting
%	<setting>
%	^ ThemeSetting
%		ifNil: [ThemeSetting := (SettingManager newMultiple:'UI theme')
%						parent: #uiSettingNode;
%						default: UIThemeWatery2;
%						domainValuesGetter: [UITheme allSubclasses collect: [:cls | SettingManager newFixed value: cls]]]
%------------------
%
%or with a much simpler version
%------------------
%MyClass class>>themeSetting
%	<setting>
%	^ ThemeSetting
%		ifNil: [ThemeSetting := (SettingManager newMultiple:'UI theme')
%						parent: #uiSettingNode;
%						default: UIThemeWatery2;
%						domainValuesGetter: [UITheme allSubclasses]]
%------------------
%
%4 DECLARING RANGE SETTING
%
%4.1 PRESENTATION
%A setting for which all possible values are given by a range is an instance of RangeSettingValue. Such a setting is instanciated with #SettingManager class>>newRange:. The argument is the name of the setting. The range is set by sending a #range: message to a setting. The argument is an Interval instance.
%
%Such a setting can be declared as below:
%------------------
%MyPackageSettings class>>mySetting
%	<setting>
%	^ MySetting 
%		ifNil: [MySetting := (SettingManager newRange: 'My setting name') 
%						description: 'A useful description'; 
%						default: aDefaultValue;
%						range: anInterval]
%------------------
%The range is an instance of Interval. It is set by the #range: message and is evaluated by the SystemSettingBrowser when choosing a new value.
%Note that the SystemSettingBrowser presents an input field and a slider. 
%
%4.2 EXAMPLE
%
%------------------
%FontSettings class>>glyphContrast
%	<setting>
%	^ GlyphContrast
%		ifNil: [GlyphContrast := (SettingManager newRange: 'Glyph contrast') 
%						description: 'Change the contrast level for glyphs. This is an integer between 1 and 100';
%						parent: #freeTypeSettingNode;
%						default: 50;
%						range: (1 to: 100)]
%------------------
%
%5 USING SPECIFIC DIALOG
%For setting browsing and editing, it could be useful to use a specific dialog instead of SystemSettingBrowser simple input widgets. For that purpose, the dialog attribute can be set with the name of a dialog class. While browsing a setting with a dialog, the SystemSettingBrowser presents a button for the dialog opening. The only constraint is that the dialog class must understand the #open message.
%
%For a node with children, it can be very useful in order to be able to use a cool dialog for the input of all children instead of being forced to input them one by one as it is the case with the SystemSettingrowser.
%
%Here is an example of a setting node with its dialog instance variable set to the value #FontSettingDialog. In the case of fonts, it could be useful in order to allow the using of a specific cool dialog for font preferences settings.
%------------------
%FontSettings class>>fontSettingNode
%	<setting> 
%	^ (SettingManager newNode: 'Fonts')
%		description: 'System fonts settings';
%		dialog: #FontSettingDialog;
%		parent: #uiSettingNode 
%------------------
%
%The dialog instance variable can be set for a setting value too. Then, neither the default value nor the type is needed:
%------------------
%UISettings class>>uiStyle
%	<setting>
%	^ UIStyle ifNil: [UIStyle := (SettingManager newSetting: 'UI style') 
%			dialog: #UIStyleChooserDialog; 
%			description: 'System style'].
%------------------
%
%6 SIMPLE SETTING WITH CHILDREN
%A setting value can be a parent for another setting value. As an example, #gradientButtonLook can be a child of a boolean setting #advancedGUISetting:
%------------------
%MyClass class>>advancedGUISetting
%	<setting>
%	^ AdvancedGUISetting
%		ifNil: [AdvancedGUISetting := 
%						(SettingManager newSetting: 'Advanced GUI settings')
%						parent: #uiSettingNode;
%						default: true]
%					
%MyClass class>>gradientButtonLook
%	<setting>
%	^ GradientButtonLook
%		ifNil: [GradientButtonLook := 
%						(SettingManager newSetting: 'Gradient look for buttons')
%						parent: #advancedGUISetting;
%						default: true]
%------------------
%


\section{Setting styles management}
\label{sec:SettingStylesManagement}

\section{Extending the setting browser}
\label{sec:ExtendingTheSettingsBrowser}

\section{How to access or set programmatically a setting}
\sd{do you think that it make sense?}
the idea is how people can customize their image?
They could save he setting browser?


\section{Programming a preference}
\label{sec:ProgrammingAPreference}


\sd{Not sure I would do that}

\section{Design of the Settings Framework}
\sd{may be we can throw away all that....}
The design of the Settings framework is based on the three following points: (1) a preference is not defined in a global class but local to the package that uses it, (2) settings can be declared independently from the application they refer to, (3) any setting declaration can be loaded even if the Settings framework is not loaded. 

Let's explain now these two points since they have an impact on the modular structure of Pharo. 

%\begin{figure}[tbh]
%\begin{center}
%\includegraphics[scale=0.3]{Principles}
%\caption{The Settings principles}
%\figlabel{principles}
%\end{center}
%\end{figure}

\paragraph{Local value with a local flow.}
The Settings framework supports the idea that a preference value is local to a package. A package should define either a singleton or a class variable defined somewhere on a class. The methods of the class are able to refer to the variable. The package should provide some way to get and set the value of the preference.

Understanding the difference to previous design as implemented in Squeak3.9 or Pharo1.0 is important. In previous versions, the class \ct{Preferences} was the place where the preferences as well as methods to change their values were defined. This implies that code using preferences was  referencing the class Preferences during its execution. The flow of control was clearly not local the class using the preferences but always executing some methods on the Preferences class. This design led to a system with a lot of hidden dependencies. 

\paragraph{No explicit dependency on the Setting Framework.}
Finally when declaring a setting, the code does not refer explicitly to any Setting class. This has the good property that you can load code containing setting declaration even if the Settings framework is not loaded. This way we make sure 
that we get a modular system. In case the settings framework is not loaded, the method containing the setting declaration is just not used by the system.



%=========================================================
\ifx\wholebook\relax\else
   \bibliographystyle{jurabib}
   \nobibliography{scg}
   \end{document}
\fi

%=================================================================
\ifx\wholebook\relax\else\end{document}\fi
%=================================================================

%-----------------------------------------------------------------

%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: t
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "english"
%%% End: