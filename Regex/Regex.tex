% $Author: oscar $
% $Date: 2009-08-27 11:02:51 +0200 (Thu, 27 Aug 2009) $
% $Revision: 28621 $

% HISTORY:
% 2008-01-15 - Stef first draft based on Vassily Bykov's documentation
% 2008-08-06 - Alex revised
% 2008-11-25 - Oscar revised
% 2009-04-17 - Fabrizio Perin reviewed
% 2009-04-18 - Jorge Ressia reviewed
% 2009-07-15 - Oscar indexing

%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
\fi
%=================================================================
%\renewcommand{\nnbb}[2]{} % Disable editorial comments
\sloppy
%=================================================================
\chapter{Les expressions régulières dans \pharo}\chalabel{regex}

%% note - regex = expr. reg. au pluriel

%\indexmain{Regular expressions|see{Regex}}
\indexmain{Expressions régulières|see{Regex}}
Les \expregs\footnote{NdT: traduit de l'anglais ``regular expressions''
  (d'où l'abrégé \emph{Regex}), le terme exact devrait être
  ``expressions rationnelles''.} sont très largement utilisés dans de
nombreux langages de script tels que \ind{Perl}, \ind{Python} et
\ind{Ruby}.
Ils sont utiles pour identifier des chaînes de caractères
correspondant à un certain \pattern (ou motif), pour vérifier que les
entrées sont conformes à un format attendu et pour réécrire des
chaînes de caractères dans un nouveau format.
\pharo dispose aussi des \expregs grâce au paquetage \pkgind{Regex} de
Vassili Bykov.\index{Bykov, Vassili}
\pkgregex est installé par défaut dans \pharo. Si vous utilisez une image
ancienne qui n'inclut pas le paquetage \pkgregex, vous pouvez
l'installer depuis
nllind{\sqsrc}\footnote{\url{http://www.squeaksource.com/Regex.html}}.

Une \expreg\footnote{\url{http://fr.wikipedia.org/wiki/Expression_rationnelle}}
%http://en.wikipedia.org/wiki/Regular_expression
est \arelire{une suite de caractères
% template - vf
dont la forme concorde avec un ensemble de chaînes de caractères}.
% is a template that matches a set of strings.
Par exemple, l'\expreg  \ct{'h.*o'} correspondera à la chaîne de
caractères \ct{'ho'}, \ct{'hiho'} et \ct{'hello'} mais elle ne
correspondera ni à \ct{'hi'} ni à \ct{'yo'}.
Nous pouvons voir celà dans \pharo ainsi:
\mthindex{String}{matchesRegex:}
\begin{code}{@TEST}
'ho' matchesRegex: 'h.*o'     --> true
'hiho' matchesRegex: 'h.*o'  --> true
'hello' matchesRegex: 'h.*o' --> true
'hi' matchesRegex: 'h.*o'      --> false
'yo' matchesRegex: 'h.*o'     --> false
\end{code}

Dans ce chapitre, nous commencerons avec un petit tutoriel dans lequel
nous développerons deux classes pour générer un \emph{site map} (ou
plan de site web) très succint.
Nous utiliserons les \expregs:
\begin{enumerate}
\item pour identifier des fichiers \ind{HTML},
\item pour extraire
%strip
le nom de fichier du chemin complet vers ce fichier, 
\item pour extraire le titre de chaque page web pour le \emph{site
    map} et
\item pour générer un chemin relatif depuis le répertoire racine du
  site web vers les fichiers HTML qu'il contient.
% to generate a relative path from the root directory of the web site to the HTML files it contains.
\end{enumerate}
Après avoir complété cet exemple, nous détaillerons le paquetage
\pkgregex en nous appuyant largement sur la documentation que Vassili
Bykov a inclus dans son paquetage\footnote{La documentation originale
  est accessible dans le côté classe de la classe \ct{RxParser}.}.

%=================================================================
\section{Le tutoriel\,---\,générer un \sitemap}

% All the code is in the package PBE-Regex in http://www.squeaksource.com/SqueakByExample

Nous allons réaliser une application simple qui permet la génération
d'un \sitemap pour une site web que nous aurions localement stocké sur
notre disque dur. Le \sitemap contiendra les liens vers chaque fichier
HTML sur le site web en utilisant le titre de la page comme texte du
lien. Les liens devront en outre refléter la structure de répertoires
du site web.

%-----------------------------------------------------------------
\subsection{Accéder au répertoire web}

\dothis{Si vous n'avez pas de site web sur votre machine, copiez
  quelques fichiers HTML vers un répertoire local pour servir de banc
  d'essai.}

Nous développerons deux classes, \ct{WebDir} et \ct{WebPage}, pour
représenter les répertoires et les pages web respectivement. L'idée
est de créer une instance de \ct{WebDir} qui pointera sur le
répertoire racine contenant notre site web. Lorsque nous enverrons à
cet objet le message \ct{makeToc}, il parcourira les fichiers et
sous-répertoires pour construire le \sitemap et enfin, il créera un
nouveau fichier appelé \ct{toc.html} et contenant les liens vers
toutes les pages du site.

Faites attention à ce que chaque \ct{WebDir} et chaque \ct{WebPage}
se souviennent du chemin vers la racine du site web; ainsi ils
pourront générer correctement les liens relatifs à la racine.

\dothis{Définissez la classe \ct{WebDir} avec les variables d'instance
\ct{webDir} et \ct{homePath} et définissez la méthode d'initialisation
appropriée.
Définissez aussi les méthodes de classe pour afficher la localisation
du site web sur votre machine comme suit:}

\begin{code}{}
WebDir>>setDir: dir home: path 
	webDir := dir.
	homePath := path

WebDir class>>onDir: dir
	^ self new setDir: dir home: dir pathName

WebDir class>>selectHome
	^ self onDir: FileList modalFolderSelector
\end{code}

La dernière méthode ouvre un navigateur de fichiers pour choisir le
répertoire à ouvrir.
Si nous inspectons maintenant le résultat de \ct{WebDir selectHome},
le système vous proposera de sélectionner le répertoire contenant vos
pages web et vous pourrez alors vérifier que les variables d'instance
 \ct{webDir} et \ct{homePath} ont bien été initialisées au répertoire
 contenant le site web et à son chemin complet (ou \emph{pathname}).

\begin{figure}[tbh]
\begin{center}
\includegraphics[width=0.8\textwidth]{aWebDir}
\caption{Une instance de WebDir.}
\figlabel{aWebDir}
\end{center}
\end{figure}

Ce serait bien de pouvoir instancier un \ct{WebDir} de façon
programmatique: ajoutons donc une autre méthode de création.

\dothis{Ajoutez les méthodes suivantes et essayez-les en inspectant le
  résultat de \mbox{\lct{WebDir onPath: '\emph{le chemin vers votre site web}'}}.}

\begin{code}{}
WebDir class>>onPath: homePath
	^ self onPath: homePath home: homePath

WebDir class>>onPath: path home: homePath
	^ self new setDir: (FileDirectory on: path) home: homePath
\end{code}

%-----------------------------------------------------------------
\subsection{Le \patmatch de fichiers HTML}

Pour l'instant, tout va bien.
%So far so good.
Nous aimerions utiliser maintenant les \expregs{} pour trouver quels
fichiers HTML ce site web contient.

Si nous naviguons dans la classe \ct{FileDirectory}, nous trouvons la
méthode \ct{fileNames} qui liste tous les fichiers dans un répertoire.
Nous voulons choisir uniquement ceux dont l'extension de fichier est
\ct{.html}. L'\expreg dont nous avons besoin est \ct{'.*\.html'}.
Le premier point \arelire{correspond à n'importe quel caractère excepté le
retour-chariot (désignant une nouvelle ligne):}
%The first dot will match any character except a newline:

\begin{code}{@TEST}
'x' matchesRegex: '.' --> true
' ' matchesRegex: '.'  --> true
Character cr asString matchesRegex: '.' --> false
\end{code}

%\index{Regex syntax!@\ct{*}}
\index{Regex!syntaxe!@\ct{*}}
Le caractère \ct{*} (connu sous le nom de ``\ind{\kleenestar}'' ou ``étoile de Kleene'',
%``\ind{Kleene star}''
\seeindex{étoile de Kleene}{\kleenestar}
d'après Stephen Kleene, son inventeur)
\arelire{définit une \expreg qui correspondra à la concordance de la
  précédente \expreg zéro ou plusieurs fois.}
est une \expreg qui correspond à
% is a regex operator that will match the preceding regex any number of times (including zero).

\mthindex{String}{matchesRegex:}
\begin{code}{@TEST}
'' matchesRegex: 'x*'     --> true
'x' matchesRegex: 'x*'   --> true
'xx' matchesRegex: 'x*' --> true
'y' matchesRegex: 'x*'   --> false
\end{code}

\index{Regex!syntaxe!@\ct{.}}
Puisque le point est un caractère spécial dans les \expregs, 
\arelire{nous devons le précéder d'un caractère d'échappement 
% ajout - vf
\lct{\symbol{92}} % backslash
si nous voulons avoir une concordance avec un vrai point dans la
chaîne de caractères.}
%if we want to literally match a dot, then we must escape it.

\begin{code}{@TEST}
'.' matchesRegex: '.'   --> true
'x' matchesRegex: '.'  --> true
'.' matchesRegex: '\.'  --> true
'x' matchesRegex: '\.' --> false
\end{code}

Vérifiez maintenant notre \expreg fonctionne pour trouver des fichiers
HTML.

\begin{code}{@TEST}
'index.html' matchesRegex: '.*\.html' --> true
'foo.html' matchesRegex: '.*\.html'    --> true
'style.css' matchesRegex: '.*\.html'   --> false
'index.htm' matchesRegex: '.*\.html' --> false
\end{code}

Cela semble bon! Nous pouvons l'essayer désormais dans notre application. 
%Looks good. Now let's try it out in our application.

\dothis{Ajouter la méthode suivante à la classe \ct{WebDir} et
  essayez-la dans votre site web de test.}

\begin{code}{}
WebDir>>htmlFiles
	^ webDir fileNames select: [ :each | each matchesRegex: '.*\.html' ]
\end{code}

Si vous envoyez le message \ct{htmlFiles} à une instance de
\ct{WebDir} et que vous l'imprimez via \menu{print it}, vous devriez
voir quelque chose de la sorte:

\begin{code}{}
(WebDir onPath: '...') htmlFiles --> #('index.html' ...)
\end{code}

%-----------------------------------------------------------------
\subsection{Mettre en cache l'\expreg}
%\subsection{Caching the regex}

Si vous naviguez de la méthode \mthind{String}{matchesRegex:}, vous
découvrirez que \arelire{c'est une extension de méthode de \ct{String}
  qui crée une nouvelle instance de \clsind{RxParser} à chaque envoi.}
C'est correct pour des requêtes \emph{ad hoc} mais si nous appliquons
la même \expreg pour chaque fichier du site web, créer une unique
instance de \ct{RxParser} pour la réutiliser est plus judicieux.
C'est ce que nous allons faire.
% you will discover that it is an extension method of \ct{String} that creates a fresh instance of \clsind{RxParser} every time it is sent.  That is fine for ad hoc queries, but if we are applying the same regex to every file in a web site, it is smarter to create just one instance of \ct{RxParser} and reuse it. Let's do that.

\dothis{Ajouter à la classe \ct{WebDir} une nouvelle variable
  d'instance \ct{htmlRegex} et initialisez-la en envoyant le message
  \ct{asRegex} à notre chaîne de caractères d'\expreg.
Modifiez la méthode \ct{WebDir>>htmlFiles} pour utiliser la même
\expreg tout le temps:}

\begin{code}{}
WebDir>>initialize
	htmlRegex := '.*\.html' asRegex

WebDir>>htmlFiles
	^ webDir fileNames select: [ :each | htmlRegex matches: each ]
\end{code}

Lister les fichiers HTML devrait fonctionner comme avant, à
l'exception de l'objet \emph{regex} que nous réutiliserons plusieurs
fois.

%-----------------------------------------------------------------
\subsection{Accéder aux pages web}

Accéder aux détails d'une page web seule devrait être la
responsabilité d'une classe distincte; définissons-la et faisons en
sorte que la classe \ct{WebDir} crée des instances de cette classe.

\dothis{Définissez une classe \ct{WebPage} avec les variables
  d'instance \ct{path} et \ct{homePath} pour identifier le fichier
  HTML et le répertoire racine du site respectivement (nous aurons
  besoin de générer les liens depuis le répertoire racine du site web jusqu'aux
  fichiers qu'il contient). Définissez une méthode d'initialisation
  côté instance et une méthode de création côté classe.}

% IMPORTANT: martial - dans la VO c'est #initializePath:homePath: , je
% préfère mettre comme dans le code source #setPath:homePath:
\begin{code}{}
WebPage>>setPath: filePath homePath: dirPath 
	path := filePath.
	homePath := dirPath

WebPage class>>on: filePath forHome: homePath
	^ self new setPath: filePath homePath: homePath
\end{code}

Une instance de \ct{WebDir} devrait être capable de retourner une
liste de toutes les pages web qu'elle contient.

\dothis{Ajouter la méthode suivante à \ct{WebDir} et inspectez la
  valeur de retour pour vérifier que ça fonctionne.}

\begin{code}{}
WebDir>>webPages
	^ self htmlFiles collect: 
		[ :each | WebPage 
			on: webDir pathName, '/', each
			forHome: homePath ]
\end{code}

Vous pouvez voir de la forme suivante:

\begin{code}{}
(WebDir onPath: '...') webPages --> an Array(a WebPage a WebPage ...)
\end{code}

%-----------------------------------------------------------------
\subsection{Substitutions de chaînes de caractères}
%String substitutions

Le précédent résultat ne nous informe pas beaucoup; utilisons une
\expreg pour récupérer le nom de fichier de chaque page web.
Pour ce faire, nous voulons extraire tous les caractères du chemin (ou
\emph{path name}) jusqu'au dernier répertoire. Sur le système de
fichiers Unix, les répertoires finissent par un \emph{slash} (\ct{/}),
donc nous avons besoin d'éliminer tout jusqu'au dernier \emph{slash}
dans le chemin.

La méthode d'extension de \ct{String}
\mthind{String}{copyWithRegex:matchesReplacedWith:} fait cela pour
nous:

\begin{code}{@TEST}
'hello' copyWithRegex: '[elo]+' matchesReplacedWith: 'i' --> 'hi'
\end{code}

\index{Regex!syntaxe!@\ct{+}}
Dans cette exemple, l'\expreg \ct{[elo]} \arelire{correspond à un caractère
pouvant être \ct{e}, \ct{l} or \ct{o}.} % CHANGE : ajout - vf : "à un"
                                % plutôt que "n'importe qu'"
% matches any of the characters \ct{e}, \ct{l} or \ct{o}.
L'opérateur \ct{+} est comme la \kleenestar, mis à part qu'il
correspond exactement à \emph{une} ou plusieurs instances de l'\expreg
qui le précéde. Il correspondera ici à la sous-chaîne \ct{'ello} qui
sera remplacé par la lettre \ct{i} pour générer une nouvelle chaîne de
caractères.
\index{Regex!syntaxe!@\ct{+}}

\dothis{Ajoutez la méthode suivante et vérifiez qu'elle fonctionne
  comme attendu.}

\begin{code}{}
WebPage>>fileName
	^ path copyWithRegex: '.*/' matchesReplacedWith: ''
\end{code}

Now you should see something like this on your test web site:

\begin{code}{}
(WebDir onPath: '...') webPages collect: [:each | each fileName ]
  --> #('index.html' ...)
\end{code}

%-----------------------------------------------------------------
\subsection{Extraire les \regexmatches}
%extracting regex matches

L'étape suivante est l'extraction de titre de chaque page HTML.

Tout d'abord, nous avons besoin de trouver une façon de récupérer le
contenu de chaque page. Vous allez voir que c'est simple.

\dothis{Ajoutez la méthode suivante et essayez-la.}

\mthindex{FileStream}{oldFileOrNoneNamed:}
\begin{code}{}
WebPage>>contents
	^ (FileStream oldFileOrNoneNamed: path) contents
\end{code}

En fait, vous pourriez avoir des problèmes si vos pages web
contiennent des caractères non-ascii. Dans ce cas, il serait plus sûr
d'écrire la méthode ainsi:

\clsindex{Latin1TextConverter}
\begin{code}{}
WebPage>>contents
	^ (FileStream oldFileOrNoneNamed: path)
		converter: Latin1TextConverter new;
		contents
\end{code}

Vous devriez maintenant pouvoir voir quelque chose semblable à ceci:

\begin{code}{}
(WebDir onPath: '...') webPages first contents --> '<head>
<title>Titre de la !\normcode{première}! page</title>
...
'
\end{code}

Passons à l'extraction du titre. Dans ce cas, nous chercherons le
texte situé \emph{entre} les balises HTML \ct{<title>} et \ct{</title>}. 

\index{Regex!syntaxe!@\ct{^}}
Nous avons besoin de trouver une manière d'extraire la \emph{partie}
d'une concordance dit aussi \ind{\regexmatch} d'une \expreg. Les
sous-expressions des \expregs sont délimitées par des parenthèses.
Considérons l'\expreg \ct{([CARETaeiou]+)([aeiou]+)}. 
Elle comprend deux sous-expressions; la première correspondera à une
séquence d'un ou plusieurs caractères qui n'est pas une voyelle et la
seconde correspondera à une ou plusieurs voyelles. \arelire{L'opérateur
\ct{CARET} au début de l'ensemble de caractères entre crochets
contredit cet ensemble \cad qu'il le transforme en l'ensemble
complémentaire~\footnote{NB: Dans \pharo,
  l'accent circonflexe (appelé aussi \emph{caret}) correspond aussi au
  mot-clé de \emph{retour} que nous écrivons \ct{^}. Pour éviter toute
  confusion, nous écrirons \ct{CARET} lorsque nous utiliserons
  l'accent circonflexe dans les expressions régulières pour les
  ensembles complémentaires mais vous devez vous souvenir que ces
  symboles sont en réalité les mêmes.}.}
  %  To avoid
  % confusion, we will write \ct{CARET} when we are using the caret
  % within regular expressions to negate sets of characters, but you
  % should not forget, they are actually the same thing.}}.

\arelire{Nous allons désormais essayer de faire correspondre l'\expreg
  à un \emph{préfixe}~\footnote{En anglais, \emph{prefix}.} de la chaîne de
caractères \ct{'pharo'} et extraire les sous-éléments de cette concordance:}
% Now we will try to match a \emph{prefix} of the string \ct{'pharo'}
% and extract the submatches:

\mthindex{RxMatcher}{matchesPrefix:}
\mthindex{RxMatcher}{subexpression:}
\begin{code}{| re |}
re := '([CARETaeiou]+)([aeiou]+)' asRegex.
re matchesPrefix: 'pharo' --> true
re subexpression: 1         --> 'pha'
re subexpression: 2         --> 'ph'
re subexpression: 3         --> 'a'
\end{code}

Après la concordance réussie entre une \expreg et une chaîne de
caractères, \arelire{vous pouvez toujours envoyer à cette concordance
  ou \emph{match} le message} \ct{subexpression: 1} pour extraire la
concordance entière.
Vous pouvez aussi envoyer \lct{subexpression: $n$} où $n-1$ est le
nombre de sous-expressions dans l'\expreg. L'\expreg ci-dessus a deux
sous-expressions, numérotées $2$ et $3$.

Nous utiliserons la même astuce pour extraire le titre dans un fichier
HTML.

\dothis{Définissez la méthode suivante:}

\mthindex{String}{asRegexIgnoringCase}
\begin{code}{}
WebPage>>title
	| re |
	re := '[\w\W]*<title>(.*)</title>' asRegexIgnoringCase.
	^ (re matchesPrefix: self contents)
		ifTrue: [ re subexpression: 2 ]
		ifFalse: [ '(', self fileName, ' -- sans titre)' ]
\end{code} % ajout vf - remplacement de 'untitled'
% \begin{code}{}
% WebPage>>title
% 	| re |
% 	re := '[\w\W]*<title>(.*)</title>' asRegexIgnoringCase.
% 	^ (re matchesPrefix: self contents)
% 		ifTrue: [ re subexpression: 2 ]
% 		ifFalse: [ '(', self fileName, ' -- untitled)' ]
% \end{code}

Deux cas subtils sont à prendre en compte ici.
Premièrement, le code HTML ne s'intéresse pas de savoir si les balises
sont en miniscule ou en majuscule donc nous devons faire en sorte que
notre \expreg soit insensible à la casse en l'instanciant avec le
message \ct{asRegexIgnoringCase}.

Deuxièmement, puisque le point correspond à n'importe quel caractère \arelire{%
\emph{à l'exception des retours-chariot}}, l'\expreg 
%\emph{except a newline}
\mbox{\lct{.*<title>(.*)</title>}} ne fonctionnera comme prévu que si
plusieurs lignes apparaissent avant le titre.
L'\expreg \ct{\w} correspond à \arevoir{n'importe quel caractère alpha-numérique} 
%matches any alphanumeric,
et \ct{\W} correspond à \arevoir{n'importe quel caractère non
  alpha-numérique}; \ct{[\w\W]} correspond donc à \arevoir{n'importe
  quel caractère \emph{incluant le retour-chariot}} (Si nous nous
  attendons à ce que les titres contiennent des
  \arelire{retours-chariot}, nous devriez utiliser la même technique
  dans la sous-expression).

Nous pouvons tester maintenant notre extracteur de titre et nous
devrions obtenir quelque chose comme ça:

\begin{code}{}
(WebDir onPath: '...') webPages first title --> 'Pharo By Example -- Home Page'
\end{code}
% \begin{code}{}
% (WebDir onPath: '...') webPages first title --> 'Home page'
% \end{code}

%-----------------------------------------------------------------
\subsection{Plus de substitutions de chaînes de caractères}
%\subsection{More string substitutions}

Pour générer notre \sitemap, nous aurons besoin de générer les liens
vers chaque page.
Nous pouvons utiliser le titre de la page comme nom de lien. Nous
aurons besoin simplement de générer le chemin correct vers la page web
depuis la racine du site web.
Par chance, c'est trivial\,---\,c'est tout simplement le chemin
complet de la page web moins le chemin complet vers le répertoire
racine du site web.

Nous devons tout de même faire attention à une chose. Comme la
variable \ct{homePath} ne se termine pas par un \ct{/}, nous devrons
veuiller à l'ajouter, sinon le chemin relatif des liens commencera par
un \ct{/}.
Notez la différence entre les deux résultats suivants:

\mthindex{String}{copyWithRegex:matchesReplacedWith:}
\begin{code}{}
'/home/testweb/index.html' copyWithRegex: '/home/testweb' matchesReplacedWith: '' --> '/index.html'
'/home/testweb/index.html' copyWithRegex: '/home/testweb/' matchesReplacedWith: '' -->  'index.html'
\end{code}

Le premier résultat nous donne un chemin absolu; ce n'est pas ce que
nous voulons.

\dothis{Définissez les méthodes suivantes:}

\begin{code}{}
WebPage>>relativePath
	^ path 
		copyWithRegex: homePath , '/'
		matchesReplacedWith: ''

WebPage>>link
	^ '<a href="', self relativePath, '">', self title, '</a>'
\end{code}

Testez donc le code suivant pour voir votre premier lien:
% CHANGE - vf - martial : trop de 'you should now be able ...' 
%You should now be able to see something like this:

% \begin{code}{}
% (WebDir onPath: '...') webPages first link --> '<a href="index.html">Home Page</a>'
% \end{code}
\begin{code}{}
(WebDir onPath: '...') webPages first link --> '<a href="index.html">Pharo By Example -- Home Page</a>'
\end{code}

%-----------------------------------------------------------------
\subsection{Générer le \sitemap}

Voilà! Nous en avons fini avec les \expregs pour ce qui concerne notre
exemple de générateur de \sitemap.
% Actually, we are now done with the regular expressions we need to
% generate the site map.
Nous aurons besoin de quelques méthodes pour compléter l'application.

\dothis{Si vous voulez voir la génération du \sitemap, ajoutez
  simplement les méthodes suivantes.}

Si votre site web contient des sous-répertoires, nous avons besoin
d'une méthode pour y accéder:
\begin{code}{}
WebDir>>webDirs
	^ webDir directoryNames
		collect: [ :each | WebDir onPath: webDir pathName , '/' , each home: homePath ]
\end{code}

Nous avons besoin aussi de générer la liste à puces contenant les
liens vers chaque page web d'un répertoire web.
\arevoir{Les sous-répertoires devraient être indentés dans leur propre liste à puces.}
% Subdirectories should be indented in their own bullet list.
\begin{code}{}
WebDir>>printTocOn: aStream 
	self htmlFiles
		ifNotEmpty: [
			aStream nextPutAll: '<ul>'; cr.
			self webPages
				do: [:each | aStream nextPutAll: '<li>';
						 nextPutAll: each link;
						 nextPutAll: '</li>'; cr].
			self webDirs
				do: [:each | each printTocOn: aStream].
			aStream nextPutAll: '</ul>'; cr]
\end{code}

Nous créons un fichier appelé ``toc.html''\footnote{\arelire{NdT: ``toc'' est
  l'abrégé de \emph{Table Of Contents} \cad ``table des matières''.}}
dans le répertoire racine du site web et nous y déposerons notre
\sitemap.
% We create a file called ``toc.html'' in the root web directory and dump the site map there.
\begin{code}{}
WebDir>>tocFileName
	^ 'toc.html'

WebDir>>makeToc
	| tocStream |
	tocStream := webDir newFileNamed: self tocFileName.
	self printTocOn: tocStream.
	tocStream close.
\end{code}

Générons maintenant une table des matières pour un répertoire web de
votre choix!
\begin{code}{}
WebDir selectHome makeToc
\end{code}

\begin{figure}[tbh]
\begin{center}
\includegraphics[width=\textwidth]{PBE-toc}
\caption{Un mini-\sitemap.}
\figlabel{PBE-toc}
\end{center}
\end{figure}

%=================================================================
\sectionindex{La syntaxe des \expregs}
%\section{Regex syntax}\indexmain{Regex syntax}

Nous allons voir plus en détails la syntaxe des \expreg telle qu'elle
est supportée par le paquetage \pkgregex.

L'\expreg la plus simple est un caractère unique. Elle correspond
exactement à ce caractère. Une séquence de caractères correspond à une
chaîne de caractères ayant exactement la même séquence de caractères:
\mthindex{String}{matchesRegex:}
\begin{code}{@TEST}
'a' matchesRegex: 'a'                  --> true
'foobar' matchesRegex: 'foobar'  --> true
'blorple' matchesRegex: 'foobar' --> false
\end{code}

Les opérateurs sont appliqués aux \expregs pour produire des \expregs
plus complexes.
\aretirer{Le séquençage (\cad l'ordonnancement des expressions les unes à la
  suite des autres) est, en un sens, ``invisible'' en ce qui concerne
  les opérateurs\,---\,quoique c'est le plus commun.} % REVOIR CHANGE
%  Sequencing (placing expressions one
% after another) as an operator is, in a certain sense,
% ``invisible''\,---\,yet it is arguably the most common.

\indexmain{Regex!syntaxe!@\ct{*}}
Nous avons déjà vu l'\ind{\kleenestar} (\ct{*}) et l'opérateur \ct{+}.
Une \expreg suivie par une \kleenestar correspond à un certain nombre
(incluant $0$) de concordances de l'expression originale. Par exemple:
\begin{code}{@TEST}
'ab' matchesRegex: 'a*b'         --> true
'aaaaab' matchesRegex: 'a*b' --> true
'b' matchesRegex: 'a*b'           --> true
'aac' matchesRegex: 'a*b'	    --> false    "b ne correspond pas"
\end{code}

\index{Regex!priorité des opérateurs}
%\index{Regex!operator precedence}
La \kleenestar a une plus grand priorité que le séquençage. Une
\kleenestar s'applique à la sous-expression la plus 
\arevoir{courte possible qui la précède}.
%shortest possible subexpression that precedes it.
Par exemple, \ct{ab*} signifie \ct{a} suivi par zéro ou plusieurs
occurences de \ct{b} et non, ``zéro ou plusieurs fois \ct{ab}'':
occurrences of \ct{ab}'':
\begin{code}{@TEST}
'abbb' matchesRegex: 'ab*' --> true
'abab' matchesRegex: 'ab*' --> false
\end{code}

\indexmain{Regex!syntaxe!@\ct{()}}
Pour obtenir une \expreg qui correspond à ``zéro ou plusieurs
occurences de \ct{ab}'', nous devons inclure \ct{ab} entre
parenthèses:
\begin{code}{@TEST}
'abab' matchesRegex: '(ab)*'   --> true
'abcab' matchesRegex: '(ab)*' --> false    "c joue les !trouble-fête!"
\end{code} % vf - note: trouble-fête au pluriel, c'est exact!

\indexmain{Regex!syntaxe!@\ct{+}}
\indexmain{Regex!syntaxe!@\ct{?}}
Deux autres opérateurs bien utiles, semblables à \ct{*}, sont \ct{+}
et \ct{?}. \ct{+} correspond à une ou plusieurs instances de l'\expreg
qu'il modifie. \ct{?} assurera la concordance avec zéro ou une
instance.
% ajout - vf - CHANGE
C'est trois opérateurs sont appelés \emph{quantificateurs}.
\begin{code}{@TEST}
'ac' matchesRegex: 'ab*c'	   --> true
'ac' matchesRegex: 'ab+c'	  --> false    "besoin d'au moins un b"
'abbc' matchesRegex: 'ab+c' --> true
'abbc' matchesRegex: 'ab?c' --> false    "trop de b"
\end{code}

\indexmain{Regex!syntaxe!\escchar}
Comme nous avons vu, les caractères \ct{*}, \ct{+}, \ct{?}, \ct{(},
and \ct{)} ont un sens spécial dans les \expregs. Si nous avons besoin
de faire correspondre n'importe lequel d'entre eux de manière
littérale, il faudrait l'\emph{échapper} en précédant ce caractère par
un \escchar \cad un \emph{antislash} (\ct{\}). L'\emph{antislash} est
  aussi un caractère spécial et a donc besoin d'être précédé par
  \escchar pour qu'il y ait concordance. Ceci est aussi valable pour
  tous les caractères spéciaux que nous pourrions voir plus loin.
\begin{code}{@TEST}
'ab*' matchesRegex: 'ab*'  --> false    "l'!astérisque! est !spécial!"
'ab*' matchesRegex: 'ab\*' --> true
'a\c' matchesRegex: 'a\\c'  --> true
\end{code}

\indexmain{Regex!syntaxe!@\ct{|}}
Le dernier opérateur est \ct{|}; il exprime un choix entre deux
sous-expressions. Il correspond à un chaîne de caractères si l'un des
deux expressions concordent. Cet opérateur à la priorité la plus
basse\,---\,inférieure même au séquençage.
%It has the lowest precedence\,---\,even lower than sequencing.
Par exemple, \ct{ab*|ba*} signifie ``a suivi par un certain nombre de
b \emph{ou} b suivi par un certain nombre de a'':
\begin{code}{@TEST}
'abb' matchesRegex: 'ab*|ba*'   --> true
'baa' matchesRegex: 'ab*|ba*'	--> true
'baab' matchesRegex: 'ab*|ba*' --> false
\end{code}

Voici un exemple un peu plus compliqué. L'expression \ct{c(a|d)+r}
correspond au nom de n'importe quelle fonction
historique\footnote{NdT: voir \url{http://fr.wikipedia.org/wiki/Lisp}.} du langage de programmation Lisp: 
 \ct{car}, \ct{cdr}, \ct{caar}, \ct{cadr}\ldots:
\begin{code}{@TEST}
'car' matchesRegex: 'c(a|d)+r'   --> true
'cdr' matchesRegex: 'c(a|d)+r'   --> true
'cadr' matchesRegex: 'c(a|d)+r' --> true
\end{code} % CHANGE - martial - note de bas de page sur Lisp

Il est possible d'écrire une expression qui correspond à une chaîne
vide; par exemple, l'\expreg \ct{a|} correspond à une chaîne vide.
Cependant, appliquer  \ct{*}, \ct{+} ou \ct{?} tel quel est une
erreur: \ct{(a|)*}, par contre, est valide.

%\indexmain{Regex!syntaxe!character set}
\indexmain{Regex!syntaxe!classe de caractères}
Nous n'avons utilisé que des caractères comme \emph{plus petits}
composants des \expregs.
% So far, we have used only characters as the \emph{smallest}
% components of regular expressions.
Il y a d'autres composants plus intéressants encore. Une \emph{classe
de caractères} est une chaîne de caractères entre crochets: il
correspond à un simple caractère s'il apparaît entre les crochets. Par
exemple, \ct{[01]} correspond à \ct{0} ou \ct{1}:
\begin{code}{@TEST}
'0' matchesRegex: '[01]'   --> true
'3' matchesRegex: '[01]'   --> false
'11' matchesRegex: '[01]' --> false  "une classe correspond !à! un !caractère! seulement"
\end{code}

En utilisant l'opérateur \ct{+}, nous pouvons construire un outil de
reconnaissance de nombre binaire:
\begin{code}{@TEST}
'10010100' matchesRegex: '[01]+' --> true
'10001210' matchesRegex: '[01]+' --> false
\end{code}

Si le premier caractère après le crochet ouvrant est \ct{CARET},
la classe de caractères est inversé: la concordance se fait donc sur
un caractère qui \emph{n'est pas} entre les crochets:
% the set is inverted: it matches any single character \emph{not} appearing between the brackets:
\begin{code}{@TEST}
'0' matchesRegex: '[CARET01]' --> false
'3' matchesRegex: '[CARET01]' --> true
\end{code}

%\indexmain{Regex!syntaxe!character range}
\indexmain{Regex!syntaxe!intervalle de classe}
Pour des raisons de commodité, une classe de caractères peut inclure
des intervalles: deux caractères séparés par un tiret (\ct{-})
% separated by a hyphen (\ct{-}).
forment ce que nous appelons intervalle de classe.
Cet intervalle est équivalent à la liste complète de tous les
caractères entre ces deux caractères:  \ct{'[0-9]'} est la même chose
que  \ct{'[0123456789]'}.
Les caractères spéciaux dans une classe de caractères sont 
\ct{CARET}, \ct{-}, and \ct{]}; ce dernier clôt la classe. 
Ci-dessous, nous avons \arelire{des exemples montrant comment les
  utiliser dans une classe pour en faire la concordance}:
% which closes the set. Below are examples how to literally match them
% in a set:
\begin{code}{@TEST}
'CARET' matchesRegex: '[01CARET]'   --> true    "mettre l'accent partout sauf au !début!"
'-' matchesRegex: '[01-]' --> true    "mettre le tiret !à! la fin"
']' matchesRegex: '[]01]'   --> true    "mettre le crochet fermant au
!début!"
\end{code}

\arevoir{Les classes vides et universelles ne peuvent pas être
  définies.} 
% Thus, empty and universal sets cannot be specified.

%-----------------------------------------------------------------
\subsection{Les classes de caractères}
%\subsection{Character classes}
Les \expregs{} peuvent aussi inclure les 
Regular expressions can also include the following backquote escapes to refer to popular classes of characters: \ct{\w} to match alphanumeric characters, \ct{\d} to match digits, and \ct{\s} to match whitespace.
Their upper-case variants, \ct{\W}, \ct{\D} and \ct{\S}, match the complementary characters (non-alphanumerics, non-digits and non-whitespace).
We can see a summary of the syntax seen so far in \tabref{regexsyntax}.

\indexmain{Regex syntax}
\begin{table}
\centering
	\begin{tabular}{ll}
		\toprule
		Syntax & What it represents \\
		\midrule
		\lct{a}				&	literal match of character \lct{a} \\
		\lct{.}				&	match any char (except newline) \\
		\lct{($\cdots$)}		&	group subexpression \\
		\lct{{\escape}}	&	escape following special character \\
		\midrule
		\lct{*}				&	\kleenestar\,---\,match previous regex zero or more times \\
		\lct{+}				&	match previous regex one or more times \\
		\lct{?}				&	match previous regex zero times or once \\
		\lct{|}				&	match choice of left and right regex \\
		\midrule
		\lct{[abcd]}		&	match choice of characters \lct{abcd} \\
		\lct{[{\caret}abcd]}	&	match negated choice of characters \\
		\lct{[0-9]}		&	match range of characters \lct{0} to \lct{9} \\
		\midrule
		\lct{{\escape}w}			&	match alphanumeric \\
		\lct{{\escape}W}			&	match non-alphanumeric \\
		\lct{{\escape}d}			&	match digit \\
		\lct{{\escape}D}			&	match non-digit \\
		\lct{{\escape}s}			&	match space \\
		\lct{{\escape}S}			&	match non-space \\
		\bottomrule
	\end{tabular}
	\caption{Regex Syntax in a Nutshell\tablabel{regexsyntax}}
\end{table}


As mentioned in the introduction, regular expressions are especially useful for validating user input, and character classes turn out to be especially useful for defining such regexes.
For example, non-negative numbers can be matched with the regex \ct{\d+}:

\begin{code}{@TEST}
'42' matchesRegex: '\d+' --> true
'-1' matchesRegex: '\d+' --> false
\end{code}

Better yet, we might want to specify that non-zero numbers should not start with the digit 0:

\begin{code}{@TEST}
'0' matchesRegex: '0|([1-9]\d*)'     --> true
'1' matchesRegex: '0|([1-9]\d*)'     --> true
'42' matchesRegex: '0|([1-9]\d*)'   --> true
'099' matchesRegex: '0|([1-9]\d*)' --> false    "leading 0"
\end{code}

We can check for negative and positive numbers as well:

\begin{code}{@TEST}
'0' matchesRegex: '(0|((\+|-)?[1-9]\d*))'     --> true
'-1' matchesRegex: '(0|((\+|-)?[1-9]\d*))'   --> true
'42' matchesRegex: '(0|((\+|-)?[1-9]\d*))'   --> true
'+99' matchesRegex: '(0|((\+|-)?[1-9]\d*))' --> true
'-0' matchesRegex: '(0|((\+|-)?[1-9]\d*))'   --> false    "negative zero"
'01' matchesRegex: '(0|((\+|-)?[1-9]\d*))'   --> false    "leading zero"
\end{code}

Floating point numbers should require at least one digit after the dot:

\begin{code}{@TEST}
'0' matchesRegex: '(0|((\+|-)?[1-9]\d*))(\.\d+)?'      --> true
'0.9' matchesRegex: '(0|((\+|-)?[1-9]\d*))(\.\d+)?'   --> true
'3.14' matchesRegex: '(0|((\+|-)?[1-9]\d*))(\.\d+)?' --> true
'-42' matchesRegex: '(0|((\+|-)?[1-9]\d*))(\.\d+)?'  --> true
'2.' matchesRegex: '(0|((\+|-)?[1-9]\d*))(\.\d+)?'     --> false    "need digits after ."
\end{code}

%Checking if aString is a fixed-point number, with at least one digit is required after a dot:
%\begin{code}{}
%'' matchesRegex: '(\+|-)?\d+(\.\d+)?'
%The same, but allow notation like '123.':
%'' matchesRegex: '(\+|-)?\d+(\.\d*)?'
%\end{code}
%Recognizer for a string that might be a name: one word with first capital letter, no blanks, no digits.  More traditional:
%\begin{code}{}
%'' matchesRegex: '[A-Z][A-Za-z]*'
%more Smalltalkish:
%'' matchesRegex: ':isUppercase::isAlphabetic:*'
%\end{code}
%A date in format MMM DD, YYYY with any number of spaces in between, in XX century:
%\begin{code}{}
%'' matchesRegex: '(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[ ]+(\d\d?)[ ]*,[ ]*19(\d\d)'
%\end{code}
%Note parentheses around some components of the expression above. As the Usage Section shows, they will allow us to obtain the actual strings that have matched them (\ie month name, day number, and year number).

For dessert, here is a recognizer for a general number format: anything like \ct{999}, or \ct{999.999}, or \ct{-999.999e+21}.
\begin{code}{@TEST}
'-999.999e+21' matchesRegex: '(\+|-)?\d+(\.\d*)?((e|E)(\+|-)?\d+)?' --> true
\end{code}

Character classes can also include the grep(1)-compatible elements listed in \tabref{charclasses}.

\indexmain{Regex syntax!character classes}
\begin{table}[htb]
\centering
	\begin{tabular}{lp{8cm}}
		\toprule
		Syntax & What it represents \\
		\midrule
\lct{[:alnum:]} & any alphanumeric \\
\lct{[:alpha:]} & any alphabetic character\\
\lct{[:cntrl:]} & any control character (ascii code is \lct{< 32})\\
\lct{[:digit:]} & any decimal digit\\
\lct{[:graph:]} & any graphical character (ascii code \lct{>= 32})\\
\lct{[:lower:]} & any lowercase character\\
\lct{[:print:]} & any printable character (here, the same as \lct{[:graph:]})\\
\lct{[:punct:]} & any punctuation character\\
\lct{[:space:]} & any whitespace character\\
\lct{[:upper:]} & any uppercase character\\
\lct{[:xdigit:]} & any hexadecimal character \\
		\bottomrule
	\end{tabular}
	\caption{Regex character classes\tablabel{charclasses}}
\end{table}

Note that these elements are components of the character classes, \ie they have to be enclosed in an extra set of square brackets to form a valid regular expression.  For example, a non-empty string of digits would be represented as \ct{[[:digit:]]+}. The above primitive expressions and operators are common to many implementations of regular expressions.

\begin{code}{@TEST}
'42' matchesRegex: '[[:digit:]]+' --> true
\end{code}

%-----------------------------------------------------------------
\subsection{Les classes de caractères spéciales}
%\subsection{Special character classes}
The next primitive expression is unique to this Smalltalk implementation. A sequence of characters between colons is treated as a unary selector which is supposed to be understood by characters. A character matches such an expression if it answers true to a message with that selector. This allows a more readable and efficient way of specifying character classes. For example, \ct{[0-9]} is equivalent to \ct{:isDigit:}, but the latter is more efficient. Analogously to character sets, character classes can be negated: \ct{:CARETisDigit:} matches a character that answers \ct{false} to \ct{isDigit}, and is therefore equivalent to \ct{[CARET0-9]}.

So far we have seen the following equivalent ways to write a regular expression that matches a non-empty string of digits: \ct{[0-9]+}, \ct{\d+}, \ct{[\d]+}, \ct{[[:digit:]]+}, \ct{:isDigit:+}.

\begin{code}{@TEST}
'42' matchesRegex: '[0-9]+'      --> true
'42' matchesRegex: '\d+'           --> true
'42' matchesRegex: '[\d]+'         --> true
'42' matchesRegex: '[[:digit:]]+' --> true
'42' matchesRegex: ':isDigit:+'  --> true
\end{code}

%-----------------------------------------------------------------
%\subsection{Matching boundaries}
\subsection{Filtrage aux extrêmités}
Le dernier groupe de primitives spéciales est visible dans
\tabref{boundaries} et est utilisé pour faire le filtrage aux
extrêmités des chaînes de caractères.

\indexmain{Regex syntax!matching string boundaries}
\begin{table}[htb]
\centering
	\begin{tabular}{lp{8cm}}
		\toprule
		Syntax & What it represents \\
		\midrule
		\lct{\caret} & match an empty string at the beginning of a line\\
		\lct{\$} & match an empty string at the end of a line\\
		\lct{{\escape}b} & match an empty string at a word boundary\\
		\lct{{\escape}B} & match an empty string not at a word boundary\\
		\lct{{\escape}<} & match an empty string at the beginning of a word\\
		\lct{{\escape}>} & match an empty string at the end of a word\\
		\bottomrule
	\end{tabular}
	\caption{Primitives to match string boundaries\tablabel{boundaries}}
\end{table}

\begin{code}{@TEST}
'hello world' matchesRegex: '.*\bw.*' --> true      "word boundary before w"
'hello world' matchesRegex: '.*\bo.*'  --> false    "no boundary before o"
\end{code}

%=================================================================
\section{L'API \pkgregex}

Up to now we have focussed mainly on the syntax of regexes.  Now we will have a closer look at the different messages understood by strings and regexes.

%-----------------------------------------------------------------
%\subsection{Matching prefixes and ignoring case}
\subsection{Concordance des préfixes hors-casse}

So far most of our examples have used the \ct{String} extension method \ct{matchesRegex:}.

Strings also understand the following messages:
\mthind{String}{prefixMatchesRegex:}, \mthind{String}{matchesRegexIgnoringCase:} and
\mthind{String}{prefixMatchesRegexIgnoringCase:}.

The message \mthind{String}{prefixMatchesRegex:} is just like \mthind{String}{matchesRegex}, except that the whole receiver is not expected to match the regular expression passed as the argument; matching just a prefix of it is enough.
\begin{code}{@TEST}
'abacus' matchesRegex: '(a|b)+'                                --> false
'abacus' prefixMatchesRegex: '(a|b)+'                       --> true
'ABBA' matchesRegexIgnoringCase: '(a|b)+'            --> true
'Abacus' matchesRegexIgnoringCase: '(a|b)+'          --> false
'Abacus' prefixMatchesRegexIgnoringCase: '(a|b)+' --> true
\end{code}

%-----------------------------------------------------------------
%\subsection{Enumeration interface}
\subsection{Protocole d'énumération}

Some applications need to access \emph{all} matches of a certain regular expression within a string.  The matches are accessible using a protocol modeled after the familiar \ct{Collection}-like enumeration protocol.

\mthind{String}{regex:matchesDo:} evaluates a one-argument \ct{aBlock} for every match of the regular expression within the receiver string.

\begin{code}{@TEST | list |}
list := OrderedCollection new.
'Jack meet Jill' regex: '\w+' matchesDo: [:word | list add: word].
list --> an OrderedCollection('Jack' 'meet' 'Jill')
\end{code}

\mthind{String}{regex:matchesCollect:} evaluates a one-argument \ct{aBlock} for every match of the regular expression within the receiver string. It then collects the results and answers them as a \clsind{SequenceableCollection}.

\begin{code}{@TEST}
'Jack meet Jill' regex: '\w+' matchesCollect: [:word | word size]                          --> an OrderedCollection(4 4 4)
\end{code}

\mthind{String}{allRegexMatches:} returns a collection of all matches (substrings of the receiver string) of the regular expression.

\begin{code}{@TEST}
'Jack and Jill went up the hill' allRegexMatches: '\w+'                                            --> an OrderedCollection('Jack' 'and' 'Jill' 'went' 'up' 'the' 'hill')
\end{code}

%-----------------------------------------------------------------
\subsection{Remplacement et traduction}
% translation

It is possible to replace all matches of a regular expression with a certain string using the message \mthind{String}{copyWithRegex:matchesReplacedWith:}.

\begin{code}{@TEST}
'Krazy hates Ignatz' copyWithRegex: '\<[[:lower:]]+\>' matchesReplacedWith: 'loves' --> 'Krazy loves Ignatz'
\end{code}

A more general substitution is match translation. This message evaluates a block passing it each match of the regular expression in the receiver string and answers a copy of the receiver with the block results spliced into it in place of the respective matches.

\begin{code}{@TEST}
'Krazy loves Ignatz' copyWithRegex: '\b[a-z]+\b' matchesTranslatedUsing: [:each | each asUppercase] --> 'Krazy LOVES Ignatz'
\end{code}

All messages of enumeration and replacement protocols perform a case-sensitive match.  Case-insensitive versions are not provided as part of a \ct{String} protocol.  Instead, they are accessible using the lower-level matching interface presented in the following question.
%-----------------------------------------------------------------
%\subsection{Lower-level interface}
\subsection{Interface bas niveau}

When you send the message \mthind{String}{matchesRegex:} to a string, the following happens:

\begin{enumerate}
\item A fresh instance of \clsind{RxParser} is created, and the regular expression string is passed to it, yielding the expression's syntax tree.
\item  The syntax tree is passed as an initialization parameter to an instance of \clsind{RxMatcher}. The instance sets up some data structure that will work as a recognizer for the regular expression described by the tree.
\item The original string is passed to the matcher, and the matcher checks for a match.
\end{enumerate}

%-----------------------------------------------------------------
%\subsection{The Matcher}
\subsection{La classe \ct{RxMatcher}}

If you repeatedly match a number of strings against the same regular expression using one of the messages defined in \clsind{String}, the regular expression string is parsed and a new matcher is created for every match.  You can avoid this overhead by building a matcher for the regular expression, and then reusing the matcher over and over again. You can, for example, create a matcher at a class or instance initialization stage, and store it in a variable for future use.
You can create a matcher using one of the following methods:

\begin{itemize}
\item You can send \mthind{String}{asRegex} or \mthind{String}{asRegexIgnoringCase} to the string.

\item You can directly invoke the \ct{RxMatcher} constructor methods \mthind{RxMatcher}{forString:} or \mthind{RxMatcher}{forString:ignoreCase:} (which is what the convenience methods above will do).
%
%The \mthind{RxMatcher}{forString:} method is equivalent to \mthind{RxMatcher class}{forString: regexString ignoreCase: false}. A more convenient way is using one of the two matcher-created messages understood by \clsind{String}. 	 \cmind{RxMatcher}{regexString asRegex} is equivalent to \mthind{RxMatcher class}{forString: regexString}. 	 \ct{regexString asRegexIgnoringCase} is equivalent to \cmind{RxMatcher class}{forString: regexString ignoreCase: true}.

%\item Sending a \mthind{RxMatcher class}{forString:ignoreCase:} message to \clsind{RxMatcher} class, with the regular expression string and a Boolean indicating whether case is ignored as arguments.
\end{itemize}

Here we send \mthind{RxMatcher}{matchesIn:} to collect all the matches found in a string:

\begin{code}{@TEST | octal hex |}
octal := '8r[0-9A-F]+' asRegex.
octal matchesIn: '8r52 = 16r2A' --> an OrderedCollection('8r52')

hex := '16r[0-9A-F]+' asRegexIgnoringCase.
hex matchesIn: '8r52 = 16r2A'   --> an OrderedCollection('16r2A')

hex := RxMatcher forString: '16r[0-9A-Fa-f]+' ignoreCase: true.
hex matchesIn: '8r52 = 16r2A'   --> an OrderedCollection('16r2A')
\end{code}

%-----------------------------------------------------------------
%\subsection{Matching}
\subsection{La concordance}

Un \emph{matcher} (ou concordeur) comprend ces messages\,---\,tous
retournant \ct{true} ou \ct{false} pour indiquer le succès ou l'échec
d'une concordance ou d'une recherche:

\mthind{RxMatcher}{matches:} -- true if the whole argument string (aString) matches.

\begin{code}{@TEST}
'\w+' asRegex matches: 'Krazy' --> true
\end{code}

\mthind{RxMatcher}{matchesPrefix:} -- true if some prefix of the argument string (not necessarily the whole string) matches.

\begin{code}{@TEST}
'\w+' asRegex matchesPrefix: 'Ignatz hates Krazy' --> true
\end{code}

\mthind{RxMatcher}{search:} \ct{aString} -- Search the string for the first occurrence of a matching substring. (Note that the first two methods only try matching from  the very beginning of the string). Using the above example with a  matcher for \ct{a+}, this method would answer success given a string \ct{'baaa'}, while the previous two would fail.

\begin{code}{@TEST}
'\b[a-z]+\b' asRegex search: 'Ignatz hates Krazy' --> true    "finds 'hates'"
\end{code}


The matcher also stores the outcome of the last match attempt and can report it: \mthind{RxMatcher}{lastResult} answers a Boolean: the outcome of the most recent match attempt. If no matches were attempted, the answer is unspecified.

\begin{code}{@TEST | number |}
number := '\d+' asRegex.
number search: 'Ignatz throws 5 bricks'.
number lastResult --> true
\end{code}

\mthind{RxMatcher}{matchesStream:}, \mthind{RxMatcher}{matchesStreamPrefix:} and \mthind{RxMatcher}{searchStream:} are analogous to the above three messages, but takes streams as their argument.

\begin{code}{@TEST | ignatz |}
ignatz := ReadStream on: 'Ignatz throws bricks at Krazy'.
names := '\<[A-Z][a-z]+\>' asRegex.
names matchesStreamPrefix: ignatz --> true
\end{code}

%-----------------------------------------------------------------
%\subsection{Subexpression matches}
\subsection{Les filtres de sous-expressions}

Suite à une tentative de concordance réussie, vous pouvez demander
quelle partie de la chaîne de caractères originale a correspondu à
quelle partie de l'\expreg. Une sous-expression est une partie
parenthésée d'une \expreg ou l'expression entière.
Lorsque une \expreg est compilée, ses sous-expressions sont affectés à
des \arevoir{indices comptant à partir de 1, par ordre de profondeur
  vers le plus profond, et de gauche à droite}. 
%When a regular expression is compiled, its subexpressions are assigned indices starting from 1, depth-first, left-to-right.

\index{Regex!subexpression matches}
Par exemple, l'\expreg \ct{((\d+)\s*(\w+))} a quatre sous-expressions
incluant l'expression entière elle-même.
\begin{code}{}
1:    ((\d+)\s*(\w+))    "l'expression !\normcode{entière}!"
2:    (\d+)\s*(\w+)       "la sous-expression !\normcode{supérieure}!"
3:    \d+                      "la !\normcode{première}! branche"
4:    \w+                     "la seconde branche"
\end{code}

L'indice valide le plus élevé est égale à 1 plus le nombre de
parenthèses de filtres (ainsi, 1 est toujours un indice valide même
s'il n'y a pas de sous-expressions parenthésées).
%The highest valid index is equal to 1 plus the number of matching parentheses.  (So, 1 is always a valid index, even if there are no parenthesized subexpressions.)

After a successful match, the matcher can report what part of the original string matched what subexpression. It understandards these messages:

\mthind{RxMatcher}{subexpressionCount} answers the total number of subexpressions: the highest value that can be used as a subexpression index with this matcher. This value 	is available immediately after initialization and never changes.

\mthind{RxMatcher}{subexpression:} takes a valid index as its argument, and may be sent only after a successful match attempt. The method answers a substring of the original string the corresponding subexpression has matched to.

\mthind{RxMatcher}{subBeginning:} and \mthind{RxMatcher}{subEnd:} answer the positions within the argument string or stream where the given subexpression match has started and ended, respectively. 
% This facility provides a convenient way of extracting parts of input strings of complex format.

\begin{code}{@TEST | items |}
items := '((\d+)\s*(\w+))' asRegex.
items search: 'Ignatz throws 1 brick at Krazy'.
items subexpressionCount --> 4
items subexpression: 1      --> '1 brick'    "complete expression"
items subexpression: 2      --> '1 brick'    "top subexpression"
items subexpression: 3      --> '1'             "first leaf subexpression"
items subexpression: 4      --> 'brick'       "second leaf subexpression"
items subBeginning: 3       --> 14
items subEnd: 3                 --> 15
items subBeginning: 4       --> 16
items subEnd: 4                 --> 21
\end{code}

As a more elaborate example, the following piece of code uses a \ct{MMM DD, YYYY} date format recognizer to convert a date to a three-element array with year, month, and day strings:

\begin{code}{@TEST | date result |}
date := '(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(\d\d?)\s*,\s*19(\d\d)' asRegex.
result := (date matches: 'Aug 6, 1996')
       ifTrue: [{ (date subexpression: 4) .
				(date subexpression: 2) .
				(date subexpression: 3) } ]
        ifFalse: ['no match'].
result --> #('96' 'Aug' '6')
\end{code}

%-----------------------------------------------------------------
%\subsection{Enumeration and Replacement}
\subsection{Énumération et remplacement}

Les protocoles de la classe \ct{String} pour l'énumeration
(\prot{enumeration}) et le remplacement que nous avons vus plus tôt
dans cette section sont en fait implémentés par le \emph{matcher}. 
\lct{RxMatcher} implémente les méthodes suivantes pour itérer dans les
concordances dans les chaînes de caractères:
%iterating over matches within strings:
\mthind{RxMatcher}{matchesIn:},
\mthind{RxMatcher}{matchesIn:do:},
\mthind{RxMatcher}{matchesIn:collect:},
\mthind{RxMatcher}{copy:replacingMatchesWith:} and
\mthind{RxMatcher}{copy:translatingMatchesUsing:}.

\begin{code}{@TEST | seuss aWords |}
seuss := 'The cat in the hat is back'.
aWords := '\<([^aeiou]|[a])+\>' asRegex.    "match words with 'a' in them"
aWords matchesIn: seuss
    --> an OrderedCollection('cat' 'hat' 'back')
aWords matchesIn: seuss collect: [:each | each asUppercase ]
    --> an OrderedCollection('CAT' 'HAT' 'BACK')
aWords copy: seuss replacingMatchesWith: 'grinch'
    --> 'The grinch in the grinch is grinch'
aWords copy: seuss translatingMatchesUsing: [ :each | each asUppercase ]
    --> 'The CAT in the HAT is BACK'
\end{code}

There are also the following methods for iterating over matches within streams:
\mthind{RxMatcher}{matchesOnStream:},
\mthind{RxMatcher}{matchesOnStream:do:},
\mthind{RxMatcher}{matchesOnStream:collect:},
\mthind{RxMatcher}{copyStream:to:replacingMatchesWith:} and
\mthind{RxMatcher}{copyStream:to:translatingMatchesUsing:}.

\begin{code}{@TEST | in out numMatch |}
in := ReadStream on: '12 drummers, 11 pipers, 10 lords, 9 ladies, etc.'.
out := WriteStream on: ''.
numMatch := '\<\d+\>' asRegex.
numMatch
  copyStream: in
  to: out
  translatingMatchesUsing: [:each | each asNumber asFloat asString ].
out close; contents --> '12.0 drummers, 11.0 pipers, 10.0 lords, 9.0 ladies, etc.'
\end{code}


%-----------------------------------------------------------------
%\subsection{Error Handling}
\subsection{Gestion des erreurs}

Several exceptions may be raised by \ct{RxParser} when building regexes.  The exceptions have the common parent \ct{RegexError}.  You may use the usual Smalltalk exception handling mechanism to catch and handle them.

\begin{itemize}

\item \clsind{RegexSyntaxError} is raised if a syntax error is detected while parsing a regex

\item \clsind{RegexCompilationError} is raised if an error is detected while building a matcher

\item \clsind{RegexMatchingError} is raised if an error occurs while matching (for example, if a bad selector was specified using \ct{':<selector>:'} syntax, or because of the matcher's internal error)

%\item If a syntax error is detected while parsing expression, \cmind{RxParser}{signalSyntaxException:} is raised/signaled;

%\item If an error is detected while building a matcher, \cmind{RxParser}{signalCompilationException:} is raised/signaled;

%\item If an error is detected while matching (for example, if a bad selector was specified using \ct{':<selector>:'} syntax, or because of the matcher's internal error), \cmind{RxParser}{signalMatchException:} is raised.
\end{itemize}

%The parent class of these three exception is \clsind{RegexError}. Since any of the three signals can be raised within a call to \mthind{matchesRegex:}, it is handy if you want to catch them all.  For example:

\begin{code}{@TEST}
['+' asRegex] on: RegexError do: [:ex | ^ ex printString ]                                        --> 'RegexSyntaxError:  nullable closure'
\end{code}
%=================================================================
\section{Les notes de programme de Vassili Bykov}
%Implementation Notes by Vassili Bykov
% Edited by ON

\index{Bykov, Vassili}
\paragraph{Où regarder pour commencer.}
In 90\% of the cases, the method \cmind{String}{matchesRegex:}  is all you need to access the package.

\clsind{RxParser} accepts a string or a stream of characters with a regular expression, and produces a syntax tree corresponding to the expression. The tree is made of instances of \clsind{Rxs*} classes.

\clsind{RxMatcher}  accepts a syntax tree of a regular expression built by the parser and compiles it into a matcher: a structure made of instances of \ct{Rxm*} classes. The \clsind{RxMatcher} instance can test whether a string or a positionable stream of characters matches the original regular expression, or it can search a string or a stream for substrings matching the expression. After a match is found, the matcher can report a specific string that matched the whole expression, or any parenthesized subexpression of it. All other classes support the same functionality and are used by \clsind{RxParser}, \clsind{RxMatcher}, or both.

\paragraph{Avertissement.} The matcher is similar in spirit, but \emph{not} in design
%--let alone the code--
to Henry Spencer's original regular expression implementation in C.  The focus is on simplicity, not on efficiency. I didn't optimize or profile anything.
%  I may in future\,---\,or I may not: I do this in my spare time and I don't promise anything. 
The matcher passes H. Spencer's test suite (see ``test suite'' protocol), with quite a few extra tests added, so chances are good there are not too many bugs.  But watch out anyway.

\paragraph{Remerciements.}
Since the first release of the matcher, thanks to the input from several fellow Smalltalkers, I became convinced a native Smalltalk regular expression matcher was worth the effort to keep it alive. For the advice and encouragement that made this release possible, I want to thank: Felix Hack, Eliot Miranda, Robb Shecter, David N. Smith, Francis Wolinski and anyone whom I haven't yet met or heard from, but who agrees this has not been a complete waste of time.
% (Coding the same ''the hard way'' is an exercise to a curious reader).

%=================================================================
\section{Résumé du chapitre}

Les \expregs sont un outil essentiel pour manipuler des chaînes de
caractères de façon relativement simple.
Ce chapitre présente le paquetage \pkgregex pour \pharo. Les points
principaux abordés dans ce chapitre sont:

\begin{itemize}
\item For simple matching, just send \ct{matchesRegex:} to a string
\item When performance matters, send \ct{asRegex} to the string representing the regex, and reuse the resulting matcher for multiple matches
\item Subexpression of a matching regex may be easily retrieved to an arbitrary depth
\item A matching regex can also replace or translate subexpressions in a new copy of the string matched
\item An enumeration interface is provided to access all matches of a certain regular expression
\item Regexes work with streams as well as with strings.
\end{itemize}


%=============================================================
\ifx\wholebook\relax\else
   \bibliographystyle{jurabib}
   \nobibliography{scg}
   \end{document}
\fi
%=============================================================


%-----------------------------------------------------------------
%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-master: t
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "english"
%%% End:
