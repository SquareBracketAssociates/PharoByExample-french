%%% Morphic.tex --- 
%% 
%% Filename: Morphic.tex
%% Description: Traduction de la page Morphic.tex de Squeak By Example
%% + copier coller de l'article originale + ajout du maintainer
%% Author: Andrew Black
%% Maintainer: Martial Boniou
%% Created: 2007-11-09 08:07:45 +0100 (Fri, 09 Nov 2007)
%% Version: 13642
%% Last-Updated: Mon Apr 18 22:18:18 2011 (+0200)
%%           By: Martial Boniou
%%     Update #: 859
%% URL:
%% https://www.iam.unibe.ch/scg/svn_repos/SqueakByExample/FrenchBook/Morphic/Morphic.tex
%% Review: Rene Mages - Fri Dec 21 22:18:36 2007 (3600 CET)
%% Review: Rene Mages - Sat Jan 12 18:55:44 2008 (3600 CET)
%% Adaptation pour PharoBook: Martial Boniou - Tue Nov 17 11:45:22 2009
%% Relecture pour PharoBook: Rene Mages - Mon Jan 18 11:45:22 2010
%% Relecture pour PharoBook: Rene Mages - Mon Aug  9 11:45:22 2010
%% Relecture pour PharoBook: Rene Mages - Sat Apr 16 11:45:22 2011
%% Sync avec la version: 33691
%% Keywords:
%% Compatibility: 
%% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 
%%% Commentary:
%%             - passage de premier paragraphe sur l'histoire de
%%             Morphic dans l'introduction 
%%             - changement de titre du premier chapitre 'premiere
%%             immersion...' +  ajouts de trois sous-sections pour
%%             aerer le document   
%%             - ajout dans la sous-section 'un monde de morphs' de
%%             deux paragraphes sur le caractere introspectif du
%%             Viewer + l'image du StringMorph qui pivote
%%             - ajout d'un tableau avec les commandes les plus
%%             communes des morphs
%%             - Dans le chapitre 'Interaction et animation', nous
%%             avons les sous-sections 'evenements souris' 'evenements
%%             clavier' 'animations Morphic'; j'ai donc ajoute pour la
%%             coherence avec le titre du chapitre l'ancien chapitre
%%             'interacteurs' comme sous-section.
%%             - redecoupe du 'resume du chapitre'; les *item*
%%             commencent tous par un verbe infinitif. Par rapport a
%%             la version d'Andrew Black, j'ai inserer dans la liste
%%             le fait de pouvoir trouver des morphs predefinis (avant-
%%             dernier *item*) et j'ai ajoute un *item* sur les
%%             methodes graphiques des canevas (derniere chapitre)
%%             
%%             D'une maniere generale tres peu de copier-coller du
%%             texte d'Hilaire Fernandes; Andrew a deja fait beaucoup
%%             de corrections. Reste la structure centrale des
%%             chapitres, les exemples et les graphiques associes.
%% 
%%             PBE:
%%             - rappel: rouge = click; jaune = actclick (contextuel)
%%             bleu = metaclick (halo) 
%%
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 
%%% Change log: 
%%             - Traduction et figures par Martial
%%             - Premiere et deuxième relecture par Rene 
%% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \graphicspath{{figures/} {../figures/}}
	\begin{document}
	% \renewcommand{\nnbb}[2]{} % Disable editorial comments
	\sloppy
\fi
%=================================================================
\chapter{L'interface Morphic}

%\sd{We should first give a conceptual overview.
%Then we need a cookbook of how to do simple things in Morphic.
%The observer pattern and its implementation with changed:  and update: messages could go here.  Or in ``Idiomatic design patterns'' later.}

%
\indmain{Morphic} est le nom de l'interface graphique de \pharo.
Elle est écrite en \st, donc elle est pleinement portable entre
différents systèmes d'exploitation; en conséquence de quoi, \pharo
a le même aspect sur Unix, \macosx et Windows.
L'absence de distingo entre \emph{composition} et \emph{exécution}
de l'interface est la principale divergence de Morphic avec la plupart
des autres boîtes à outils graphiques: tous ses éléments
graphiques peuvent être assemblés et désassemblés à tout
moment par l'utilisateur.
%note de martial: il faudra remettre cette note lorsque nous serons
%fixes sur les droits. Je pense qu'il vaudrait mieux le remercier
%plus precisement dans le chapitre Preface (cad en precisant que c'est
%lui qui est a l'origine de ce chapitre.
%\footnote{We thank Hilaire Fernandes for permission to base this chapter on his original article in French.}

\ab{After the first printing, I took an editing pass, correcting some errors and grammatical infelicities.}

\on{I have commented out the LabelstickerMorph and PyramidMorph examples, as they do not really add much over the other examples we have already. The source code is now available in the example subdirectory, in case someone would like to try and use them after all.}

%martial: je prefere mettre la partie historique en intro car elle est
%trop courte; de plus le paragraphe porte mal son nom
Morphic a été développée par John Maloney et Randy Smith pour
le langage de programmation orienté objet \ind{Self} développé
chez Sun Microsystems:
%ajout
l'interface de ce langage basé sur le concept de prototypes (comme
JavaScript) est apparue en 1993. Maloney réécrivit ensuite une nouvelle version de Morphic pour \squeak, l'ancêtre de \pharo tout en conservant de la version originale son aspect \emph{direct} et \emph{vivant}.
%ajout
Dans ce chapitre, nous ferons une immersion dans cet univers d'objets
graphiques, les \emph{morphs} et nous apprendrons à les modeler (à la
souris ou en programmation), à leur ajouter des fonctionnalités (pour
accroître leur capacité d'interaction) et enfin, en préambule
d'un exemple complet, nous verrons comment ils s'intègrent non seulement
dans l'espace mais aussi dans le temps.

%=================================================================
\section{Première immersion dans Morphic}

\subsection{Réponse au doigt et à l'\oe il}
Le caractère direct de l'interface Morphic se traduit par le fait
que toutes les formes graphiques sont des objets 
%examined or changed directly
inspectables et modifiables directement par la souris.
%l'interactivité offerte

De plus, le fait que toute action faite par l'utilisateur donne lieu
à une réponse de la part de Morphic définit son caractère
vivant: les informations affichées sont constamment mise à jour
au fur et à mesure des changements du ``monde'' que l'interface
décrit. 
Comme preuve de cette vie et de toute la dynamique qui en résulte,
nous vous proposons d'isoler une option du menu World et de vous
en faire un bouton hors du menu.

\dothis{Afficher le menu World. 
\Metaclickz{} une première fois sur le menu World
  de manière à afficher son \emph{halo}\footnote{Rappelez-vous que
    vous devez avoir l'option \button{halosEnabled} activée dans le
    Preference Browser. Vous pouvez aussi l'activer en évaluant
    \ct{Preferences enable: \#halosEnabled} dans un espace de
    travail.} Morphic.
\Metaclickz{} à nouveau sur l'option de menu que vous voulez détacher,
disons \menu{Workspace} pour afficher son halo. % CHANGE
 Déplacez celui-ci n'importe où sur l'écran en glissant
  la poignée noire \grabHandle{},
 comme le montre \figref{detachingMenu}.}
\index{Morphic!halo}

\begin{figure}[ht]
   \centerline{\includegraphics[width=0.3\textwidth]{detachingMenu}}
	\caption{Détacher l'option de menu \menu{Workspace} pour
      en faire un bouton indépendant.\figlabel{detachingMenu}}
\end{figure}

\subsection{Un monde de morphs}
Tous les objets que vous voyez à l'écran dans \pharo sont des
\emph{morphs}; tous sont des instances des sous-classes de \ct{Morph}.
\mbox{\ct{Morph}} est une grande classe avec de nombreuses méthodes
qui permettent d'implémenter des sous-classes ayant un comportement
original avec très peu de code.
Vous pouvez créer un morph pour représenter n'importe quel objet. 
%, although how good a representation you get depends on the object!

\dothis{Pour créer un morph représentant une chaîne de
  caractères, évaluer le code suivant dans un espace de travail.}

\begin{code}{}
'Morph' asMorph openInWorld
\end{code}
\cmindex{Morph}{openInWorld}
% ON: openViewerForArgument is gone in pharo! % CHANGE - martial: donc
% différent de SBE

Ce code crée un morph pour représenter la chaîne
de caractères \ct{'Morph'} et l'affiche dans
l'écran principal, le ``world'' (en français, nous dirions
``monde'' puisque la fenêtre \pharo est un \emph{monde de morphs}).
Vous pouvez manipuler cet objet graphique en \metaclickant{}.
\index{world}

% CHANGE - martial - dans SBE, il y a un paragraphe avec le Viewer
% eToys que j'avais ajouté

\subsection{Personnaliser sa représentation}

Revenons maintenant au code qui a créé ce morph. 
% martial - 'orange' remplace 'tan' dans la VO de PBE/SBE
Tout repose sur la méthode qui fabrique un morph à partir d'une
chaîne de caractères:
cette méthode \mthind{String}{asMorph} implémentée dans
\ct{String} crée un \ct{StringMorph}. \mthind{Object}{asMorph} est
implémentée par défaut dans \ct{Object} donc tout objet peut
être représenté par un morph. En réalité, la méthode
\ct{asMorph} dans \ct{Object} fait appel à sa méthode dérivée
dans \ct{String}. Ainsi, tant qu'une classe n'a pas surchargé cette
méthode, elle sera représentée par un \ct{StringMorph}.
Par exemple, évaluer \ct{Color orange asMorph openInWorld} ouvrira un
\ct{StringMorph} dont le label sera le résultat de \clsind{Color}
\ct{orange printString} (comme en faisant un \short{p} sur \ct{Color orange}
dans un Workspace).
Voyons comment obtenir un rectangle de couleur plutôt que ce
\ct{StringMorph}.
%The method \mthind{Object}{asMorph} has a default implementation in class \ct{Object} class that just creates a StringMorph.
%So, for example, \ct{Color tan asMorph} returns a StringMorph labeled with the result of \clsind{Color} \ct{tan printString}.
%Let's change this so that we get a coloured rectangle instead.

\dothis{Ouvrez un navigateur de classes sur la classe \ct{Color} et
  ajoutez la méthode suivante
%ajout
dans le protocole \ct{creation}:}
\begin{method}{Obtenir un morph d'une instance de \ct{Color}}
Color>>>asMorph
	^ Morph new color: self
\end{method}
\noindent
Exécutez \ct{Color blue asMorph} \mthind{Morph}{openInWorld} dans un
espace de travail. Fini le texte d'affichage \ct{printString}! Vous
obtenez un joli rectangle bleu.


%=================================================================
\section{Manipuler les morphs}

Puisque les morphs sont des objets, nous pouvons les manipuler comme
n'importe quel autre objet dans \st \cad par envoi de messages. Dès
lors nous pouvons entre autre changer leurs propriétés ou créer
de nouvelles sous-classes de \ct{Morph}.

Qu'il soit affiché à l'écran ou non, tout morph a une position
et une taille. Tous les morphs sont inclus, par commodité, dans une
boîte englobante, \cad une région rectangulaire occupant un
certain espace de l'écran. Dans le cas des formes irrégulières,
leur position et leur taille correspondent à celles du plus petit
rectangle qui englobe la forme. Cette boîte englobante définit
les limites (ou \emph{bounds}) du morph. % ou frontiere?
La méthode \mthind{Morph}{position} retourne un \ct{Point} qui
décrit la position du coin supérieur gauche du morph (\cad le coin
supérieur gauche de sa boîte englobante).
L'origine des coordonnées du système est le coin supérieur
gauche de l'écran: la valeur de la coordonnée $y$ augmente
\emph{en descendant} l'écran et la valeur de $x$ augmente en allant
de gauche à droite.
La méthode \ct{extent} renvoie aussi un point, mais ce point
définit la largeur et la hauteur du morph plutôt qu'une position.

\dothis{Entrez le code suivant dans un espace de travail et
  évaluez-le (\menu{do it}):}
%%% futur?
%%%bill etait rouge (red); il devient vert (green) pour les raisons
%%%evoquees plus loin (contraste)
\begin{code}{}
joe := Morph new color: Color blue.
joe openInWorld.
bill := Morph new color: Color red.
bill openInWorld.
\end{code}
\noindent

%ajout
Ce code affiche deux nouveaux morphs répondant aux noms de joe et
bill: par défaut, un morph apparaît comme  un rectangle de
position (0@0) et de taille (50@40).
Saisissez ensuite \ct{joe position} et affichez son résultat par \menu{print it}.
Pour déplacer joe, exécutez \ct{joe position: (joe position + (10@3))} plusieurs fois.
Vous pouvez modifier la taille aussi. Pour avoir la taille de joe,
vous pouvez évaluer par \menu{print it} l'expression \ct{joe}
\mthind{Morph}{extent}. Pour le faire grandir, exécutez \ct{joe extent: (joe extent * 1.1)}.
Pour changer la couleur d'un morph, envoyez-lui le message
\mthind{Morph}{color:} avec en argument un objet de classe \ct{Color},
correspondant à la couleur désirée. Par exemple,
\ct{joe color: Color orange}.
Pour ajouter la transparence, essayez
\ct{joe color: (Color blue alpha: 0.5)}.
%martial: a l'origine, c'est orange et pas blue (voir figure)
%%%martial: dans la version d'Andrew (SBE), joe est orange transparent ici et
%%%bleu transparent sur la figure: donc je prefere que joe soit orange
%%%transparent sur la figure; c'est pour le contraste que bill devient
%%%vert

\dothis{Pour faire en sorte que bill suive joe, vous pouvez exécuter
  ce code de manière répétée:}
\begin{code}{}
bill position: (joe position + (100@0))
\end{code}
\noindent

Si vous déplacez joe avec la souris et que vous exécutez ce code,
bill se déplacera pour se positionner à 100 pixels à droite de joe.
\ab{It would seem that this would be a good place to introduce the \ct{step} method}

%=================================================================
\section{Composer des morphs}

Créer de nouvelles représentations graphiques peut se faire en
plaçant un morph à l'intérieur d'un autre. C'est ce que nous
appelons la \emph{composition}; les morphs peuvent être composés
à l'infini. % to any depth
Pour ce faire, vous pouvez envoyer au morph contenant le message
\mthind{Morph}{addMorph:}. %container
\index{morph!composer}
\seeindex{morph!sous-morph}{sous-morph}
%
%To create new morphs, there are two main techniques that you can combine:
%\begin{enumerate}
%	\item by composing morphs one into another,
%	\item by subclassing \ct{Morph} and overriding \mthind{Morph}{drawOn:} to draw original morph shapes.
%\end{enumerate}
%}

\dothis{Ajoutez un morph à un autre avec le code suivant:}
\begin{code}{}
star := StarMorph new color: Color yellow.
joe addMorph: star.
star position: joe position.
\end{code}

\noindent
La dernière ligne place l'étoile nommée star aux mêmes
coordonnées que joe. Notez que les coordonnées du morph
contenu sont toujours à la position absolue définie par rapport
à l'écran, et non à la position relative définie par rapport
au morph contenant.
Plusieurs méthodes sont disponibles pour positionner un morph;
naviguez dans les méthodes du protocole \protind{geometry} de la
classe \ct{Morph} pour le constater vous-même.
Par exemple, centrer l'étoile dans joe revient à exécuter
\ct{Star} \mthind{Morph}{center:} \ct{joe center}.

\begin{figure}[ht]
	\centerline{\includegraphics{joeStar}}
	\caption{L'étoile de classe StarMorph est contenue dans joe, le
      morph bleu translucide.\figlabel{joeStar}}
\end{figure}
%%%orange

Si vous attrapez l'étoile avec la souris, vous constaterez que vous
prenez en réalité joe et que les deux morphs sont ensemble:
l'étoile est \emph{incluse} %embedded inside a traduit par inclus dans
à l'intérieur de joe.
Il est possible d'inclure plus de morphs dans joe. %
%ajout
Les morphs inclus sont appelés des \ind{sous-morph}{}s (en anglais,
\emph{submorphs}). %
%la phrase est tourne differement dans SBE
Comme l'interface Morphic propose une interactivité directe pour
tout morph, nous pouvons aussi faire notre inclusion de morphs en
remplaçant la programmation par une simple manipulation à la souris.
%In addition to doing this programatically, you can also embed morphs by direct manipulation.
\seeindex{submorph}{sous-morph}

%=================================================================
\section{Dessiner ses propres morphs}

Bien qu'il soit possible de faire des représentations graphiques
utiles et intéressantes par composition de morphs, vous aurez
parfois besoin de créer quelque chose de complètement différent.
\index{morph!sous-classer}
Pour ce faire, vous définissez une sous-classe de \ct{Morph} et
surchargez la méthode \mthind{Morph}{drawOn:} pour personnaliser son
apparence.

L'interface Morphic envoie un message \ct{drawOn:} à un morph à
chaque fois qu'il est nécessaire de rafraîchir l'affichage du
morph à l'écran. Le paramètre passé à \ct{drawOn:} est un
type de canevas de classe \clsind{Canvas}; le morph s'affichera alors
lui-même sur ce canevas dans ses limites. %
%the expected behaviour is that the morph will draw itself on that canvas, inside its bounds.
Utilisons cette connaissance pour créer un morph en forme de croix.
\index{morph!sous-classer}

\dothis{Définissez via le Browser une nouvelle
  classe \clsind{CrossMorph} héritée de \ct{Morph}:}
\begin{classdef}{Définir la classe \ct{CrossMorph}}
Morph subclass: #CrossMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PBE-Morphic'
\end{classdef}

Nous pouvons définir la méthode \ct{drawOn:} ainsi:
%ajout du commentaire
\begin{method}[firstDrawOn]{Dessiner un \ct{CrossMorph}}
drawOn: aCanvas 
	"crossHeight est la hauteur de la barre horizontale horizontalBar
    et crossWidth est la largeur de la barre verticale verticalBar"
    | crossHeight crossWidth horizontalBar verticalBar |
	crossHeight := self height / 3.0 .
	crossWidth := self width / 3.0 .
	horizontalBar := self bounds insetBy: 0 @ crossHeight.
	verticalBar := self bounds insetBy: crossWidth @ 0.
	aCanvas fillRectangle: horizontalBar color: self color.
	aCanvas fillRectangle: verticalBar color: self color
\end{method}


\begin{figure}[hbt]
	\ifluluelse
		{\centerline{\includegraphics[width=0.3\textwidth]{NewCross}}}
		{\centerline{\includegraphics{NewCross}}}
	\caption{Un nouveau morph en forme de croix de classe
      \ct{CrossMorph} avec son halo. Vous pouvez redimensionner cette
      croix grâce à la poignée inférieure droite
      de couleur jaune.\figlabel{cross}}
\end{figure}

Envoyer le message \mthind{Morph}{bounds} à un morph renvoie sa
boîte englobante, instance de la classe \clsind{Rectangle}.  Les
rectangles comprennent plusieurs messages qui créent d'autres
rectangles de même géométrie; % related geometry; 
dans notre méthode, nous utilisons le message \ct{insetBy:} avec un
point comme argument pour créer une première fois un rectangle de
hauteur (en anglais, \emph{height}) réduite, puis pour créer un
autre rectangle de largeur (en anglais, \emph{width}) réduite.

\dothis{Pour tester votre nouveau morph, évaluer l'expression \ct{CrossMorph new} \mthind{Morph}{openInWorld}.}
Le résultat devrait être semblable à celui de \figref{cross}.
Cependant, vous remarquerez que toute la boîte englobante est
sensible à la souris (vous pouvez cliquer en dehors de la croix et
interagir ou déplacer celle-ci). Corrigeons ceci en rendant la seule
surface de la croix sensible à la souris.
%However, you will notice that the sensitive zone\,---\,where you can click to grab the morph\,---\,is still the whole bounding box.  Let's fix this.

Lorsque la librairie Morphic a besoin de trouver quels morphs se
trouvent sous le curseur, elle envoie le message \ct{containsPoint:}
 à tous les morphs qui ont leur boîte englobante sous le pointeur de la souris. 
%ajout
Cette méthode répond vrai lorsque le point-argument est contenu dans la
forme définie.
Pour limiter la zone sensible du morph à la forme de la croix, vous
devez surcharger la méthode \ct{containsPoint:}.

\dothis{Définissez la méthode \ct{containsPoint:} dans la classe \ct{CrossMorph}:}

\needlines{4}
\begin{method}[firstContains]{Modeler la zone sensible à la souris des instances de \ct{CrossMorph}}
containsPoint: aPoint
	| crossHeight crossWidth horizontalBar verticalBar |
	crossHeight := self height / 3.0.
	crossWidth := self width / 3.0.
	horizontalBar := self bounds insetBy: 0 @ crossHeight.
	verticalBar := self bounds insetBy: crossWidth @ 0.
	^ (horizontalBar containsPoint: aPoint)
		or: [verticalBar containsPoint: aPoint]
\end{method}

Cette méthode suit la même logique que la méthode \ct{drawOn:}, 
nous sommes donc sûrs que les points pour lesquels
\ct{containsPoint:} retourne \ct{true} sont les mêmes points qui
seront colorés par \ct{drawOn:}.
Notez qu'à 
%ajout
la dernière ligne nous avons profité de la méthode
\mthind{Rectangle}{containsPoint:} 
de la classe \ct{Rectangle} pour faire l'essentiel du travail.
%Notice how we leverage the \mthind{Rectangle}{containsPoint:} method in class \ct{Rectangle} to do the hard work.

Il reste tout de même deux problèmes avec ce code dans les 
\mthsref{firstDrawOn} et \ref{mth:firstContains}.
Le plus remarquable est que nous ayons du code dupliqué.
C'est une erreur fondamentale: si vous avez besoin de modifier la
façon dont \ct{horizontalBar} ou \ct{verticalBar} sont
calculées, vous risquez d'oublier de reporter les changements
effectués d'une méthode à l'autre.
%reformulation
La solution consiste à éliminer la redondance en refactorisant ces
calculs dans deux nouvelles méthodes que nous plaçons dans le
protocole \ct{private}:

\needlines{4}
\begin{method}{\ct{horizontalBar}}
horizontalBar
	| crossHeight |
	crossHeight := self height / 3.0.
	^ self bounds insetBy: 0 @ crossHeight
\end{method}

\needlines{4}
\begin{method}{\ct{verticalBar}}
verticalBar
	| crossWidth |
	crossWidth := self width / 3.0.
	^ self bounds insetBy: crossWidth @ 0
\end{method}

\noindent
Nous pouvons ensuite définir les méthodes \ct{drawOn:} et
\ct{containsPoint:} ainsi:

\needlines{4}
\begin{method}{Refactoriser \ct{CrossMorph>>>drawOn:}}
drawOn: aCanvas 
	aCanvas fillRectangle: self horizontalBar color: self color.
	aCanvas fillRectangle: self verticalBar color: self color
\end{method}

\needlines{4}
\begin{method}{Refactoriser \ct{CrossMorph>>>containsPoint:}}
containsPoint: aPoint
	^ (self horizontalBar containsPoint: aPoint)
		or: [self verticalBar containsPoint: aPoint]
\end{method}

Ce code est plus simple à comprendre principalement parce que nous
avons donné des noms parlants à ces méthodes privées. En fait,
notre simplification a mis en avant notre second problème: 
% it is so simple that you may have noticed the second problem:
la zone centrale de notre croix, à la croisée des barres
horizontales et verticales, est dessinée deux fois. Ce n'est pas
très problématique tant que notre croix est de couleur opaque,
mais l'erreur devient clairement apparente si nous dessinons une croix
semi-transparente, comme nous pouvons le voir sur \figref{overdrawBug}.

\begin{figure}[t]
\begin{minipage}{0.48\textwidth}
	\ifluluelse
		{\centerline{\includegraphics[scale=0.6]{overdrawBug}}}
		{\centerline{\includegraphics{overdrawBug}}}
	\caption{Le centre de la croix est rempli deux fois avec la
      couleur.	\figlabel{overdrawBug}}
\end{minipage}
\hfill
\begin{minipage}{0.48\textwidth}
	\ifluluelse
		{\centerline{\includegraphics[scale=0.6]{hairlineBug}}}
		{\centerline{\includegraphics{bug}}}
	\caption{Le morph en forme de croix présente une ligne de pixels
      non remplis.	\figlabel{bug}}
\end{minipage}
\end{figure}

\needlines{4}
\dothis{Évaluez ligne par ligne le code suivant dans un espace de travail:}

\begin{code}{}
m := CrossMorph new bounds: (0@0 corner: 300@300).
m openInWorld.
m color: (Color blue alpha: 0.3).
\end{code}

\noindent
La correction repose sur la division de la barre verticale en trois
morceaux et sur le remplissage uniquement des deux morceaux supérieurs et inférieurs.
Encore une fois, nous trouvons une méthode dans la classe
\ct{Rectangle} qui va bien nous aider: \ct{r1 areasOutside: r2} 
retourne un tableau de rectangles comprenant les parties de \ct{r1}
exclus de \ct{r2}. 

Le code revisité de la méthode \ct{drawOn:} peut s'écrire comme suit:

%ajout du commentaire
\begin{method}{La méthode \ct{drawOn:} revisitée pour ne remplir le centre qu'une seule fois}
drawOn: aCanvas 
    "topAndBottom est un tableau des parties de verticalBar !tronqué!"
	| topAndBottom |
	aCanvas fillRectangle: self horizontalBar color: self color.
	topAndBottom := self verticalBar areasOutside: self horizontalBar. 
	topAndBottom do: [ :each | aCanvas fillRectangle: each color: self color]
\end{method}

Ce code semble fonctionner mais, suivant la taille des croix 
%ajout
(que vous pouvez obtenir en les dupliquant et en les redimensionnant
avec le halo Morphic), vous pouvez constater qu'une ligne d'un pixel
de haut peut séparer la base de la croix du reste, comme le montre
\figref{bug}.
Ceci est du à un problème de troncature: %temporaire  
lorsque la taille d'un rectangle à remplir n'est pas un entier,
\ct{fillRectangle: color:} semble mal arrondir et laisse donc une
ligne de pixels non remplis.
Nous pouvons résoudre ce problème en arrondissant explicitement
lors du calcul des tailles des barres.

\needlines{5}
\begin{method}{\ct{CrossMorph>>>horizontalBar} avec troncature explicite}
horizontalBar
	| crossHeight |
	crossHeight := (self height / 3.0) rounded.
	^ self bounds insetBy: 0 @ crossHeight
\end{method}

\needlines{5}
\begin{method}{\ct{CrossMorph>>>verticalBar} avec troncature explicite}
verticalBar
	| crossWidth |
	crossWidth := (self width / 3.0) rounded.
	^ self bounds insetBy: crossWidth @ 0
\end{method}



%=================================================================
%\section{Composing Morphs}

%\on{The source code is in the examples directory.
%For the moment I prefer to leave out the examples, as they do not add much.}

%Below, we present a few morphs that were designed for a course project.

%\paragraph{An adhesive Label} The \ct{LabelStickerMorph} is a metaphor for an adhesive label with a colored border and three lines of text (\figref{labeler}, \egref{labeler}).

%\begin{figure}[ht]
%	\centerline{\includegraphics[width=0.25\textwidth]{labeler}}
%	\caption{The sticker label morph.
%		\figlabel{labeler}}
%\end{figure}

%\begin{example}[labeler]{Creating a sticker label}{}
%label := LabelstickerMorph new openInWorld.
%label text1: 'Confiture sans sucre';
%	text2: 'Fraises du jardin';
%	text3: '9 mai 2006'.
%label lineColor: Color blue
%\end{example}

%\paragraph{A Number Pyramid}
%The previous morph is designed by overriding the \ct{drawOn:} method.
%We built \ct{PyramidMorph} by composing morphs: we used \ct{TextMorph}s to make the blocks and added them to a base morph (\figref{pyramid}, \egref{pyramid}). \damien{figure does not match text... no numbers? Where is the code?}
%\begin{figure}[ht]
%	\centerline{\includegraphics{pyramid}}
%	\caption{The number pyramid morph.
%		\figlabel{pyramid}}
%\end{figure}

%\begin{example}[pyramid]{Manipulating the number pyramid}{}
%pyramid := (PyramidMorph base: 4) openInWorld.
%pyramid block: 8 value: 2
%\end{example}


%=================================================================
\section{Intéraction et animation}

Pour construire des interfaces utilisateur vivantes avec les morphs,
nous avons besoin de pouvoir interagir avec elles en utilisant la
souris et le clavier.
En outre, les morphs doivent être capable de répondre aux
intéractions de l'utilisateur en changeant leur apparence et leur
position, autrement dit, en s'animant eux-mêmes.

\subsection{Les événements souris}

Quand un bouton de la souris est pressé, Morphic envoie à chaque
morph sous le pointeur de la souris le message
\ct{handlesMouseDown:}. Si un morph répond \ct{true}, Morphic lui
envoie immédiatemment le message \mbox{\mthind{Morph}{mouseDown:}.} Lorsque
le bouton de la souris est relâché, Morphic envoie
\mthind{Morph}{mouseUp:}  à ces mêmes morphs qui avaient répondu
positivement. Si tous les morphs retournent \ct{false}, Morphic entame
une opération de
%saisissement dans la version d'Hilaire (c'est en fait une emotion vive et soudaine)
saisie en prévision du glisser-déposer.
Comme nous allons le voir, les messages \ct{mouseDown:} et \ct{mouseUp}
sont envoyés avec un argument\,---\,un objet de classe
\clsind{MouseEvent}\,---\,qui contient les détails de l'action de la souris.
%that encodes the details of the mouse action.

Ajoutons la gestion des événements souris à notre classe
\ct{CrossMorph} en commençant par nous assurer que toutes nos
croix répondent \ct{true} au message \mthind{Morph}{handlesMouseDown:}.

\dothis{Ajoutez la méthode suivante à la classe \ct{CrossMorph}:}
\begin{method}{Déclarer que \ct{CrossMorph} réagit aux clics de souris}
CrossMorph>>>handlesMouseDown: anEvent
	^ true
\end{method}

Supposons que vous vouliez que la couleur de la croix passe au rouge
(\ct{Color red})
à chaque fois que vous \clickz et qu'elle passe au jaune
\mbox{(\ct{Color yellow})}
lorsque vous \actclickz sur celle-ci. 
Nous devons créer la \mthref{mouseDown}.

%% REVOIR IMPORTANT
\tradalert{martial}{Faudrait-il mettre des méthodes \#clickButtonPressed
  et \#actClickButtonPressed dans Pharo?!}
\begin{method}[mouseDown]{Réagir aux clics de la souris en changeant la couleur de la croix}
CrossMorph>>>mouseDown: anEvent
	anEvent redButtonPressed "click"
		ifTrue: [self color: Color red].
	anEvent yellowButtonPressed "action-click"
		ifTrue: [self color: Color yellow].
	self changed
\end{method}

\ab{I added this note:}
Remarquez que non seulement cette méthode change la couleur de notre
morph, mais qu'elle envoie aussi le message \ct{self changed}.
Ce message assure que Morphic envoie \ct{drawOn:}
%in a timely fashion
de façon assez rapide.

\ab{However, the \ct{self changed} message seems to be entirely unnecessary; the colour changes instantly without it.}

Notez aussi qu'une fois qu'un morph gère les événements \subind{événement}{souris}, vous ne pouvez plus l'attraper avec la souris pour le déplacer.
Dès lors, vous devez utiliser le halo Morphic en \metaclickant: les poignées supérieures noire \grabHandle{} et marron \moveHandle{} vous permettent respectivement de prendre et déplacer ce morph.
\seeindex{souris!événement}{événement, souris}

L'argument \ct{anEvent} de \ct{mouseDown:} est une instance de
\mbox{\clsind{MouseEvent},} sous-classe de \ct{MorphicEvent}.
%\lct{Mor\-phic\-Event}{.} 
\ct{MouseEvent} définit les méthodes
\mthind{MouseEvent}{redButtonPressed} pour la gestion du \arelire{\clickbtn} 
et \mthind{MouseEvent}{yellowButtonPressed} \arelire{pour celle du
  \actclickbtn}. % REVOIR martial: encore des vestiges de Squeak
 Parcourez cette classe pour en savoir plus sur les autres méthodes disponibles pour la gestion
des événements souris. 
% ATTENDRE - martial - je n'aime pas trop l'abandon des conventions de couleurs de la souris dans le livre si le système les garde CONFUS! 
%The anEvent argument of mouseDown: is an instance of MouseEvent, which
%is a subclass of MorphicEvent. MouseEvent defines the redButtonPressed and
%yellowButtonPressed methods. Browse this class to see what other methods
%it provides to interrogate the mouse event.


\subsection{Les événements clavier}

La capture des événements \subind{événement}{clavier} se déroule en trois
étapes. Morphic devra:

%modification
%``keyboard focus'' to a specific morph: for instance we can give focus to our morph when the mouse is over it.

\begin{enumerate}
	\item activer votre morph pour la gestion du clavier par la ``mise
      au point'' sous une certaine condition, disons, lorsque la souris est au-dessus du morph; 
	\item gérer l'événement proprement dit avec la méthode
      \mthind{Morph}{handleKeystroke:} --- ce message est envoyé au
      morph quand vous pressez une touche et qu'il a déjà reçu
      la mise au point  (en anglais, \emph{keyboard focus});
	\item libérer la mise au point lorsque la condition de la
      première étape n'est plus remplie, disons, quand la souris
      n'est plus au-dessus du morph.
\end{enumerate}

Occupons-nous de \ct{CrossMorph} pour que nos croix réagissent à
certaines touches du clavier. Tout d'abord, nous avons besoin d'être
informé que la souris est au-dessus de la surface de notre morph:
dans ce cas, le morph doit répondre \ct{true} au message
\mthind{Morph}{handlesMouseOver:}.

\dothis{Déclarez que \ct{CrossMorph} réagit lorsque il est sous le
  pointeur de la souris.}

\begin{method}{Gérer les événements souris ``mouse over''} 
CrossMorph>>>handlesMouseOver: anEvent
	^ true
\end{method}

\noindent
Ce message est équivalent à \mthind{Morph}{handlesMouseDown:}
utilisé pour la position de la souris.
Les messages \mthind{Morph}{mouseEnter:} et
\mthind{Morph}{mouseLeave:} sont envoyés respectivement lorsque le
pointeur de la souris entre dans l'espace du morph ou sort de celui-ci.

\dothis{Définissez deux méthodes grâce auxquelles un morph
  \ct{CrossMorph} peut activer et libérer la mise au point sur le
  clavier. Créez ensuite une troisième méthode pour gérer
  l'interaction via la saisie des touches.}
\begin{method}{Activer la mise au point sur le clavier lorsque la souris entre dans l'espace du morph}
CrossMorph>>>mouseEnter: anEvent
	anEvent hand newKeyboardFocus: self
\end{method}

\begin{method}{Libérer la mise au point sur le clavier lorsque la souris sort de l'espace du morph}
CrossMorph>>>mouseLeave: anEvent
	anEvent hand newKeyboardFocus: nil
\end{method}

\begin{method}[handleKeystroke]{Capturer et gérer les événements clavier}
CrossMorph>>>handleKeystroke: anEvent
	| keyValue |
	keyValue := anEvent keyValue.
	keyValue = 30	 "!flèche du haut!"
		ifTrue: [self position: self position - (0 @ 1)].
	keyValue = 31	 "!flèche du bas!"
		ifTrue: [self position: self position + (0 @ 1)].
	keyValue = 29	 "!flèche de droite!"
		ifTrue: [self position: self position + (1 @ 0)].
	keyValue = 28	 "!flèche de gauche!"
		ifTrue: [self position: self position - (1 @ 0)]
\end{method}

La méthode que nous venons d'écrire vous permet de déplacer
notre croix avec les touches fléchées. Remarquez que lorsque la
souris n'est pas sur la croix, le message
\mthind{Morph}{handleKeystroke:} n'est pas envoyé: dans ce cas, la croix
ne répond pas aux commandes clavier.
Vous pouvez connaître la valeur des touches saisies au clavier en
ouvrant une fenêtre Transcript et en ajoutant à 
\mthref{handleKeystroke} la ligne 
\glbind{Transcript} \ct{show: anEvent keyValue}.
L'événement-argument \ct{anEvent} de \ct{handleKeystroke} est une
instance de la classe \clsind{KeyboardEvent}, sous-classe de
\clsind{MorphicEvent}. Naviguez dans cette classe pour connaître les
méthodes de gestion des événements clavier.

% dans le document original, on parle avant de
% MorphicEvent mais pas dans la version d'andrew

\subsection{Les animations Morphic}

%martial: j'ai changé deux methodes + 3 en quatre + 1
Pour l'essentiel, Morphic permet de composer et d'automatiser de
simples animations grâce à quatre méthodes:
\begin{itemize}
\item \mthind{Morphic}{step} qui est envoyé au morph à un
  \emph{tempo} régulier pour construire le comportement de l'animation;
\item \mthind{Morphic}{stepTime} qui définit l'intervalle de temps en
  millisecondes entre chaque envoi du message \ct{step}~\footnote{\ct{stepTime} est
    en réalité le temps \emph{minimum} entre les envois du message
    \ct{step}. Si vous demandez un \emph{tempo} \ct{stepTime} de
    1\,ms, ne soyez pas étonné si \pharo est trop occupé pour que
    le rythme de l'animation de votre morph tienne cette cadence.};
\item \mthind{Morphic}{startStepping} démarre l'animation au rythme
  du métronome \ct{stepTime};
\item \mthind{Morphic}{stopStepping} arrête l'animation.
\end{itemize}

à ces méthodes s'ajoute une méthode de test
\mthind{Morphic}{isStepping} pour savoir si le morph est en cours
d'animation.% currently being stepped.
\index{Morphic!animation}

\dothis{Faites clignoter le \ct{CrossMorph} en définissant les
  méthodes suivantes:}
\begin{method}{Définir la périodicité de l'animation}
CrossMorph>>>stepTime
	^ 100
\end{method}
\begin{method}{Construire le comportement de l'animation}
CrossMorph>>>step
	(self color diff: Color black) < 0.1
		ifTrue: [self color: Color red]
		ifFalse: [self color: self color darker]
\end{method}
\noindent
Pour démarrer l'animation, vous pouvez ouvrir un inspecteur sur
votre objet \ct{CrossMorph}: cliquez sur la poignée de débogage 
\debugHandle{} du halo Morphic de votre croix 
(en \metaclickant{}) puis choisissez \menu{inspect morph} dans le
menu flottant. Entrez l'expression \ct{self startStepping} dans le
mini-espace de travail situé dans le bas de l'inspecteur et faites
un \menu{do it}.
%ajout
Pour arrêter l'animation, évaluez simplement \ct{self stopStepping} dans l'inspecteur. 
Pour démarrer et arrêter l'animation de façon plus efficace, vous pouvez
ajouter des contrôles supplémentaires au clavier. Par exemple,
vous pouvez modifier la méthode \ct{handleKeystroke:} pour que la
touche $+$ démarre le clignotement de la croix et que la touche $-$
le stoppe.

\dothis{Ajoutez le code suivant à \mthref{handleKeystroke}:}

\begin{code}{}
	keyValue = $+ asciiValue 
		ifTrue: [self startStepping].
	keyValue = $- asciiValue
		ifTrue: [self stopStepping].
\end{code}

% \on{You can also \menu{debug \go inspect morph} and evaluate: \ct{self currentWorld startStepping: self}.}

%=================================================================
%martial: passage de cette section en sous-section
\subsection{Les interacteurs} %interactors

%ajout
Morphic dispose de morphs commodes pour créer en quelques lignes de
code des interactions avec l'utilisateur. Parmi eux, nous avons la
classe \clsind{UIManager} offre un grand nombre de boîtes de
dialogue % CHANGE - martial - FillInTheBank devient UIManager
prêtes à l'emploi.
La méthode \mthind{UIManager}{request:initialAnswer:} renvoie
une chaîne de caractères entrée par l'utilisateur (voir
\figref{dialogName}).
\begin{code}{} % CHANGE
UIManager default request: 'Quel est votre nom?' initialAnswer: 'sans nom'
\end{code}

\begin{figure}[htb]
\begin{minipage}{0.48\textwidth}
	\centerline{\includegraphics[width=0.8\textwidth]{dialog}}
	\caption{Une boîte de dialogue affichée par
      \ct{UIManager request: 'Quel est votre nom?' initialAnswer: 'sans nom'}.
		\figlabel{dialogName}}
\end{minipage}
\hfill
\begin{minipage}{0.48\textwidth}
	\vfill
	\centerline{\includegraphics[width=0.8\textwidth]{popup}}
	\vfill
	\vspace{4ex}
	\caption{Un menu flottant.}\figlabel{popup}
\end{minipage}
\end{figure}

Pour afficher le menu flottant (en anglais, \emph{pop-up menu}), 
utilisez une des méthodes \ct{chooseFrom:} (voir
  \figref{popup}):
\begin{code}{}
UIManager default
	chooseFrom: #('cercle' 'ovale' '!\normcode{carré}!' 'rectangle' 'triangle')
	lines: #(2 4) message: 'Choisissez une forme'
\end{code}

%=================================================================
\section{Le glisser-déposer}

Morphic supporte aussi le glisser-déposer. Étudions l'exemple
suivant. Créons tout d'abord un morph receveur qui n'acceptera un
morph que si le dépôt de ce morph se fait dans une certaine
condition. Créons ensuite un second morph que nous appelons morph
déposé. Le fait que le morph soit bleu (\ct{Color blue}) sera
notre condition pour que le glisser-déposé se fasse ici.

\dothis{Définissez la classe pour le morph receveur et créez une
  méthode d'initialisation comme suit:}
\begin{classdef}{Définir un morph sur lequel un autre morph pourra être déposé}
Morph subclass: #ReceiverMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PBE-Morphic'
\end{classdef}

%\dothis{Now define the initialization method in the usual way:}
\begin{method}{Initialiser un objet \ct{ReceiverMorph}}
ReceiverMorph>>>initialize
	super initialize.
	color := Color red.
	bounds := 0 @ 0 extent: 200 @ 200
\end{method}

Comment décidons-nous si le receveur va accepter ou refuser le morph
déposé? En général, ces deux morphs devront s'accorder sur
leur interaction. Le receveur fait cela en répondant au message
 \mthind{Morph}{wantsDroppedMorph:event:}; le premier argument est le
 morph que nous voulons déposer et le second est l'événement
 souris. Ce dernier argument permet, par exemple, au receveur de
 savoir si une (ou plusieurs) touche de modification a été
 maintenue enfoncée durant la phase de dépôt de l'autre morph.
Le morph déposé, quant à lui, se doit de vérifier s'il est
compatible avec le morph sur lequel il est déposé; le message
\ct{wantsToBeDroppedInto:} doit répondre \ct{true} si le morph
receveur 
%ajout
passé en argument est défini comme compatible. L'implémentation
de cette méthode dans la classe mère des morphs \ct{Morph} renvoie
toujours \ct{true} donc, par défaut, tous les morphs sont acceptés en tant que
receveur.

\begin{method}{Accepter les morphs déposés selon leur couleur}
ReceiverMorph>>>wantsDroppedMorph: aMorph event: anEvent
	^ aMorph color = Color blue
\end{method}

Qu'arrive-t-il au morph déposé si le morph receveur ne veut pas de lui?
Le comportement par défaut de l'interface Morphic est de ne rien
%reformule
faire, \cad de laisser le morph déposé au-dessus du morph receveur
sans aucune interaction avec celui-ci. 
Le morph déposé aurait un comportement plus intuitif s'il
retournait à sa position d'origine en cas de refus.
Nous pouvons faire cela en disant au receveur de répondre \ct{true}
au message  \mthind{Morph}{repelsMorph:event:} lorsque celui-ci ne
veut pas du morph déposé:

\needlines{4}
\begin{method}{Changer le comportement du morph déposé lorsqu'il est rejeté}
ReceiverMorph>>>repelsMorph: aMorph event: anEvent
	^ (self wantsDroppedMorph: aMorph event: anEvent) not
\end{method}

C'est tout ce dont nous avons besoin.
%That's all we need as far as the receiver is concerned.

\dothis{Créez des instances de \clsind{ReceiverMorph} et de
  \clsind{EllipseMorph} dans un espace de travail:}
\begin{code}{}
ReceiverMorph new openInWorld.
EllipseMorph new openInWorld.
\end{code}
\noindent
Essayez de faire un glisser-déposer de l'ellipse jaune
\ct{EllipseMorph} sur le morph receveur rouge. Il sera rejeté et
retournera à sa position initiale.

%martial: j'ai ajoute le texte entre parentheses
\dothis{Changez la couleur de l'ellipse pour du bleu via l'inspecteur
  (que vous pouvez activer avec le menu de la poignée du débogage
  du halo Morphic en cliquant sur \menu{inspect morph}): évaluez
  \ct{self color: Color blue}.  Les morphs bleus étant acceptés par
  le \ct{ReceiverMorph}: essayez à nouveau le glisser-déposer.}

%ajout (encouragement)
Bravo! Vous venez de faire un glisser-déposer.

Continuons à explorer le glisser-déposer en créant un morph
déposé spécifique nommé \ct{DroppedMorph},
sous-classe de \ct{Morph}:

\begin{classdef}{Définir un morph que nous pouvons glisser-déposer sur un \ct{ReceiverMorph}}
Morph subclass: #DroppedMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PBE-Morphic'
\end{classdef}

\begin{method}{Initialiser \ct{DroppedMorph}}
DroppedMorph>>>initialize
	super initialize.
	color := Color blue.
	self position: 250@100
\end{method}

% reformulation
Nous voulons que le morph déposé ait un nouveau comportement 
lorsqu'il est rejeté par le receveur; cette fois-ci, il restera
attaché au pointeur de la souris:
\needlines{7}
\begin{method}{Réagir lorsque le morph est rejeté lors du dépôt}
DroppedMorph>>>rejectDropMorphEvent: anEvent
	| h |
	h := anEvent hand.
	WorldState
		addDeferredUIMessage: [h grabMorph: self].
	anEvent wasHandled: true
\end{method}

L'envoi du message \mthind{MorphicEvent}{hand} à un événement
répond la ``main'' (en anglais, \emph{hand}), instance de
\ct{HandMorph} qui représente le pointeur de la souris et tout ce
qu'il tient.
Dans notre méthode, nous disons à l'écran \pharo, \ct{World}, que
la main 
%ajout
(stockée dans la variable temporaire \ct{h}) doit capturer
le morph rejeté 
%ajout + l'index de la méthode
\ct{self} grâce au message \mthind{HandMorph}{grabMorph:}.
%ajout (commentaire de la methode dans MorphicEvent et non dans DropEvent)
La méthode \ct{wasHandled:} détermine si l'événement était capturé.

\dothis{Créer deux instances de \ct{DroppedMorph} et faites un
  glisser-déposer pour chacune sur le receveur.}
\begin{code}{}
ReceiverMorph new openInWorld.
(DroppedMorph new color: Color blue) openInWorld.
(DroppedMorph new color: Color green) openInWorld.
\end{code}
\noindent
Le morph vert (\ct{Color green}) est rejeté et reste ainsi attaché
au pointeur de la souris.

%=================================================================
%\section{Un exemple complet}
\section{Le jeu du dé}

Lançons-nous maintenant dans la création d'un jeu
du dé complet. Nous voulons faire défiler toutes les faces d'un
dé dans une boucle rapide suite à un premier clic de
souris sur la surface de ce dé puis, lors
d'un second clic, arrêter l'animation sur une face.

\begin{figure}[ht]
	\centerline{\includegraphics[scale=0.65]{die}}
	\caption{Le dé dans Morphic.\figlabel{dialogDie}}
\end{figure}

\dothis{Définissez un dé comme une sous-classe de
  \clsind{BorderedMorph} définissant un \ct{Morph} avec un bord:
  appelez-le \ct{DieMorph} (dé se dit \emph{die} en anglais).}

\needlines{6}
\begin{classdef}{Définir le dé DieMorph}
BorderedMorph subclass: #DieMorph
	instanceVariableNames: 'faces dieValue isStopped'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'PBE-Morphic'
\end{classdef}

La variable d'instance \ct{faces} stocke le nombre de faces de notre
dé; nous nous autorisons à avoir des dés jusqu'à neuf faces!
\ct{dieValue} contient la valeur de la face affichée en ce moment et
\ct{isStopped} est un booléen que est \ct{true} si et seulement si
l'animation est à l'arrêt.
Nous allons définir la \emph{méthode de classe} \ct{faces: n} dans
le côté classe de \clsind{DieMorph} pour pouvoir créer un
nouveau dé à \ct{n} faces.

\begin{method}{Créer un nouveau dé avec un nombre de faces déterminé}
DieMorph class>>>faces: aNumber
	^ self new faces: aNumber
\end{method}

La méthode \ct{initialize} est définie dans le côté instance
de la classe; souvenez-vous que \ct{new} envoie \ct{initialize} à
toute instance nouvellement créée.

\begin{method}{Initialiser les instances de \ct{DieMorph}}
DieMorph>>>initialize
	super initialize.
	self extent: 50 @ 50.
	self useGradientFill; borderWidth: 2; useRoundedCorners.
	self setBorderStyle: #complexRaised.
	self fillStyle direction: self extent.
	self color: Color green.
	dieValue := 1.
	faces := 6.
	isStopped := false
\end{method}

Nous utilisons quelques méthodes de la classe \ct{BorderedMorph}
pour donner un aspect sympathique à notre dé: bordure épaisse
avec un effet de relief, coins arrondis et dégradé de couleur sur
la face visible.
%ajout
Nous définissons ensuite la méthode d'instance \ct{faces:} pour
affecter la variable d'instance\,---\,il s'agit d'une méthode
d'accès de type mutateur\,---\, en vérifiant que le paramètre est
bien valide:
\begin{method}{Affecter le nombre correspondant à la face visible du dé}
DieMorph>>>faces: aNumber
	"Affecter le !numéro! de la face"
	(aNumber isInteger
			and: [aNumber > 0]
			and: [aNumber <= 9])
		ifTrue: [faces := aNumber]
\end{method}
\on{Why not make this a pre-condition, \ie an assertion?}

Comprenez bien l'ordre dans lequel les messages sont envoyés lors de
la création d'un dé. Si nous évaluons \ct{DieMorph faces: 9}:
\begin{enumerate}
	\item la méthode de classe \ct{DieMorph class>>>faces:} envoie
      \ct{new} à \ct{DieMorph class};
	\item la méthode pour \ct{new} (héritée par \ct{DieMorph class} de \ct{Behavior}) crée la nouvelle instance et lui envoie
       le message \ct{initialize};
	\item la méthode \ct{initialize} de \ct{DieMorph} affecte la
      valeur initiale 6 à \ct{faces};
	\item \ct{DieMorph class>>>new} retourne à la méthode de
      classe \ct{DieMorph class>>>faces:} qui envoie ensuite le
      message \ct{faces: 9} à la nouvelle instance;
	\item la méthode d'instance \ct{DieMorph>>>faces:} s'exécute
      maintenant en affectant à la valeur 9 la variable d'instance
      \ct{faces}.
\end{enumerate}

%Avant de passer à la définition de la méthode \ct{drawOn:}
Pour positionner les points noirs sur la face du dé, nous devons
besoin de définir autant de méthodes qu'il y a de faces possibles:

\begin{methods}{Neuf méthodes pour placer les points noirs sur la face visible du dé}
DieMorph>>>face1
	^ {0.5@0.5}
DieMorph>>>face2
	^ {0.25@0.25 . 0.75@0.75}
DieMorph>>>face3
	^ {0.25@0.25 . 0.75@0.75 . 0.5@0.5}
DieMorph>>>face4
	^ {0.25@0.25 . 0.75@0.25 . 0.75@0.75 . 0.25@0.75}
DieMorph>>>face5
	^ {0.25@0.25 . 0.75@0.25 . 0.75@0.75 . 0.25@0.75 . 0.5@0.5}
DieMorph>>>face6
	^ {0.25@0.25 . 0.75@0.25 . 0.75@0.75 . 0.25@0.75 . 0.25@0.5 . 0.75@0.5}
DieMorph>>>face7
	^ {0.25@0.25 . 0.75@0.25 . 0.75@0.75 . 0.25@0.75 . 0.25@0.5 . 0.75@0.5 . 0.5@0.5}
DieMorph >>>face8
	^ {0.25@0.25 . 0.75@0.25 . 0.75@0.75 . 0.25@0.75 . 0.25@0.5 . 0.75@0.5 . 0.5@0.5 . 0.5@0.25}
DieMorph >>>face9
	^ {0.25@0.25 . 0.75@0.25 . 0.75@0.75 . 0.25@0.75 . 0.25@0.5 . 0.75@0.5 . 0.5@0.5 . 0.5@0.25 . 0.5@0.75}
\end{methods}
\on{kind of ugly boilerplate code -- should be a nice way to map these more elegantly to coordinates.}

Ces méthodes définissent des collections de coordonnées de
points pour chaque configuration de faces possible. Les coordonnées
sont dans un carré de dimension $1\times1$. Pour placer nos points,
nous effectuons simplement un changement d'échelle.

%reformulation
Enfin, pour dessiner la face du dé, nous définissons la méthode
\ct{drawOn:} qui fera d'abord un envoi sur \ct{super}, utilisant la méthode
définie dans une classe-mère pour dessiner le fond de la face, et
qui exploitera, dans un deuxième temps, les méthodes créées
précédemment pour dessiner les points noirs.

\begin{method}{Dessiner le dé}
DieMorph>>>drawOn: aCanvas
	super drawOn: aCanvas.
	(self perform: ('face' , dieValue asString) asSymbol)
		do: [:aPoint | self drawDotOn: aCanvas at: aPoint]
\end{method}

Les capacités réflexives de \st sont utilisées dans la
dernière expression de cette méthode. Dessiner les points noirs
d'une face revient à itérer sur la collection 
%ajout
de coordonnées retournée par la méthode \ct{faceX} 
%ajout
(\ct{X} est issu de la variable d'instance \ct{dieValue}
correspondant au numéro de la face en cours),
en envoyant le message \ct{drawDotOn:at:} pour chacune de ces
coordonnées. Pour joindre la bonne méthode %martial: joindre plutot qu'appeler
\ct{faceX}, nous utilisons la méthode \mthind{Object}{perform:} qui
envoie le message construit à partir d'une chaîne de
caractères \lct{('face', dieValue asString) asSymbol}.
Cet usage de la méthode \ct{perform:} est très fréquent.
\index{réfléctivité}
\begin{method}{Dessiner un simple point noir sur une face}
DieMorph>>>drawDotOn: aCanvas at: aPoint
	aCanvas
		fillOval: (Rectangle
			center: self position + (self extent * aPoint)
			extent: self extent / 6)
		color: Color black
\end{method}
\ew{I would not use reflection to call faceX on p.234. A statically
  filled Dictionary would be more appropriate. Get the point set with
  "MyDict at: X".}

Puisque les coordonnées sont normées dans l'intervalle $[0{:}1]$,
elles sont mises à l'échelle des dimensions du dé avec 
\ct{self extent * aPoint}.

\dothis{Créez une instance de dé dans un espace de travail:}
\begin{code}{}
(DieMorph faces: 6) openInWorld.
\end{code}

Pour pouvoir modifier la valeur de la face visible, nous devons
créer un mutateur aussi pour \ct{dieValue}. 
%modification
Grâce à elle, nous pourrions, par exemple, afficher la face à 4
points depuis une nouvelle méthode de la classe en y écrivant
\ct{self dieValue: 4}.
%To change the displayed face, we create an accessor that we can use as \ct{myDie dieValue: 4}:

\begin{method}{Affecter un nombre à la valeur courante du dé}
DieMorph>>>dieValue: aNumber
	(aNumber isInteger
			and: [aNumber > 0]
			and: [aNumber <= faces])
		ifTrue:
			[dieValue := aNumber.
			self changed]
\end{method}

Nous allons utiliser le système d'animation pour faire défiler rapidement 
%ajout
et aléatoirement (avec le message \ct{atRandom}) toutes les faces du dé:
\index{Morphic!animation}
\begin{methods}{Animer le dé}
DieMorph>>>stepTime
	^ 100

DieMorph>>>step
	isStopped ifFalse: [self dieValue: (1 to: faces) atRandom]
\end{methods}
Désormais, notre dé ``roule''!

Pour démarrer ou arrêter  l'animation par un \clickbtn de souris, nous
utiliserons ce que nous avons préalablement appris sur les événements souris.
Nous activons la réception des événements de la souris et nous
décrivons notre gestion du \clickbtn dans la
méthode \ct{mouseDown:}.       
%ou \mthind{Morph}{mouseDown:}

\begin{methods}{Gérer les clics de souris pour démarrer et arrêter l'animation}
DieMorph>>>handlesMouseDown: anEvent
	^ true

DieMorph>>>mouseDown: anEvent
	anEvent redButtonPressed "click"
		ifTrue: [isStopped := isStopped not]
\end{methods}

%ajout
Maintenant notre dé ``roule'' ou se fige quand nous cliquons dessus.

% That's all for the essentials of Morphic!

% Most of the work on \ct{DieMorph} was done with an instance of it living in the environment; this is quite nice when to tweak programs.

%=================================================================
%\section{More about the canvas}
%\section{Encore quelques mots sur le canevas}
\section{Gros plan sur le canevas}

La méthode \ct{drawOn:} a un canevas, instance de
\clsindmain{Canvas}, comme unique argument;
le canevas est l'espace dans lequel le morph se dessine.
En utilisant les méthodes graphiques du canevas, vous êtes libre
de donner l'apparence que vous voulez à votre morph.
Si vous parcourez la hiérarchie d'héritage de la classe
\ct{Canvas}, vous constaterez plusieurs variantes. Par défaut, nous
utilisons \clsind{FormCanvas}. Cette classe et sa classe-mère
\ct{Canvas} contiennent les méthodes graphiques essentielles pour
dessiner des points, des lignes, des polygones, des rectangles, des
ellipses, du texte et des images avec rotation et changement d'échelle. 

%ajout de la note de bas de page
Vous pouvez aussi utiliser d'autres types de canevas pour obtenir, par
exemple, des méthodes supplémentaires ou encore, ajouter la
transparence ou l'anti-crénelage (ou
\emph{anti-aliasing}~\footnote{Ce rendu est utilisé pour atténuer
  ou éliminer l'effet escalier du aux pixels.}) aux morphs.  
Vous aurez besoin dans ces cas-là de canevas tels que
\clsind{AlphaBlendingCanvas} ou \clsind{BalloonCanvas}.
Pour obtenir un canevas différent dans la méthode \ct{drawOn:}
alors que son argument est une instance de \ct{FormCanvas}, vous devrez
court-circuiter le canevas courant par un autre. 
%martial: ou transformer un type de canevas en un autre.
%comme dans:
%But how can you obtain such a canvas in a \ct{drawOn:} method, when \ct{drawOn:} receives an instance of \ct{FormCanvas} as its argument?
%Fortunately, you can transform one kind of canvas into another.

\dothis{Redéfinissez \ct{drawOn:} de la classe \ct{DieMorph} pour
  utiliser un canevas semi-transparent:}

%martial: je force la nouvelle page tant que le titre est sur l'autre page
%\newpage
\begin{method}{Dessiner un dé semi-transparent}
DieMorph>>>drawOn: aCanvas
	| theCanvas |
	theCanvas := aCanvas asAlphaBlendingCanvas: 0.5.
	super drawOn: theCanvas.
	(self perform: ('face' , dieValue asString) asSymbol)
		do: [:aPoint | self drawDotOn: theCanvas at: aPoint]
\end{method}
\noindent

C'est tout ce dont nous avons besoin! 

\begin{figure}[ht]
	\centerline{\includegraphics[scale=0.7]{multiMorphs}}
	\caption{Le dé semi-transparent.\figlabel{multiMorphs}}
\end{figure}

% ON: This appears to be broken:
% Vous pouvez parcourir la méthode
% \mthind{Canvas}{asAlphaBlendingCanvas:} par curiosité.
% Pour profiter de l'anti-crénelage, vous pouvez aussi utiliser
% \clsind{BalloonCanvas} et changer la méthode d'affichage des points
% noirs de notre dé comme dans \mthsref{aadie}.

% \needlines{6}
% \begin{methods}[aadie]{Dessiner un dé avec anti-crénelage}
% DieMorph>>>drawOn: aCanvas
% 	| theCanvas |
% 	theCanvas := aCanvas asBalloonCanvas aaLevel: 3.
% 	super drawOn: aCanvas.
% 	(self perform: ('face' , dieValue asString) asSymbol)
% 		do: [:aPoint | self drawDotOn: theCanvas at: aPoint]

% DieMorph>>>drawDotOn: aCanvas at: aPoint
% 	aCanvas
% 		drawOval: (Rectangle
% 			center: self position + (self extent * aPoint)
% 			extent: self extent / 6)
% 		color: Color black
% 		borderWidth: 0
% 		borderColor: Color transparent
% \end{methods}

%=================================================================
\section{Résumé du chapitre}

Morphic comporte une librairie graphique grâce à laquelle les éléments de
l'interface graphique peuvent être composés dynamiquement.
Vous pouvez:
\begin{itemize}
  \item convertir un objet en \emph{morph} et l'afficher
    sur l'écran de \pharo, le \emph{world}, en lui envoyant le message
    \ct{asMorph openInWorld};
  \item faire apparaître le halo Morphic en \metaclickant
  sur un morph et manipuler ce morph
    grâce aux poignées du halo. Ces poignées ont des ballons
    d'aide (ou \emph{help balloons}) qui détaillent leur action;
  \item composer des morphs en les emboîtant les uns dans les autres,
    soit par glisser-déposer, soit par envoi du message \ct{addMorph:};
  \item dériver la classe d'un morph et redéfinir ses
    méthodes-clé telles que \ct{initialize} et \ct{drawOn:};
  \item contrôler la façon dont réagit un morph avec les
    événements issus de la souris et du clavier en redéfinissant les
    méthodes comme, par exemple, \ct{handlesMouseDown:} et
    \ct{handlesMouseOver:};
  \item animer un morph en définissant les méthodes \ct{step}
    (ce que fait le morph) et \ct{stepTime} (le nombre de
    millisecondes entre les pas);
  \item trouver différents morphs pré-définis pour
    l'interactivité de l'utilisateur comme
    \ct{PopUpMenu} ou \ct{UIManager};
% martial: ajout a signaler a andrew
  \item explorer les méthodes graphiques des différents canevas,
    instances de \ct{Canvas} ou de sous-classes,
    pour exploiter leurs ressources pour le dessin des morphs.
\end{itemize}

%=================================================================
\ifx\wholebook\relax\else\end{document}\fi
%=================================================================

%-----------------------------------------------------------------
