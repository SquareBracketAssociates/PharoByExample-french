% $Author: oscar $
% $Date: 2009-08-16 20:11:18 +0200 (Sun, 16 Aug 2009) $
% $Revision: 28482 $
% $Id: Seaside.tex 28482 2009-08-16 18:11:18Z oscar $

% HISTORY:
% 2007-10-29 - Oscar started chapter
% 2007-11-30 - Oscar first draft
% 2007-12-07 - Orla Greevy reviewed
% 2007-12-09 - Lukas Renggli reviewed
% 2008-01-11 - Andrew revised
% 2009-04-17 - Fabrizio Perin reviewed
% 2009-04-18 - Jorge Ressia reviewed
% 2009-05-06 - Oscar converted to Pharo; fixed review comments
% 2009-11-18 - Martial started the french translation
%
% 
% sync avec la version: 29667
%
%=================================================================
\ifx\wholebook\relax\else
% --------------------------------------------
% Lulu:
	\documentclass[a4paper,10pt,twoside]{book}
	\usepackage[
		papersize={6.13in,9.21in},
		hmargin={.75in,.75in},
		vmargin={.75in,1in},
		ignoreheadfoot
	]{geometry}
	\input{../common.tex}
	\pagestyle{headings}
	\setboolean{lulu}{true}
% --------------------------------------------
% A4:
%	\documentclass[a4paper,11pt,twoside]{book}
%	\input{../common.tex}
%	\usepackage{a4wide}
% --------------------------------------------
    \localizedgpath{{figures/lang/fr/}}%
    {{figures/lang/en/}}%
    {{figures/} {../figures/}}
	\begin{document}
	% \renewcommand{\nnbb}[2]{} % Disable editorial comments
	\sloppy
\fi
%=================================================================
\chapter{\arelire{Seaside par l'exemple}}
\chalabel{seaside}

%=================================================================

\ind{Seaside} est une bibliothèque destinée à la construction
d'applications web en Smalltalk. 
Elle a été initialement développée par Avi Bryant \index{Bryant, Avi} 
en 2002; 
\arevoir{une fois maîtrisé,} Seaside permet la création d'applications
web aussi facilement que se fait l'écriture d'applications classiques.
%once mastered, Seaside makes web applications almost as easy to write as desktop applications.

Deux des applications basées sur Seaside les plus connues sont 
 \ind{SqueakSource}\footnote{\url{http://SqueakSource.com}} et \ind{Dabble DB}\footnote{\url{http://DabbleDB.com}}.
Seaside n'est pas commun dans le sens qu'il est résolument orienté
objet: il n'y a aucune structure de type \emph{template} XHTML, aucun
contrôle de flux complexe par des pages web, ni même encodage de
l'état dans les URLs. Vous envoyez simplement des messages aux
objets. Quelle merveilleuse idée!

\section{Pourquoi avons-nous besoin de Seaside?}

Les applications web modernes essayent d'intéragir avec l'utilisateur
de la même façon que les applications de bureau: elles interrogent
l'utilisateur et celui-ci leur répond, habituellement en remplissant
un formulaire ou en cliquant sur un bouton.
Mais le web fonctionne d'une autre manière: le navigateur de
l'utilisateur fait des requêtes au serveur et le serveur répond avec
une nouvelle page web.
Dès lors les bibliothèques (ou \emph{frameworks}) destinées au
\ind{développement d'applications web} doivent contourner une foule de
problèmes, le principal étant la gestion du contrôle de flux ``inversé''.
% control flow
C'est pour cette raison que beaucoup d'applications web tentent
d'interdire \arelire{l'usage du bouton \backbtn (ou ``back'' en anglais, nommé
\emph{précédent(e)} sur certaines navigateurs)} du fait de la
difficulté de garder une trace de l'état d'une session.
\arelire{Diffuser des flux de contrôle significatifs
% non-trivial control flows
entre plusieurs pages web est souvent encombrant et plusieurs de ces
flux % control flows
peuvent être difficile à écrire.}
%Expressing non-trivial control flows across multiple web pages is often cumbersome, and multiple control flows can be difficult or impossible to express.

% Seaside is a component-based framework that uses ``\ind{continuations}''\footnote{A \emph{continuation} represents ``the rest of the computation'' at any point in a computation. In Smalltalk, a continuation is just an object that captures the current state of the computation, and which can be resumed at any point.} to keep track of multiple points in the control flow of web applications. Continuations are managed automatically by Seaside, so web developers do not even have to be aware of the underlying machinery. It just works.

\index{Seaside!\backtracking}
%\index{Seaside!backtracking state}
\index{Seaside!transactions}
\index{Seaside!composant}
%\index{Seaside!components}
Seaside est une bibliothèque orienté composant
% component-based 
qui allège le développement web de plusieurs façons.
Tout d'abord, le flux de contrôle
% conttrol flow
peut être exprimé naturellement en utilisant les envois de message.
\arevoir{Seaside garde une trace de la correspondance entre page web et 
un point précis dans l'exécution de l'application web.}
% Seaside keeps track of which web page corresponds to which point in
% the execution of the web application.
Donc le bouton \backbtn du navigateur web fonctionnement correctement.

Deuxièmement, la gestion de l'état est automatique. % 
%Second, state is managed for you.
En tant que développeur, vous aurez le choix permettre le
\backtracking (\ie le chaînage arrière) de l'état ou non, ainsi la
navigation en \backbtn{} annulera les effets de bord.
% backtracking of state, so that navigation ``back'' in time will undo side-effects.
Vous pouvez autrement utiliser le \arelire{support de transaction}
inclus dans Seaside pour empêcher les utilisateurs d'annuler les
effets de bord permanents lorsqu'ils utilisent le bouton \backbtn.
Vous n'avez pas à encoder l'information de l'état dans
l'URL\,---\,Seaside s'en occupe pour vous. 

Ensuite, les pages web sont générées depuis les composants imbriqués,
chacun pouvant avoir son propre flux de contrôle indépendant.
% control flow
Il n'y a pas de \emph{templates} XHTML\,---\,le code XHTML valide est
généré de façon programmatique via un simple protocole Smalltalk.
% generated programmatically using a simple Smalltalk protocol.
Seaside supporte les feuilles de style en cascade 
 (\ind{CSS}), ainsi le contenu et la mise en page sont clairement
 séparés.
\seeindex{feuille de style en cascade}{CSS} % REVOIR
%\seeindex{Cascading Style Sheets}{CSS}

Finalement, Seaside offre une interface web pratique pour le
développement en facilitant la programmation itérative, le débogage
interactif et la recompilation et l'extension des applications alors
que le serveur reste en activité.

%=================================================================
\section{Démarrer avec Seaside}

Télécharger le logiciel ``Seaside \subind{Seaside}{One-Click
  Experience}'' depuis le \subind{Seaside}{site
  web}\footnote{\url{http://seaside.st}} est la façon la plus simple
pour commencer avec Seaside.
Il s'agit d'une \arevoir{version empaqueté}
% prepackaged version 
de Seaside 2.8 pour \ind{Mac OS X}, \ind{Linux} and \ind{Windows}.
Le site web de Seaside liste aussi de nombreux liens vers des
ressources complémentaires dont de la documentation et des
tutoriels (en anglais).
Sachez, cependant, que Seaside a considérablement évolué durant ces
dernières années et toutes ces ressources disponibles ne se rapportent
pas nécessairement à la dernière version de Seaside.

% If you are feeling more adventurous, an alternative to the ``one-click'' image is to start with the latest \ind{\pharo web image}\footnote{\url{http://pharo-project.org/download}}, and install Seaside yourself by following the manual \subind{Seaside}{installation} instructions on the Seaside web site.
\mb{It should be nice to explain how to load it from
  Monticello. The reader should be able to do this at this step.}

Seaside inclut un serveur web: vous pouvez lancer ce serveur sur le
port 8080 en évaluant \clsind{WAKom} \ct{startOn: 8080} et le stopper
en évaluant \ct{WAKom stop}.
Dans l'installation par défaut, le \subind{Seaside}{compte
  administrateur} (en anglais, \emph{administrator login}) est
\lct{admin} et le mot de passe (ou \emph{password}) est \lct{seaside}.
Pour les changer, évaluez: 
 \clsind{WADispatcherEditor} \ct{initialize}.
Ceci affichera une fenêtre de dialogue pour la saisie d'un nouveau nom
et d'un nouveau mot de passe. 

\begin{figure}[tbh]
\begin{center}
\includegraphics[width=\textwidth]{seasideStartup}
\caption{La page de démarrage de Seaside.}
\figlabel{seasideStartup}
\end{center}
\end{figure}

\dothis{Démarrez le serveur Seaside et rendez-vous sur la page
  \url{http://localhost:8080/seaside/} avec votre navigateur favori.}

\noindent
Vous devriez voir une page web semblable à celle de \figref{seasideStartup}.

\noindent
\dothis{Naviguez vers la page \lct{examples{\go}counter} (voir \figref{counter}).}


\begin{figure}[htb]
\begin{center}
\includegraphics[width=0.8\textwidth]{counter}
\caption{La démo du compteur avec l'application ``counter''.}
\figlabel{counter}
\end{center}
\end{figure}

\noindent
Cette page est une petite application Seaside nommé
\subind{Seaside}{counter}: elle affiche un
compteur qui peut être incrémenté et décrementé en cliquant sur les
liens \link{++} et \link{--\,--}.

\noindent
\dothis{Amusez-vous un peu avec l'application ``counter'' en cliquant sur
  ces liens.
Utiliser le bouton \backbtn du navigateur pour revenir à l'état
précédent et cliquer ensuite sur \link{++}.
Remarquez comment le compteur est correctement incrémenté depuis
l'état actuellement affiché au lieu d'être incrémenté depuis l'état
dans lequel le compteur était lorsque vous aviez commencé à utiliser
le bouton \backbtn.}

Notez la 
% \subind{Seaside}{toolbar}
\subind{Seaside}{\toolbar} en bas de la page web dans 
 \figref{seasideStartup}.
Seaside supporte la notion de ``sessions'' pour suivre l'état de
l'application pour différents utilisateurs.
\button{New Session} démarre une nouvelle session sur l'application
``counter''.
\button{Configure} vous permet de 
de configurer les paramètres de votre application via une interface
web (pour fermer la vue \button{Configure}, cliquez sur le \link{x}
dans le côté supérieur droit de la page).
\button{Toggle Halos} propose d'explorer l'état de l'application
lancée sur le serveur Seaside.
\button{Profiler} et \button{Memory} offre une information détaillée 
à propos des performances à l'exécution de l'application.
\button{XHTML} peut être utilisé pour valider la page web générée;
ce lien ne fonctionne que lorsque la page est accessible depuis
Internet car il utilise le service de validation W3C.
\index{Seaside!halos}


Les applications Seaside sont construites à l'aide de
\arevoir{``composants'' connectables}.
% pluggable ``components''.
Ces composants sont en réalité des objets Smalltalk ordinaires.
Leur seule particularité est qu'elles doivent être des instances des
classes héritées de la classe de la bibliothèque Seaside appelée
\ct{WAComponent}.
Nous pouvons explorer les composants et leurs classes dans l'image
Pharo ou directement, depuis l'interface web, en utilisant les halos.


\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{counterHalos}
\caption{Les halos dans Seaside.}
\figlabel{counterHalos}
\end{center}
\end{figure}

\dothis{Sélectionnez \button{Toggle Halos}. Vous devriez voir une 
page web comme celle de \figref{counterHalos}.
Dans le coin supérieur gauche, le texte \ct{WACounter} nous indique le
nom de la classe du composant Seaside qui implémente le comportement
de cette page. \arelire{À côté de ce texte,} il y trois icônes
cliquables.
Le premier, représentant un crayon, active un navigateur de classes
Seaside sur la classe \ct{WACounter}. Le second icône avec une loupe
ouvre un inspecteur d'objets sur l'instance \ct{WACounter} en cours
d'activité.
Le dernier, sous la forme de cercles colorés, affiche la feuille de
style \ind{CSS} de ce composant.
Dans le coin supérieur droit, le 
 \link{R} et le  \link{S} vous laissent basculer entre la vue du
 code rendue et celle du code source.
Essayez donc en cliquant sur ces différents liens.
Remarquez que les liens \link{++} et \link{--} sont aussi actifs dans
la vue du code source.
\mb{More and more browsers, Safari/Firefox, provide pretty-print code view!}
\arevoir{Observez d'ailleurs le formattage en couleurs du code source fourni
par les halos Seaside \aretirer{avec} la vue du code source non-formattée fournie
par votre navigateur.}}

Le navigateur de classes Seaside et l'inspecteur d'objets peuvent être
très pratiques lorsque le serveur tourne sur un autre ordinateur,
surtout si celui-ci n'a pas d'écran ou qu'il se trouve dans un lieu
distant.
Néanmoins, lorsque vous commencez à développer une application
Seaside, le serveur sera lancé localement et il sera plus facile
d'utiliser les outils de développement standards disponibles dans
l'image \pharo dans laquelle votre serveur est en activité.
 
\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.7\textwidth]{haltingCounter}
\caption{Suspendre l'application ``counter''.}
\figlabel{haltingCounter}
\end{center}
\end{figure}

\dothis{Cliquez sur le lien 
 Object Inspector représenté par l'icône de loupe du halo
pour ouvrir un inspecteur d'objets sur \arelire{l'objet-compteur
  Smalltalk} et évaluez \ct{self halt} (en cliquant sur 
\button{doit}). % REVOIR
La page web s'arrêtera de charger. Allez maintenant dans votre image
Seaside. Vous devriez voir une fenêtre \arevoir{de pré-débogueur} % ATTENDRE changement dans le debugger de Pharo?
affichant un objet \ct{WACounter} exécutant un \ct{halt} (voir
\figref{haltingCounter}).
Examinez cette exécution dans le débogueur
% ajout vf - rappel
en cliquant sur la première ligne de la pile,
puis cliquez sur \button{Proceed}.
Retourner dans votre navigateur web et notez que l'application ``counter''
fonctionne à nouveau.}

Les composants Seaside peuvent être instanciés plusieurs fois et dans
différents contextes.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{multiCounterHalos}
\caption{Les sous-composants indépendants.}
\figlabel{multiCounterHalos}
\end{center}
\end{figure}

\dothis{Allez sur la page
  \url{http://localhost:8080/seaside/examples/multicounter avec votre
    navigateur web}.
Vous verrez une application construite grâce à un certain nombre
d'instances indépendantes du composant ``counter''.
Incrémentez et décrémentez plusieurs de ces compteurs.
Vérifiez que ces compteurs se comportent correctement même lorsque
vous utilisez le bouton \backbtn.
Activez les halos pour voir que la structure de l'application est
faite de composants imbriqués.
Utilisez le navigateur de classes Seaside pour visualiser
l'implémentation de \ct{WAMultiCounter}.
Vous devriez voir trois méthodes du côté classe (\ct{canBeRoot},
\ct{description} et \ct{initialize}) ainsi que trois méthodes du côté
instance (\ct{children}, \ct{initialize} et \ct{renderContentOn:}).
\arelire{Remarquez qu'une application est simplement un composant
qui peut être à la racine de la hiérarchie de composants; cette
possibilité de devenir racine, et donc application, est indiquée en
définissant une méthode de classe \ct{canBeRoot} (en anglais, ``peut
être racine'') pour qu'elle réponde
\ct{true}.}}
\index{Seaside!multicounter}

Vous pouvez utiliser l'interface web Seaside, copier ou enlever une
ou plusieurs applications (\ie les composants racines). Essayez de
changer la configuration comme suit.

\dothis{Allez sur \url{http://localhost:8080/seaside/config} avec
  votre navigateur.
Saisissez le \emph{login} et le mot de passe 
 (\ct{admin} et \ct{seaside} par défaut).
Sélectionnez 
 \link{Configure} à côté de ``examples''.
Sous l'entête  ``Add entry point'' (\ie{} \emph{ajouter un point
  d'entrée}),
saisissez le nouveau nom ``counter2'' pour le type \emph{Application} 
et cliquez sun le bouton \button{Add} comme le montre \figref{counter2}.
Sur  l'écran suivant, choisissez \clsind{WACounter} comme composant racine 
 \emph{Root Component} puis, cliquez sur \button{Save} et enfin,
 \button{Close}.
Nous avons maintenant un nouveau compteur installé à l'URL
 \url{http://localhost:8080/seaside/examples/counter2}.
Utilisez la même interface de configuration pour enlever ce point
d'entrée.}
\index{Seaside!configuration}


\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{counter2}
\caption{Configurer une nouvelle application.}
\figlabel{counter2}
\end{center}
\end{figure}

Seaside fonctionne dans deux modes: soit le mode de développement dit 
\emph{development} qui le mode dans lequel nous venons de travailler,
soit dans le mode de diffusion appelé \emph{deployment} dans lequel la
\toolbar n'est pas accessible. 
\index{Seaside!mode!deployment}
\index{Seaside!mode!development}
Vous pouvez mettre Seaside dans le mode \emph{deployment} en utilisant
soit la page de configuration\,---\,pour cela naviguer jusqu'à
l'entrée de l'application et cliquez sur le lien \link{Configure}\,---\,soit
% \ab{How?  I couldn't find this}
cliquez directement sur le bouton  \button{Configure} dans la
\toolbar.
Dans chacun de ces cas, mettez le mode \emph{deployment} à
\emph{true}.
Notez que ceci n'affecte que les nouvelles sessions.
Vous pouvez aussi activer ce mode en évaluant 
\clsind{WAGlobalConfiguration} \lct{setDeploymentMode}, et
inversement, réactiver le mode \emph{development} en évaluant
\ct{WAGlobalConfiguration setDevelopmentMode}.
\index{Seaside!deployment mode}
\index{Seaside!development mode}

En fait, la page web de configuration n'est qu'une autre application
Seaside. Ainsi elle peut aussi être pilotée depuis la page de
configuration. Si vous enlevez l'application
``config'', vous pouvez toujours la réinstaller en évaluant
\clsind{WADispatcherEditor} \ct{initialize}.

%=================================================================
\section{Les composants Seaside}
\seclabel{components}
\seeindex{Seaside!component}{Seaside, composant}

%\ab{This section was too long\,---\,18 pages.  It also contained several self-references (``see section 1.3''). So I broke into smaller sections, by promoting some of the subsections and subsubsections.}

Comme nous l'avons mentionné précédemment, les \arelire{applications
  Seaside sont bâties sur une aggrégation de
  \subind{Seaside}{composants}\,---\,en anglais,
  \emph{component}}.
%As we mentioned in the previous section, Seaside applications are built out of \emph{\subind{Seaside}{components}.}
Regardons comment Seaside fonctionne en programmant le composant
``hello world''.
%\emph{Hello World}.

Tout composant Seaside doit hérité directement ou indirectement de
\clsind{WAComponent} comme le montre la \figref{WACounter}.

\dothis{Définissez une sous-classe de \ct{WAComponent} appelée
  \ct{HelloWorld}.}

Les composants doivent savoir comment faire \arelire{leur propre rendu
  visuel}.
Ceci est fait habituellement en implémentant la méthode
\mthind{WAPresenter}{renderContentOn:} qui prend comme argument une
instance de  \clsind{WAHtmlCanvas}; ce dernier sait comment faire le
rendu en XHTML.
\index{Seaside!rendu}
%\index{Seaside!rendering}

\dothis{Implémentez la méthode suivante et mettez-la dans le protocole
  \prot{rendering}:}
\needlines{2}
\begin{code}{}
WAHelloWorld>>>renderContentOn: html
	html text: 'hello world'
\end{code}

\noindent
Nous devons dire maintenant à Seaside que ce composant est destiné à
être autonome
% ajout vf - plus clair
\arelire{(donc une possible racine de l'arborescence de composants).} % CHANGE

\dothis{Écrivez la méthode de classe suivante pour \ct{WAHelloWorld}.}

\begin{code}{}
WAHelloWorld class>>>canBeRoot
	^ true
\end{code}

\noindent
Nous avons fini!

\dothis{Pointez votre navigateur web
  \url{http://localhost:8080/seaside/config}, ajoutez une nouvelle
  entrée qui vous appelerez ``hello'' et choisissez \ct{WAHelloWorld}
  comme composant racine.}
Pointez maintenant votre navigateur 
à l'URL \url{http://localhost:8080/seaside/hello}.
Vous y êtes! Vous devriez voir une page web comme sur
 \figref{WAHelloWorld}.

\begin{figure}[htb]
\begin{center}
\includegraphics[width=\textwidth]{WAHelloWorld}
\caption{``hello world'' en Seaside.}
\figlabel{WAHelloWorld}
\end{center}
\end{figure}

%-----------------------------------------------------------------
\subsection{Le \backtracking d'état et l'application ``counter''}
\seeindex{Seaside!chaînage arrière}{Seaside!\backtracking} % REVOIR
%{Simple and nested components}

L'application ``counter'' est seulement un peu plus compliquée que
l'application ``hello world''.
\seclabel{backtracking}

\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{WACounter}
\caption{La classe \ct{WACounter} implémentant l'application
  ``counter''. Les méthodes avec les noms soulignés sont des méthodes
  de classe; les autres sont des méthodes d'instance.}
\figlabel{WACounter}
\end{center}
\end{figure}

La classe  \clsind{WACounter} est une \arelire{application autonome},
ainsi \ct{WACounter class} doit répondre \ct{true} au message 
 \mthind{WAComponent class}{canBeRoot}.
Elle doit aussi être enregistrée en tant qu'application; sa méthode de
classe \ct{initialize} est utilisée pour cela (voir
\figref{WACounter}).

\ct{WACounter} définit deux méthodes, \ct{increase} et \ct{decrease},
qui seront déclenchés par les liens \link{++} et \link{--\,--} sur la
page web.
Cette classe définit aussi une variable d'instance 
 \ct{count} pour enregistrer l'état du compteur.
Cependant, nous voulons aussi que Seaside synchronise le compteur avec
\arelire{la page dans le navigateur web}:
% browser page:
lorsque l'utilisateur clique sur le bouton \backbtn{} de son
navigateur web, nous voulons que Seaside rappelle l'état de l'objet
\ct{WACounter}.
%when the user clicks on the browser's ``back'' button, we want seaside to ``backtrack'' the state of the \ct{WACounter} object.
Seaside inclut un mécanisme général pour le chaînage arrière ou
\backtracking mais chaque application doit signaler à Seaside quelle
partie de son état doit être suivie.

Un composant permet le \backtracking en implémentant la méthode
d'instance \ct{states}:
% \ab{note that xspace messes up again, by inserting a space at the start of this line}
\ct{states} devrait répondre un tableau contenant tous les objets à
suivre. Dans notre cas, l'objet \ct{WACounter} s'ajoute lui-même à la
table Seaside des objets à suivre pour le \backtracking en retournant
\ct{Array with: self}.

\paragraph{\emph{Avertissement.}}
Il y a un point subtil mais important à surveiller lorsque vous
déclarez des objets pour le \backtracking.
Seaside suit l'état en faisant un \arelire{\emph{copie}}
% \emph{copy} % REVOIR - martial - nom de méthode??
de tous les objets déclarés dans le tableau \ct{states}.
Ceci se fait via l'objet
 \clsind{WASnapshot}; \ct{WASnapshot} est une sous-classe
de \clsind{IdentityDictionary} qui enregistre les objets à être suivis
en tant que clés et des \arelire{copies superficielles 
% ajout vf
(\ie{} en \ct{shallowCopy})} en tant que valeurs.
\arelire{S'il y a \backtracking{} de l'état d'une application vers une
  capture particulière de l'état, l'état de chaque objet entré dans ce
dictionnaire est écrasé par la copie sauvegardée dans la capture.}
%If the state of an application is backtracked to a particular snapshot, the state of each object entered into the snapshot dictionary is overwritten by the copy saved in the snapshot.

\tradalert{martial}{revoir ce paragraphe.}

Voilà le point critique:
Dans le cas de \ct{WACounter}, vous pourriez vous dire que l'état à
être suivi est une valeur numérique\,---\,la valeur de la variable
d'instance \ct{count}.
Cependant, la méthode \ct{states} répondant \ct{Array with: count} ne
marche pas.
%However, having the \ct{states} method answer \ct{Array with: count}
%won't work. 
Ceci est du au fait que l'objet \ct{count} est un entier et un entier
est immuable.
%This is because the object named by \ct{count} is an integer, and integers are immutable.
Les méthodes \ct{increase} et \ct{decrease} ne changent pas l'état de
l'objet \ct{0} en \ct{1} ou l'objet \ct{3} en \ct{2}.
Au lieu de ça, elles associent \ct{count} à un autre entier:
%Instead, they make \ct{count} name a different integer: 
chaque fois que le compteur est incrémenté ou décrémenté, l'objet
nommé \ct{count} est \emph{remplacé} par un autre.
C'est pourquoi \ct{WACounter>>>states} doit retourner \ct{Array with: self}.
Lorsque l'état d'un objet \mbox{\ct{WACounter}} est remplacé par un
état précédent, la \emph{valeur} de chacune des variables d'instance
dans l'objet est remplacée par une valeur précédente; ceci remplace
correctement la valeur actuelle de \ct{count} par une valeur
précédente.
\index{Seaside!\backtracking} % CHANGE
%\index{Seaside!backtracking state}
\index{WAPresenter!states@\ct{states}}

\section{Le rendu XHTML}

Le but d'une application web est la création, ou ``rendu'', de pages
web.
Comme nous l'avons dit dans \secref{components}, chaque composant
Seaside est responsable de son propre rendu.
% REVOIR - ajout vf (cette phrase n'existe pas dans PBE
\arelire{En anglais, nous utilisons le terme \emph{rendering} que nous
  retrouvons en tant que nom de protocole pour les méthodes de rendu.}
Commençons notre exploration du rendu par l'exemple du composant ``counter''.
% by seeing how the counter component renders itself.

\subsection{Le rendu de l'application ``counter''}

Le rendu de l'application ``counter'' est relativement simple; le code
est visible sur \figref{WACounter}.
La valeur actuelle du compteur est affichée comme une entête (ou
\emph{heading}) XHTML et les opérations d'incrémentation et de
décrémentation sont implémentées sous la forme de lien HTML (ou
\emph{anchor}) \arelire{avec des \callbacks (\ie{} des fonctions
  de rappel) sous la forme de \emph{blocks} qui enverront soit
  \ct{increase} soit \ct{decrease} à l'objet ``counter''}.
%The current value of the counter is displayed as an XHTML heading, and the increment and decrement operations are implemented as html anchors (that is, links) with callbacks to blocks that will send \ct{increase} and \ct{decrease} to the counter object.
Avant de voir plus en détails le protocole \prot{rendering}, regardons
un peu le cas de l'application ``\subind{Seaside}{multicounter}''

\subsection{De la version ``counter'' à la version ``multicounter''}

\Figref{WAMultiCounter} montre \ct{WAMultiCounter} qui est
aussi une application
% ajout - vf
de compteurs multiples. Elle est 
autonome; elle surcharge donc la méthode de
classe \mthind{WAComponent class}{canBeRoot} pour qu'elle réponde
\ct{true}.
De plus, c'est un composant \emph{composite}. Seaside a besoin d'une
déclaration de ses composants enfants faite via la méthode
\ct{children} qui répond un tableau de tous les composants que
l'application contient.
Le rendu de ce composant se fait en faisant le rendu de ces
sous-composants séparés par une barre horizontale.
En dehors des méthodes d'instance et de classe destinées à
l'initialisation, il n'y a rien d'autre pour faire l'application
``multicounter''!

\begin{figure}[bht]
\begin{center}
\includegraphics[width=\textwidth]{WAMultiCounter}
\caption{L'application de compteurs multiples ``multicounter'' basée
  sur la classe WAMultiCounter.}
\figlabel{WAMultiCounter}
\end{center}
\end{figure}

%-----------------------------------------------------------------
\subsection{Quelques mots encore à propos du rendu XHTML}

Comme nous l'avons vu sur ces exemples, Seaside n'utilise pas de
patrons ou \emph{templates} pour générer les pages web.
Au lieu de ça, il génère le code XHTML de manière programmatique.
Tout composant Seaside devrait surcharger la méthode
 \mthind{WAPresenter}{renderContentOn:}. C'est ce message qui sera
 envoyé par Seaside pour chaque composant nécessitant d'être rendu.
 \ct{renderContentOn:} a un argument qui est un
 \seeindex{canevas}{canevas HTML} \emphind{canevas HTML}
% ajout -vf
 (en anglais, \emph{canvas}\seeindex{canvas}{canevas HTML}) 
sur lequel le composant devra être rendu.
Par convention, le paramètre de canevas HTML est appelé 
 \ct{html}.
Un canevas HTML est analogue au canevas graphique utilisé par Morphic
(et la plupart des autres bibliothèques graphiques) pour
\arevoir{abstraire le graphisme des détails dépendants des
  périphériques}.
% An html canvas is analogous to the graphics canvas used by Morphic (and most other drawing frameworks) to abstract away from the device-dependent details of drawing.
 
Voici quelques-unes des méthodes de rendu les plus simples:
\begin{code}{}
html text: 'hello world'.  "rendu du texte ordinaire"
html html: '&ndash;'.     "rendu d'un !élément! XHTML"
html render: 1.              "rendu d'un object"
\end{code}

Le message \ct{render: anyObject} 
% ajout - vf
(ou \lct{anyObject} défini un objet quelconque)
peut être envoyé à un canevas HTML
pour faire le rendu de \ct{anyObject}; 
ce message est normalement utilisé pour faire le rendu de
sous-composants.
Le message \ct{renderContentOn:} sera alors envoyé à \lct{anyObject}.
C'est ce qu'il se produit avec l'application ``multicounter''
 (voir \figref{WAMultiCounter}).

\subsection{Utiliser les \brushes}
\seclabel{brushes}
\seeindex{\brushes}{\brush}
Un canevas offre \arelire{un grand nombre de \brushes (\ie{}
  des pinceaux)} utilisés pour le rendu d'un contenu sur le canevas.
Il y a des \brushes\,---\,au singulier, \brush\,---\,pour toutes
sortes d'éléments XHTML: des paragraphes, des tables, des listes\ldots
Pour voir l'ensemble des \brushes et des méthodes utilitaires
associées, vous devez naviguer avec votre Browser dans la classe
\clsind{WACanvas} et ses sous-classes. 
%To see the full protocol of brushes and convenience methods, you should browse the class \clsind{WACanvas} and its subclasses.
L'argument de \ct{renderContentOn:} est en fait une instance de la
sous-classe \clsind{WARenderCanvas}.

Nous avons déjà vu le \brush suivant dans les exemples ``counter'' et ``multicounter'':
\needlines{2}
\begin{code}{}
html horizontalRule.
\end{code}

\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{RenderingDemo}
\caption{La démo des rendus: ``Rendering Demo''.}
\figlabel{RenderingDemo}
\end{center}
\end{figure}

Dans \figref{RenderingDemo}, nous pouvons voir la sortie de beaucoup
de \brushes simples inclus dans Seaside\footnote{Le code source de
  \mthref{renderdemo} se trouve dans le paquetage \ct{PBE-SeasideDemo}
  dans le projet
  \url{http://www.squeaksource.com/PharoByExample}.
  \frsays{\arevoir{NdT: Les textes
  ont été traduits dans le présent ouvrage. Attendez-vous à ce que la
  version du code d'exemple que vous téléchargerez soit en anglais.}}{}}.
% REVOIR une version francaise du repository de code à prévoir!?!
Le composant racine \ct{SeasideDemo} \arelire{fait simplement le rendu
  de} ses sous-composants qui sont instances de
\ct{SeasideHtmlDemo}, \ct{SeasideFormDemo}, \ct{SeasideEditCallDemo}
et \ct{SeasideDialogDemo}, comme le montre \tmthref{renderdemo}.

\needspace{7ex}
\localcode{renderdemo}

\noindent
Rappelez vous qu'un composant racine doit toujours déclarer ses
enfants sinon Seaside refusera d'en faire le rendu.
\begin{code}{}
SeasideDemo>>>children
	^ { htmlDemo . formDemo . editDemo . dialogDemo }
\end{code}

Remarquez qu'il y a deux différentes façons d'instancier le \brush
d'entête nommé \ct{heading}:
soit vous placez le texte directement en argument du message
\ct{heading:}
% ajout - vf
envoyé au canevas,
soit vous instanciez le \brush via l'envoi de \ct{heading} puis 
vous envoyez une cascade de messages au \brush{} en question pour
définir ses propriétés et en faire le rendu.
% and then to send a cascade of messages to the brush to set its
% properties and render it.
Beaucoup des \brushes disponibles peuvent être utilisés de ces deux
manières.

\important{Si vous envoyez à un \brush une \ind{cascade} de messages
  incluant \mthind{WABrush}{with:}, \ct{with:} doit être le message
  \emph{final}.}
L'association du contenu au \brush{} et le rendu de ce dernier est
fait par \ct{with:}.

Dans \mthref{renderdemo}, la première entête est de niveau
(ou \emph{level}) 1 puisque c'est la valeur par défaut.
Nous mettons explicitement le niveau de la seconde entête à 2.
Le sous-composant est rendu sous la forme de \emph{div} XHTML avec
``subcomponent'' comme nom de classe \ind{CSS} (pour en savoir plus
sur les feuilles de style CSS, rendez-vous à \secref{css}).
Notez aussi que l'argument du message à mots-clés \ct{with:} n'a pas
besoin d'être une chaîne de caractères litéral: ce peut être un autre
composant ou même\,---\,comme dans l'exemple suivant\,---\,un
\emph{block} contenant \arevoir{des actions de rendu appliquées plus tard}.
%block containing further rendering actions.

Le composant \ct{SeasideHtmlDemo} fait la démonstration des \brushes{}
les plus basiques.
Le code devrait parler de lui-même~\footnote{NdT: les \emph{div}{s} et
  les \emph{span}{s} sont des éléments HTML\/XHTML et ``link with
  callback'' peut se traduire par ``lien avec fonction de rappel''.}.
%Most of the code should be self-explanatory.


\begin{code}{}
SeasideHtmlDemo>>>renderContentOn: html 
	self renderParagraphsOn: html.
	self renderListsAndTablesOn: html.
	self renderDivsAndSpansOn: html.
	self renderLinkWithCallbackOn: html
\end{code}

La division de longue méthode de rendu en plusieurs méthodes adjointes
est une pratique commune: c'est ce que nous avons fait ici.
%It is common practice to break up long rendering methods into many helper methods, as we have done here.

\important{Ne mettez pas tout votre code de rendu dans une seule
  méthode.
Séparez-le dans différentes méthodes adjointes dont le nom est de la
forme \ct{render*On:}. Toutes les méthodes de rendu vont dans le
protocole \prot{rendering}.
N'envoyez pas \ct{renderContentOn:} depuis votre propre code: utilisez
plutôt \ct{render:}.}

Observons le code suivant.
La première méthode, \ct{SeasideHtmlDemo>>>renderParagraphsOn:}, vous
montre comment générer des paragraphes XHTML, du texte ordinaire ou en
emphase (\ie{} en italique) et des images.
Remarquez qu'en Seaside les éléments simples sont rendus en spécifiant
le texte qu'ils contiennent directement alors que les éléments
complexes sont spécifiés dans des \emph{blocks}.
C'est une convention simple pour vous aider à structurer votre code de
rendu.

\localcode{renderParagraphs}

La méthode suivante, \ct{SeasideHtmlDemo>>>renderListsAndTablesOn:},
vous montre comment générer des listes et des tables.
\arelire{Une table utilise deux niveaux de \emph{blocks} pour afficher chacune
de ses lignes et les cellules que ces dernières contiennent.}
%A table uses two levels of blocks to display each of its rows and the cells within the rows.

\localcode{renderListsAndTables}

Nous pouvons voir sur l'exemple suivant comment nous pouvons spécifier
les éléments \emph{div}s et \emph{span}s avec leurs attributs CSS
\emph{class} ou \emph{id}.
Bien sûr, les messages \ct{class:} et \ct{id:} peuvent être aussi
envoyés à d'autres \brushes, et pas seulement aux \emph{div}s et aux
\emph{span}s.
La méthode \ct{SeasideDemoWidget>>>style} définit comment ces éléments
XHTML devraient être affichés (voir \secref{css}).

\localcode{renderDivsAndSpans}

Finalement nous avons un simple exemple d'un lien, crée en liant un
simple \subind{Seaside}{\callback} (ou fonction de rappel) à une
``ancre'' (en anglais, ``\emph{anchor}'').
Cliquez sur le lien aura pour conséquence de basculer le texte entre
``true'' et ``false'' en faisant varier la variable d'instance
booléenne \ct{toggleValue}.
%by toggling the instance variable \ct{toggleValue}.

\needlines{3}
\localcode{renderLinkWithCallback}

\important{Remarquez que les actions ne devraient apparaître que dans les
\callbacks. Le code exécuté durant le rendu ne devrait pas changer
l'état de l'application!}
%Note that actions should appear only in callbacks.
%The code executed while rendering should not change the state of the
%application!

%-----------------------------------------------------------------
\subsection{Les formulaires}
\seeindex{Seaside!\emph{form}}{Seaside, formulaire}

Les formulaires ou \emph{forms} sont simplement rendus \arelire{comme dans les
autres exemples que nous avons vus précédemment.
Voici le code pour le composant \ct{SeasideFormDemo} sur
\figref{RenderingDemo}}.

\index{Seaside!formulaire}
%\index{Seaside!XHTML forms} % REVOIR IMPORTANT Seaside!XHTML!form

\begin{code}{} % REVOIR
SeasideFormDemo>>>renderContentOn: html
	| radioGroup |
	html heading: heading.
	html form: [
		html span: 'Heading: '.
		html textInput on: #heading of: self.
		html select
			list: self colors;
			on: #color of: self.
		radioGroup := html radioGroup.
		html text: 'Radio on:'.
		radioGroup radioButton
			selected: radioOn;
			callback: [radioOn := true].
		html text: 'off:'.
		radioGroup radioButton
			selected: radioOn not;
			callback: [radioOn := false].
		html checkbox on: #checked of: self.
		html submitButton
			text: 'done' ]
\end{code}{}

En raison de sa nature complexe, le formulaire est rendu en utilisant
un \emph{block}.
\arevoir{%
Notez que tous les changements d'état se produit dans les
\callbacks et non dans les parties de code liées au rendu.} % REVOIR - martial - déjà dit plus haut dans \important
%Note that all the state changes happen in the callbacks, not as part of the rendering.

Le message \mthind{WAAnchorTag}{on:of:} est une particularité Seaside
qui mérite une explication.
Dans l'exemple, ce message est utilisé pour attacher un zone de saisie
de texte à la variable \ct{heading}.
Les ancres (\ie{} les liens) et les boutons prennent en charge, eux
aussi, ce message.
Le premier argument est le nom d'une variable d'instance pour laquelle
des méthodes d'accès
ont été définies; le second argument est l'objet auquel appartient
cette variable d'instance.
Les messages accesseur et mutateur avec la convention de noms usuelle
(\ie{} \ct{heading} et \ct{heading:} respectivement) 
doivent être compris par l'objet.
Dans le cas présent d'une zone de saisie de texte, 
\arelire{cela nous évite le problème d'avoir à définir un \callback
  pour mettre à jour le champ de saisie et d'avoir à attacher le
  contenu par défaut de l'entrée à la valeur actuelle de la variable
  d'instance.}
%this saves us the trouble of having to define a callback that updates the field as well as having to bind the default contents of the html input field to the current value of the instance variable.
En utilisant \ct{on: #heading of: self}, la variable \ct{heading} est
mise à jour automatiquement à chaque fois l'utilisateur \arevoir{change le
texte de la zone de saisie.}
%variable is updated automatically whenever the user updates the text input field.

Le même message est utilisé deux fois encore dans cet exemple pour
mettre à jour la variable \ct{color} en fonction de la sélection de la
couleur dans le formulaire HTML et pour attacher l'état de la case à
cocher (ou \emph{checkbox}) à la variable \ct{checked}.
Vous pouvez trouver beaucoup d'autres exemples dans les tests
fonctionnels de Seaside.
Jetez un \oe il à la \arelire{catégorie
  \scat{Seaside-Tests-Functional}} % REVOIR - martial - ne devrait-on
                                % pas parler de paquetage/catégorie et
                                % non catégorie seule depuis Pharo
                                % (besoin d'une image One-Click
                                % Experience en Pharo plus récent)
ou allez simplement sur la page
\url{http://localhost:8080/seaside/tests/alltests} avec votre
navigateur web.
Sélectionnez \menu{WAInputTest} 
% ajout vf
\arelire{(cliquez sur le bouton \button{Restart} si vous avez
  désactivé le support JavaScript de votre navigateur web)} % CHANGE -
                                % ajout vf - automatique si JavaScript
 pour voir la plupart des types d'éléments de formulaire.

N'oubliez pas que, si vous activez le bouton \button{Toggle Halos} de
la \toolbar, vous pouvez naviguer dans le code source des exemples
directement via le navigateur de classes Seaside. 

%-----------------------------------------------------------------
\section{Les feuilles de style CSS}
\seclabel{css}

%\ab{I think that it just needs a few paragraphs telling the reader the key ideas behind CSS, and the new terminology that the CSS folks introduce, before going in to the details of how you define their "thingies".  Now I have forgotten what they call their "thingies" --- I know that there are effectively paragraph styles (divs) and character styles (spans), but I've forgotten what they call them.  So, I think that the text needs to tell the reader, for each thingie, (1) the CSS concept behind the thingie, (2) what it looks like in a CSS style sheet , (3) what it looks like in html, and (4) how to do it in Seaside.   Maybe (3) can be omitted, because it's not needed to use Seaside.}
% \on{I think we do most of that already.}

Les feuilles de style en cascade ou 
\emph{Cascading Style
  Sheets}\footnote{\url{http://www.w3.org/Style/CSS/}} abrégé en
 \ind{CSS} sont devenues une technique standard pour séparer le style
 du contenu des applications web.
Seaside utilise les CSS pour éviter l'encombrement de votre code de
rendu par la mise en page.

Vous pouvez mettre un feuille de style CSS pour vos composants web en
définissant la méthode \ct{style} qui devrait retourner les règles CSS
de ce composant sous forme d'une chaîne de caractères.
Les styles de tous les composants affichés sur un page web sont
assemblés. Ainsi chaque composant peut avoir son propre style.
Une meilleur approche serait de définir une classe abstraite pour
votre application web définissant un style commun pour toutes ses
sous-classes. % martial - ( un trait aussi )

En réalité, il est préférable de définir les feuilles de style des
applications déployées comme des fichiers externes.
Ce faisant, l'apparence du composant est complétement séparée de sa
fonctionnalité\,---\,regardez la classe \clsind{WAFileLibrary} qui
permet de servir des fichiers statiques sans le besoin d'un autre
serveur autonome
% ajout - vf
dédié à ces fichiers.

Si vous n'êtes pas déjà familier avec les CSS, veuillez lire
\arelire{la brève introduction aux feuilles de style CSS}.
%If you already are familiar with CSS, then that's all you need to know.
%Otherwise, read on for a very brief introduction to CSS.

\arelire{En utilisant les CSS, vous définirez différentes classes aux éléments
de texte et de paragraphe de vos pages web et vous déclarerez toutes
les propriétés graphiques dans une feuille de style séparée, plutôt
que d'écrire ces propriétés directement sous forme d'attributs de ces
éléments.}
%Instead of directly encoding display attributes in the paragraph and text elements of your web pages, with CSS you will define different classes of elements and place all display considerations in a separate style sheet.
Les entités-paragraphes sont appelées \emph{div}s et les
entités-textes sont appelées \emph{span}s.
Vous devriez définir alors définir des noms symboliques pour ces
classes, tels que ``highlight'' (\emph{subbrillance} en français) pour
le texte à mettre en surbrillance, et préciser dans votre feuille de
style comment le texte en surbrillance doit être affiché.
Un feuille de style comprend simplement un ensemble de règles qui
décrivent le format des éléments XHTML donnés. 
Chaque règle se scinde en deux parties: un \emph{sélecteur} qui
dit sur quels éléments XHTML la règle s'applique et une
\emph{déclaration} qui liste un certain nombre d'attributs pour ce ou
ces éléments.

\begin{figure}[tb]
\begin{code}{}
SeasideDemoWidget>>>style
	^ '
body {
	font: 10pt Arial, Helvetica, sans-serif, Times New Roman;
}
h2 {
	font-size: 12pt;
	font-weight: normal;
	font-style: italic;
}
table { border-collapse: collapse; }
td {
	border: 2px solid #CCCCCC;
	padding: 4px;
}
#author {
	border: 1px solid black;
	padding: 2px;
	margin: 2px;
}
.subcomponent {
	border: 2px solid lightblue;
	padding: 2px;
	margin: 2px;
}
.highlight { background-color: yellow; }
.boolean { background-color: lightgrey; }
.field { background-color: lightgrey; }
'
\end{code}
\caption{La feuille de style commune \lct{SeasideDemoWidget}.
\figlabel{democss}}
\end{figure}
\figref{democss} illustre l'exemple d'une simple feuille de style pour
l'application ``Rendering Demo'' vue plus tôt dans
\figref{RenderingDemo}.
La première règle signale une préférence pour les fontes à utiliser
pour le corps de la page web correspondant toujours à l'élément \ct{body}.
Les quelques règles suivantes donnent les propriétés des entêtes de
niveau 2 (\ct{h2}) et celles des tables (\ct{table}) et de leur
cellule (\ct{td} pour \emph{table data}).

Les règles restantes ont des sélecteurs qui correspondent aux éléments
XHTML qui ont le même nom d'attributs ``class'' ou ``id''.
Les sélecteurs CSS pour les attributs de classe nommés ``class''
commencent par un point (``\ct{.}'') et ceux pour les attributs \emph{id}
commencent par un dièse (``\ct{#}'').
La principale différence entre les classes et les attributs \emph{id}
est la suivante: plusieurs éléments peuvent avoir la même classe mais
seul un élément peut avoir un attribut \emph{id} donné (\ie{} un
\emph{id}{dentifant}).
Ainsi, alors qu'une classe comme \ct{highlight} peut être utilisée
plusieurs fois dans un page, un attribut \emph{id} doit identifier un
élément \emph{unique} sur la page, comme un menu particulier par
exemple, ou encore une date modifiée ou un auteur.
Remarquez qu'un élément XHTML particulier peut avoir de multiples
classes; dans ce cas, tous les attributs d'affichage seront appliqués
\arelire{séquentiellement}.
%all the applicable display attributes will be applied in sequence.

% This style sheet expects at most one element to specify the \emph{author} of the web page.

Des conditions au sélecteur peuvent être ajoutées. Ainsi le sélecteur
\ct{div.subcomponent} correspondera seulement à un élément XHTML qui
est à la fois un élément \emph{div} \emph{et} un élément de classe
``subcomponent''.

Il est aussi possible de préciser des éléments imbriqués, bien que
cela soit rarement nécessaire. Par exemple, le sélecteur
``\ct{paragraphe span}'' correspondera à un élément \emph{span} inclus dans un
paragraphe (élément \ct{p}) mais excluera ceux inclus dans un élément
\emph{div}.

Il existe un grand nombre de livres et de sites web sur le sujet des
CSS que vous pourrez consulter pour en apprendre plus.
Pour une démonstration spectaculaire du pouvoir des CSS, nous vous
recommandons de voir le site CSS Zen
Garden\footnote{\url{http://www.csszengarden.com/}} qui présente
comment un même contenu peut avoir un rendu totallement différent
uniquement en changeant de feuille de style.

%-----------------------------------------------------------------
\section{Gérer les flux de contrôle} % REVOIR

Seaside facilite considérablement l'élaboration d'applications web
ayant un flux de contrôle (en anglais, \emph{control flow}) complexe.
%non-trivial control flow.
Deux mécanismes peuvent être utilisées:

\begin{enumerate}
  \item un composant peut appeler\,---\,en anglais,
    \emph{call}\,---\,un autre composant en envoyant
\ct{caller call: callee}
% ajout vf
où \ct{caller} est le composant appelant et \ct{callee} est le
composant appelé.
Le composant appelant est temporairement remplacé par le composant
appelé jusqu'à ce que le \arelire{composant appelé lui rende la main
  en envoyant \ct{answer:} (\ie la réponse).}
%until the callee returns control by sending \ct{answer:}.
L'appelant est généralement \ct{self} mais ce peut être un autre
composant visible;
\seeindex{Seaside!tâche}{Seaside, \task}
  \item un flux d'information (ou \emph{workflow}) peut être défini
    comme une \subind{Seaside}{\task}~\footnote{En français, \emph{tâche}.}.
%A workflow
    C'est un type particulier de composant, sous-classe de
    \clsind{WATask} (et non pas de \clsind{WAComponent}).\seclabel{task}
Au lieu de définir \ct{renderContentOn:}, ce composant ne définit
aucun contenu du lui-même mais définit une méthode \ct{go} qui envoie
une série de messages \ct{call:} pour activer un certain nombre de
composants en retour.
\end{enumerate}
\index{Seaside!flux de contrôle}
\seeindex{Seaside!control flow}{Seaside, flux de contrôle} % REVOIR

%-----------------------------------------------------------------
\subsection{\emph{Call} et \emph{answer}}

\emph{Call} (\cad{} l'appel) et \emph{answer} (\cad la réponse) sont utilisées
pour réaliser des dialogues simples.
% are used to realize simple dialogues.

L'application ``Rendering Demo'' présente un exemple simple de
\ct{call:} et \ct{answer:}.
Le composant \ct{SeasideEditCallDemo} affiche un  displays a text field and an \emph{edit} link.
The callback for the edit link calls a new instance of \ct{SeasideEditAnswerDemo} initialized to the value of the text field.
The callback also updates this text field to the result which is sent as an answer.

(We underline the \ct{call:} and \ct{answer:} sends to draw attention to them.)

\begin{code}{}
SeasideEditCallDemo>>>renderContentOn: html 
	html span
		class: 'field';
		with: self text.
	html space.
	html anchor
		callback: [self text: (self !\underline{call:}! (SeasideEditAnswerDemo new text: self text))];
		with: 'edit'
\end{code}{}

What is particularly elegant is that the code makes absolutely no reference to the new web page that must be created.
At run-time, a new page is created in which the \ct{SeasideEditCallDemo} component is replaced by a \ct{SeasideEditAnswerDemo} component; the parent component and the other peer components are untouched.

\important{\mthind{WAComponent}{call:} and \mthind{WAComponent}{answer:} should never be used while rendering.
They may safely be sent from within a \subind{Seaside}{callback}, or from within the \mthind{WATask}{go} method of a task.}

The \ct{SeasideEditAnswerDemo} component is also remarkably simple.
It just renders a form with a text field.
The submit button is bound to a callback that will answer the final value of the text field.

\begin{code}{}
SeasideEditAnswerDemo>>>renderContentOn: html
	html form: [
		html textInput
			on: #text of: self.
		html submitButton
			callback: [ self !\underline{answer:}! self text ];
			text: 'ok'.
		]
\end{code}{}

That's it.

Seaside takes care of the control flow and the correct rendering of all the components.
Interestingly, the ``back'' button of the browser will also work just fine (though side effects are not rolled back unless we take additional steps).

%-----------------------------------------------------------------
\subsection{Les méthodes utilitaires}
%\subsection{Convenience methods}

Since certain call--answer dialogues are very common, Seaside provides some convenience methods to save you the trouble of writing components like \ct{SeasideEditAnswerDemo}.
The generated dialogues are shown in \figref{dialogs}.
We can see these convenience methods being used within \ct{SeasideDialogDemo>>>renderContentOn:}
\index{Seaside!convenience methods} % REVOIR

\begin{figure}[b]
\begin{center}
\includegraphics[width=\textwidth]{dialogs}
\caption{Some standard dialogs}
\figlabel{dialogs}
\end{center}
\end{figure}

The message \mthind{WAComponent}{request:} performs a call to a component that will let you edit a text field.
The component answers the edited string.
An optional label and default value may also be specified.

\needlines{3}
\begin{code}{}
SeasideDialogDemo>>>renderContentOn: html
	html anchor
		callback: [ self request: 'edit this' label: 'done' default: 'some text' ];
		with: 'self request:'.
...
\end{code}

The message \mthind{WAComponent}{inform:} calls a component that simply displays the argument message and waits for the user to click ``ok''.
The called component just returns \ct{self}.

\begin{code}{}
...
	html space.
	html anchor
		callback: [ self inform: 'yesBANG' ];
		with: 'self inform:'.
...
\end{code}

The message \mthind{WAComponent}{confirm:} asks a questions and waits for the user to select either ``Yes'' or ``No''.
The component answers a boolean, which can be used to perform further actions.

\begin{code}{}
...
	html space.
	html anchor
		callback: [
			(self confirm: 'Are you happy?')
				ifTrue: [ self inform: ':-)' ]
				ifFalse: [ self inform: ':-(' ]
			];
		with: 'self confirm:'.
\end{code}

A few further convenience methods, such as \mthind{WAComponent}{chooseFrom:caption:}, are defined in the \prot{convenience} protocol of \clsind{WAComponent}.

%-----------------------------------------------------------------
\subsection{Les tâches Seaside}

A \subind{Seaside}{task} is a component that subclasses \clsind{WATask}.
It does not render anything itself, but simply calls other components in a control flow defined by implementing the method \mthind{WATask}{go}.

\clsind{WAConvenienceTest} is a simple example of a task defined in the category \scat{Seaside-Tests-Functional}.
To see its effect, just point your browser to \url{http://localhost:8080/seaside/tests/alltests}, select \menu{WAConvenienceTest} and click \button{Restart}.

\begin{code}{}
WAConvenienceTest>>>go
	[ self chooseCheese.
	  self confirmCheese ] whileFalse.
	self informCheese
\end{code}

This task calls in turn three components.
The first, generated by the convenience method \mthind{WAComponent}{chooseFrom: caption:}, is a \clsind{WAChoiceDialog} that asks the user to choose a cheese.

\begin{code}{}
WAConvenienceTest>>>chooseCheese
	cheese := self
		chooseFrom: #('Greyerzer' 'Tilsiter' 'Sbrinz')
		caption: 'What''s your favorite Cheese?'.
	cheese isNil ifTrue: [ self chooseCheese ]
\end{code}

% \alex{Is there a situation where cheese may be nil? Maybe if a browser authorizes an empty selection...}

The second is a \clsind{WAYesOrNoDialog} to confirm the choice (generated by the convenience method \mthind{WAComponent}{confirm:}).

\begin{code}{}
WAConvenienceTest>>>confirmCheese
	^self confirm: 'Is ', cheese,  ' your favorite cheese?'
\end{code}

Finally a \clsind{WAFormDialog} is called (via the convenience method \mthind{WAComponent}{inform:}).

\begin{code}{}
WAConvenienceTest>>>informCheese
	self inform: 'Your favorite cheese is ', cheese, '.'
\end{code}

The generated dialogues are shown in \figref{chooseCheese}.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{chooseCheese}
\caption{Une tâche simple.}
\figlabel{chooseCheese}
\end{center}
\end{figure}

%-----------------------------------------------------------------
\subsection{Transactions} % REVOIR TRADUIRE

We saw in \secref{backtracking} that Seaside can keep track of the correspondence between the state of components and individual web pages by having components register their state for backtracking:
all that a component need do is implement the method \ct{states} to answer an array of all the objects whose state must be tracked.

Sometimes, however, we do not want to backtrack state: instead we want to \emph{prevent} the user from accidentally undoing effects that should be permanent.
This is often referred to as ``the shopping cart problem''.
Once you have checked-out your shopping cart and paid for the items you have purchased, it should not be possible to go ``back'' with the browser and add more items to the shopping cart!

Seaside allows you to prevent this by defining a task within which certain actions are grouped together as \emph{transactions}.
You can backtrack within a transaction, but once a transaction is complete, you can no longer go back to it.
The corresponding pages are \emph{invalidated}, and any attempt to go back to them will cause Seaside to generate a warning and redirect the user to the most recent valid page.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{sushiStore}
\caption{The Sushi Store}
\figlabel{sushiStore}
\end{center}
\end{figure}

The Seaside \emphsubind{Seaside}{Sushi Store} is sample application that illustrates many of the features of Seaside, including transactions.
This application is bundled with your installation of Seaside, so you can try it out by pointing your browser at
\url{http://localhost:8080/seaside/examples/store}.\footnote{If you cannot find it in your image, there is a version of the sushi store available on SqueakSource from \url{http://www.squeaksource.com/SeasideExamples/}.}

The sushi store supports the following workflow:
\begin{enumerate}[itemsep=0pt]
  \item Visit the store.
  \item Browse or search for sushi.
  \item Add sushi to your shopping cart.
  \item Checkout.
  \item Verify your order.
  \item Enter shipping address.
  \item Verify shipping address.
  \item Enter payment information.
  \item Your fish is on its way!
\end{enumerate}

If you toggle the \subind{Seaside}{halos}, you will see that the top-level component of the sushi store is an instance of \clsind{WAStore}.
It does nothing but render the title bar, and then it renders \ct{task}, an instance of \clsind{WAStoreTask}.

\begin{code}{}
WAStore>>>renderContentOn: html
	"... render the title bar ..."
	html div id: 'body'; with: task
\end{code}

\clsind{WAStoreTask} captures this workflow sequence. At a couple of points it is critical that the user not be able to go back and change the submitted information.

\dothis{\,``Purchase'' some sushi and then use the ``back'' button to try to put more sushi into your cart.
You will get the message ``That page has expired.''}

Seaside lets the programmer say that a certain part of a workflow act like a transaction: once the transaction is complete, the user cannot go back and undo it.
You say this by sending \mthind{WAComponent}{isolate:} to a task with the transactional block as its argument.
We can see this in the sushi store workflow as follows:

\begin{code}{}
WAStoreTask>>>go
	| shipping billing creditCard |
	cart := WAStoreCart new.
	self isolate:
		[[self fillCart.
		self confirmContentsOfCart]
			whileFalse].

	self isolate:
		[shipping := self getShippingAddress.
		billing := (self useAsBillingAddress: shipping)
					ifFalse: [self getBillingAddress]
					ifTrue: [shipping].
		creditCard := self getPaymentInfo.
		self shipTo: shipping billTo: billing payWith: creditCard].

	self displayConfirmation.
\end{code}

Here we see quite clearly that there are two transactions.
The first fills the cart and closes the shopping phase.
(The helper methods \ct{fillCart} \etc take care of instantiating and calling the right subcomponents.)
Once you have confirmed the contents of the cart you cannot go back without starting a new session.
The second transaction completes the shipping and payment data.
You can navigate back and forth within the second transaction until you confirm payment.
However, once both transactions are complete, any attempt to navigate back will fail.

Transactions may also be nested.
A simple demonstration of this is found in the class \clsind{WANestedTransaction}.
The first \ct{isolate:} takes as argument a block that contains another, nested \ct{isolate:}

\begin{code}{}
WANestedTransaction>>>go
	self inform: 'Before parent txn'.
	self isolate:
			[self inform: 'Inside parent txn'.
			self isolate: [self inform: 'Inside child txn'].
			self inform: 'Outside child txn'].
	self inform: 'Outside parent txn'
\end{code}

\dothis{Go to \url{http://localhost:8080/seaside/tests/alltests}, select \menu{WATransactionTest} and click on \button{Restart}.
Try to navigate back and forth within the parent and child transaction by clicking the \button{back} button and then clicking \button{ok}.
Note that as soon as a transaction is complete, you can no longer go back inside the transaction without generating an error upon clicking \button{ok}.}

%=================================================================
\section{Un tutoriel complet}

% ON: Should take about two hours

Let's see how we can build a complete Seaside application from scratch.\footnote{The exercise should take at most a couple of hours. If you prefer to just look at the completed source code, you can grab it from the SqueakSource project \url{http://www.squeaksource.com/PharoByExample}.
The package to load is \scat{PBE-SeasideRPN}. The tutorial that follows uses slightly different class names so that you can compare your implementation with ours.}
We will build a RPN (Reverse Polish Notation) calculator as a Seaside application that uses a simple stack machine as its underlying model.
Furthermore, the Seaside interface will let us toggle between two displays\,---\,one which just shows us the current value on top of the stack, and the other which shows us the complete state of the stack.
The calculator with the two display options is shown in \figref{stackMachine}.

\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{stackMachine}
\caption{RPN calculator and its stack machine}
\figlabel{stackMachine}
\end{center}
\end{figure}

We begin by implementing the stack machine and its tests.

\dothis{Define a new class called \ct{MyStackMachine} with an instance variable \ct{contents} initialized to a new \ct{OrderedCollection}.}

\begin{code}{}
MyStackMachine>>>initialize
	super initialize.
	contents := OrderedCollection new.
\end{code}

The stack machine should provide operations to \ct{push:} and \ct{pop} values, view the \ct{top} of the stack, and perform various arithmetic operations to add, subtract, multiply and divide the top values on the stack.

\dothis{Write some tests for the stack operations and then implement these operations.
Here is a sample test:}

\needlines{4}
\begin{code}{}
MyStackMachineTest>>>testDiv
	stack
		push: 3;
		push: 4;
		div.
	self assert: stack size = 1.
	self assert: stack top = (4/3).
\end{code}

You might consider using some helper methods for the arithmetic operations to check that there are two numbers on the stack before doing anything, and raising an error if this precondition is not fulfilled.\footnote{It's a good idea to use \ct{Object>>>assert:} to specify the preconditions for an operation.
This method will raise an \ct{AssertionFailure} if the user tries to use the stack machine in an invalid state.}
If you do this, most  of your methods will just be one or two lines long.

You might also consider implementing \ct{MyStackMachine>>>printOn:} to make it easier to debug your stack machine implementation with the help of an object inspector.
(Hint: just delegate printing to the \ct{contents} variable.)
\index{Object!printOn:@\ct{printOn:}}

\dothis{Complete the \ct{MyStackMachine} by writing operations \ct{dup} (push a duplicate of the top value onto the stack), \ct{exch} (exchange the top two values), and \ct{rotUp} (rotate the entire stack contents up\,---\,the top value will move to the bottom).}

Now we have a simple stack machine implementation.
We can start to implement the Seaside RPN Calculator.

We will make use of 5 classes:
\begin{itemize}
  \item \ct{MyRPNWidget}\,---\,this should be an abstract class that defines the common CSS style sheet for the application, and other common behavior for the components of the RPN calculator.
  It is a subclass of \ct{WAComponent} and the direct superclass of the following four classes. 
  
    \item \ct{MyCalculator}\,---\,this is the root component.
  It should register the application (on the class side), it should instantiate and render its subcomponents, and it should register any state for backtracking.
  \item \ct{MyKeypad}\,---\,this displays the keys that we use to interact with the calculator.
  \item \ct{MyDisplay}\,---\,this component displays the top of the stack and provides a button to call another component to display the detailed view.
  \item \ct{MyDisplayStack}\,---\,this component shows the detailed view of the stack and provides a button to answer back.
  It is a subclass of \lct{MyDisplay}.
\end{itemize}

\dothis{Define \ct{MyRPNWidget} in the category \ct{MyCalculator}.
Define the common \ct{style} for the application.}

Here is a minimal CSS for the application.
You can make it more fancy if you like.
\begin{code}{}
MyRPNWidget>>>style
	^ 'table.keypad { float: left; }
td.key {
	border: 1px solid grey;
	background: lightgrey;
	padding: 4px;
	text-align: center;
}
table.stack { float: left; }
td.stackcell {
	border: 2px solid white;
	border-left-color: grey;
	border-right-color: grey;
	border-bottom-color: grey;
	padding: 4px;
	text-align: right;
}
td.small { font-size: 8pt; }'
\end{code}

\dothis{Define \ct{MyCalculator} to be a root component and register itself as an application (\ie implement \ct{canBeRoot} and \ct{initialize} on the class side).
Implement \ct{MyCalculator>>>renderContentOn:} to render something trivial (such as its name), and verify that the application runs in a browser.
}

\ct{MyCalculator} is responsible for instantiating \ct{MyStackMachine}, \ct{MyKeypad} and \ct{MyDisplay}.

\dothis{
Define \ct{MyKeypad} and \ct{MyDisplay} as subclasses of \lct{MyRPNWidget}.
All three components will need access to a common instance of the stack machine, so define the instance variable \ct{stackMachine} and an initialization method \ct{setMyStackMachine:} in the common parent, \ct{MyRPNWidget}.
Add instance variables \ct{keypad} and \ct{display} to \ct{MyCalculator} and initialize them in \ct{MyCalculator>>>initialize}.
(Don't forget to send \lct{super initialize}!)}

\dothis{
Pass the shared instance of the stack machine to the keypad and the display in the same initialize method.
Implement \ct{MyCalculator>>>renderContentOn:} to simply render in turn the keypad and the display.
To correctly display the subcomponents, you must implement \ct{MyCalculator>>>children} to return an array with the keypad and the display.
Implement placeholder rendering methods for the keypad and the display and verify that the calculator now displays its two subcomponents.
}

%\ab{Too long!}

Now we will change the implementation of the display to show the top value of the stack.

\dothis{
Use a table with class ``keypad'' containing a row with a single table data cell with class ``stackcell''.
Change the rendering method of the keypad to ensure that the number 0 is pushed on the stack in case it is empty.
(Define and use \ct{MyKeypad>>>ensureMyStackMachineNotEmpty}.)
Also make it display an empty table with class ``keypad''.
Now the calculator should display a single cell containing the value 0.
If you toggle the halos, you should see something like this:
}

\begin{figure}[ht]
\begin{center}
\includegraphics[width=0.8\textwidth]{firstStackDisplay}
\caption{Displaying the top of the stack}
\figlabel{firstStackDisplay}
\end{center}
\end{figure}

Now let's implement an interface to interact with the stack.

\dothis{
First define the following helper methods, which will make it easier to script the interface:
}

\needlines{3}
\begin{code}{}
MyKeypad>>>renderStackButton: text callback: aBlock colSpan: anInteger on: html 
	html tableData
		class: 'key';
		colSpan: anInteger;
		with: 
				[html anchor
					callback: aBlock;
					with: [html html: text]]
\end{code}


\begin{code}{}
MyKeypad>>>renderStackButton: text callback: aBlock on: html 
	self 
		renderStackButton: text
		callback: aBlock
		colSpan: 1
		on: html
\end{code}

We will use these two methods to define the buttons on the keypad with appropriate \callbacks.
Certain buttons may span multiple columns, but the default is to occupy just one column.

\dothis{
Use the two helper methods to script the keypad as follows:
(Hint: start by getting the digit and ``Enter'' keys working, then the arithmetic operators.)
}

\needlines{4}
\begin{code}{}
MyKeypad>>>renderContentOn: html 
  self ensureStackMachineNotEmpty.
  html table
    class: 'keypad';
    with: [
      html tableRow: [
          self renderStackButton: '+' callback: [self stackOp: #add] on: html.
          self renderStackButton: '&ndash;' callback: [self stackOp: #min] on: html.
          self renderStackButton: '&times;' callback: [self stackOp: #mul] on: html.
          self renderStackButton: '&divide;' callback: [self stackOp: #div] on: html.
          self renderStackButton: '&plusmn;' callback: [self stackOp: #neg] on: html ].
        html tableRow: [
          self renderStackButton: '1' callback: [self type: '1'] on: html.
          self renderStackButton: '2' callback: [self type: '2'] on: html.
          self renderStackButton: '3' callback: [self type: '3'] on: html.
          self renderStackButton: 'Drop' callback: [self stackOp: #pop]
          	colSpan: 2 on: html ].
" and so on ... "
        html tableRow: [
          self renderStackButton: '0' callback: [self type: '0'] colSpan: 2 on: html.
          self renderStackButton: 'C' callback: [self stackClearTop] on: html.
          self renderStackButton: 'Enter'
          	callback: [self stackOp: #dup. self setClearMode]
			colSpan: 2 on: html ]]
\end{code}

Check that the keypad displays properly.
If you try to click on the keys, however, you will find that the calculator does not work yet ...

\dothis{
Implement \ct{MyKeypad>>>type:} to update the top of the stack by appending the typed digit.
You will need to convert the top value to a string, update it, and convert it back to an integer, something like this:
}
\begin{code}{}
MyKeypad>>>type: aString
	stackMachine push: (stackMachine pop asString, aString) asNumber.
\end{code}
Now when you click on the digit keys the display should be updated.
(Be sure that \ct{MyStackMachine>>>pop} returns the value popped, or this will not work!)


\dothis{Now we must implement \ct{MyKeypad>>>stackOp:}
Something like this will do the trick:}

\begin{code}{}
MyKeypad>>>stackOp: op
	[ stackMachine perform: op ] on: AssertionFailure do: [ ].
\end{code}

The point is that we are not sure that all operations will succeed, for example, addition will fail if we do not have two numbers on the stack.
For the moment we can just ignore such errors.
If we are feeling more ambitious later on, we can provide some user feedback in the error handler block.

\dothis{The first version of the calculator should be working now.
Try to enter some numbers by pressing the digit keys, hitting \menu{Enter} to push a copy of the current value, and entering \menu{+} to sum the top two values.}

You will notice that typing digits does not behave the way you might expect.
Actually the calculator should be aware of whether you are typing a \emph{new} number, or appending to an existing number.

\dothis{Adapt \ct{MyKeypad>>>type:} to behave differently depending on the current typing mode.
Introduce an instance variable \ct{mode} which takes on one of the three values \lct{typing} (when you are typing), \lct{push} (after you you have performed a calculator operation and typing should force the top value to be pushed), or \lct{clear} (after you have performed \menu{Enter} and the top value should be cleared before typing).
The new \ct{type:} method might look like this:
}

\begin{code}{}
MyKeypad>>>type: aString
	self inPushMode ifTrue: [
		stackMachine push: stackMachine top.
		self stackClearTop ].
	self inClearMode ifTrue: [ self stackClearTop ].
	stackMachine push: (stackMachine pop asString, aString) asNumber.
\end{code}

Typing might work better now, but it is still frustrating not to be able to see what is on the stack.

\dothis{
Define \ct{MyDisplayStack} as a subclass of \ct{MyDisplay}.
Add a button to the rendering method of \ct{MyDisplay} which will call a new instance of \ct{MyDisplayStack}.
You will need an html anchor that looks something like this:
}

\begin{code}{}
html anchor
	callback: [ self call: (MyDisplayStack new setMyStackMachine: stackMachine)];
	with: 'open'
\end{code}

The callback will cause the current instance of \ct{MyDisplay} to be temporarily replaced by a new instance of \ct{MyDisplayStack} whose job it is to display the complete stack.
When this component signals that it is done (\ie by sending \ct{self answer}), then control will return to the original instance of \ct{MyDisplay}.

\dothis{
Define the rendering method of \ct{MyDisplayStack} to display all of the values on the stack.
(You will either need to define an accessor for the stack machine's \ct{contents} or you can define \ct{MyStackMachine>>>do:} to iterate over the stack values.)
The stack display should also have a button labelled ``close'' whose callback will simply perform \ct{self answer}.
}

\begin{code}{}
html anchor
	callback: [ self answer];
	with: 'close'
\end{code}

Now you should be able to \emph{open} and \emph{close} the stack while you are using the calculator.

There is, however, one thing we have forgotten.
Try to perform some operations on the stack.
Now use the ``back'' button of your browser and try to perform some more stack operations.
(For example, \menu{open} the stack, type \menu{1}, \menu{Enter} twice and \menu {+}.
The stack should display ``2'' and ``1''.
Now hit the ``back'' button.
The stack now shows three times ``1'' again.
Now if you type \menu{+} the stack shows ``3''.
Backtracking is not yet working.

\dothis{
Implement \ct{MyCalculator>>>states} to return the contents of the stack machine.
Check that backtracking now works correctly!
}

Sit back and enjoy a tall glass of something cool!

%=================================================================
\section{Un bref coup d'\oe il sur la technologie AJAX}

% Original text by Lukas Renggli

\ind{AJAX} (Asynchronous \ind{JavaScript} and \ind{XML}) is a technique to make web applications more interactive by exploiting JavaScript functionality on the client side.

Two well-known JavaScript libraries are \ind{Prototype} (\url{http://www.prototypejs.org}) and \ind{script.aculo.us} (\url{http://script.aculo.us}).
Prototype provides a framework to ease writing JavaScript.
script.aculo.us provides some additional features to support animations and drag-and-drop on top of Prototype.
Both frameworks are supported in Seaside through the package ``Scriptaculous''.

All ready-made images have the Scriptaculous package extensions already loaded.
The latest version is available from \url{http://www.squeaksource.com/Seaside}.
An online demo is available at \url{http://scriptaculous.seasidehosting.st}.
Alternatively, if you have a enabled image running, simply go to \url{http://localhost:8080/seaside/tests/scriptaculous}.

The Scriptaculous extensions follow the same approach as Seaside itself\,---\,simply configure Smalltalk objects to model your application, and the needed Javascript code will be generated for you.

Let us look at a simple example of how client-side Javascript support can make our RPN calculator behave more naturally.
Currently every keystroke to enter a digit generates a request to refresh the page.
We would like instead to handle editing of the display on the client-side by updating the display in the existing page.

\dothis{To address the display from JavaScript code we must first give it a unique id.
Update the calculator's rendering method as follows:\footnote{If you have not implemented the tutorial example yourself, you can simply load the complete example (PBE-SeasideRPN) from \url{http://www.squeaksource.com/PharoByExample} and apply the suggested changes to the classes \ct{RPN*} instead of \ct{My*}.}}

\begin{code}{}
MyCalculator>>>renderContentOn: html
	html div id: 'keypad'; with: keypad.
	html div id: 'display'; with: display.	
\end{code}
				
\dothis{To be able to re-render the display when a keyboard button is pressed, the keyboard needs to know the display component.
Add a \ct{display} instance variable to \ct{MyKeypad}, an initialize method \ct{MyKeypad>>>setDisplay:}, and call this from \ct{MyCalculator>>initialize}.
Now we are able to assign some JavaScript code to the buttons by updating \ct{MyKeypad>>>renderStackButton:callback:colSpan:on:} as follows:}

\begin{code}{}
MyKeypad>>>renderStackButton: text callback: aBlock colSpan: anInteger on: html 
	html tableData
		class: 'key';
		colSpan: anInteger;
		with: [
			html anchor
				callback: aBlock;
				onClick:				"handle Javascript event"
					(html updater
						id: 'display';
						callback: [ :r |
							aBlock value.
							r render: display ];
						return: false);
				with: [ html html: text ] ]
\end{code}

\mthind{WATagBrush}{onClick:} specifies a \ind{JavaScript} event handler.
\ct{html updater} returns an instance of \ct{SUUpdater}, a Smalltalk object representing the JavaScript Ajax.Updater object (\url{http://www.prototypejs.org/api/ajax/updater}).
This object performs an AJAX request and updates a container's contents based on the response text.
\ct{id:} tells the updater what XHTML DOM element to update, in this case the contents of the div element with the id 'display'.
\ct{callback:} specifies a block that is triggered when the user presses the button.
The block argument is a new renderer \ct{r}, which we can use to render the display component.
(Note: Even though html is still accessible, it is not valid anymore at the time this callback block is evaluated).
Before rendering the display component we evaluate \ct{aBlock} to perform the desired action.

\ct{return: false} tells the JavaScript engine to not trigger the original link callback, which would cause a full refresh.
We could instead remove the original anchor \ct{callback:}, but like this the calculator will still work even if JavaScript is disabled.

\dothis{Try the calculator again, and notice how a full page refresh is triggered every time you press a digit key. (The URL of the web page is updated at each keystroke.)}

Although we have implemented the client-side behavior, we have not yet activated it.
Now we will enable the Javascript event handling.

\dothis{
Click on the \link{Configure} link in the toolbar of the calculator.
Select ``Add Library:'' \ct{SULibrary}, click the \button{Add} button and \button{Close}.}

Instead of manually adding the library, you may also do it programmatically when you register the application:
\begin{code}{}
MyCalculator class>>>initialize
	(self registerAsApplication: 'rpn')
		addLibrary: SULibrary}}
\end{code}

\begin{figure}[ht]
\begin{center}
\includegraphics[width=\textwidth]{ajax-processing}
\caption{Seaside AJAX processing (simplified)}
\figlabel{ajax-processing}
\end{center}
\end{figure}

\dothis{Try the revised application.  Note that the feedback is much more natural. In particular, a new URL is not generated with each keystroke.}

You may well ask, \emph{yes, but how does this work?}
\figref{ajax-processing} shows how the RPN applications would both without and with AJAX.
Basically AJAX short-circuits the rendering to \emph{only} update the display component.
Javascript is responsible both for triggering the request and updating the corresponding DOM element.
Have a look at the generated source-code, especially the JavaScript code:

\begin{code}{}
new Ajax.Updater(
	'display',
	'http://localhost/seaside/RPN+Calculator',
	{'evalScripts': true,
	  'parameters': ['UNDERSCOREs=zcdqfonqwbeYzkza', 'UNDERSCOREk=jMORHtqr','9'].join('&')});
return false
\end{code}

For more advanced examples, have a further look at \url{http://localhost:8080/seaside/tests/scriptaculous}.

\paragraph{\emph{Astuces.}}
In case of server side problems use the Smalltalk debugger.
In case of client side problems use FireFox (\url{http://www.mozilla.com}) with the JavaScript debugger FireBug (\url{http://www.getfirebug.com/}) plugin enabled.

%=================================================================
\section{Résumé du chapitre}

\begin{itemize}
  \item The easiest way to get started is to download the ``Seaside One-Click Experience'' from \url{http://seaside.st}
  \item Turn the server on and off by evaluating \ct{WAKom startOn: 8080} and \ct{WAKom stop}.
  \item Reset the administrator login and password by evaluating \ct{WADispatcherEditor initialize}.
  \item \menu{Toggle Halos} to directly view application source code, run-time objects, CSS and XHTML.
  \item Send \ct{WAGlobalConfiguration setDeploymentMode} to hide the toolbar.
  \item Seaside web applications are composed of components, each of which is an instance of a subclass of \ct{WAComponent}.
  \item Only a root component may be registered as a component. It should implement \ct{canBeRoot} on the class side. Alternatively it may register itself as an application in its class-side \ct{initialize} method by sending \ct{self registerAsApplication:} \emph{application path}.
  If you override \ct{description} it is possible to return a descriptive application name that will be displayed in the configuration editor.
  \item To backtrack state, a component must implement the \ct{states} method to answer an array of objects whose state will be restored if the user clicks the browser's ``back'' button.
  \item A component renders itself by implementing \ct{renderContentOn:}.
  The argument to this method is an XHTML rendering \emph{canvas} (usually called \ct{html}).
  \item A component can render a subcomponent by sending \ct{self render:} \emph{subcomponent}.
  \item XHTML is generated programmatically by sending messages to \emph{brushes}. A brush is obtained by sending a message, such as \ct{paragraph} or \ct{div}, to the html canvas.
  \item If you send a cascade of messages to a brush that includes the message \ct{with:}, then \ct{with:} should be the last message sent.
  Thw \ct{with:} message sets the contents \emph{and} renders the result.
  \item Actions should appear only in \callbacks (ou fonction de rappel).
You should not change the state of the application while you are rendering it.
  \item You can bind various form widgets and anchors to instance variables with accessors by sending the message \ct{on:} \emph{instance variable} \ct{of:} \emph{object} to the brush.
  \item You can define the CSS for a component hierarchy by defining the method \ct{style}, which should return a string containing the style sheet.
  (For deployed applications, it is more usual to refer to a style sheet located at a static URL.)
  \item Control flows can be programmed by sending \ct{x call: y}, in which case component \ct{x} will be replaced by \ct{y} until \ct{y} answers by sending \ct{answer:} with a result in a callback.
  The receiver of \ct{call:} is usually \ct{self}, but may in general be any visible component.
  \item A control flow can also be specified as a \emph{task}\,---\,a instance of a subclass of \ct{WATask}. It should implement the method \ct{go}, which should \ct{call:} a series of components in a workflow.
  \item Use \ct{WAComponents}'s convenience methods \ct{request:}, \ct{inform:}, \ct{confirm:} and \ct{chooseFrom:caption:} for basic interactions.
  \item To prevent the user from using the browser's ``back'' button to access a previous execution state of the web application, you can declare portions of the workflow to be a \emph{transaction} by enclosing them in an \ct{isolate:} block.
\end{itemize}
%-----------------------------------------------------------------

%=================================================================
\ifx\wholebook\relax\else 
   \bibliographystyle{jurabib}
   \nobibliography{scg}
   \end{document}
\fi
%=================================================================
